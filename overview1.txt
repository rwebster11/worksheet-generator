import os
import io
import re # For parsing YouTube URL
import random # Needed for word search logic
from copy import deepcopy # Needed for word search logic
import traceback # Import traceback for detailed error logging
import logging # Import standard logging
from datetime import datetime, timezone # Added timezone for UTC awareness
from PIL import Image, ImageDraw, ImageFont
import math
# Third-party imports
import anthropic
import httpx # Still needed by Anthropic client internally, even without proxy
from dotenv import load_dotenv
from flask import Flask, request, jsonify, send_from_directory, send_file
from flask_sqlalchemy import SQLAlchemy
from bs4 import BeautifulSoup
import docx
from docx.shared import Inches, Pt
from youtube_transcript_api import YouTubeTranscriptApi, TranscriptsDisabled, NoTranscriptFound # Keep for now
import json
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
import uuid # For generating unique filenames
from werkzeug.utils import secure_filename # For basic filename security (optional but good practice)
from PIL import Image, ImageDraw, ImageFont # For DOCX image generation
import io # For handling image data in memory
import json
# Configure basic logging early
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s:%(name)s:%(message)s')

# Load environment variables from .env file
logging.info("Attempting to load .env file...")
dotenv_path = os.path.join(os.path.dirname(__file__), '.env') # Explicit path
found_dotenv = load_dotenv(dotenv_path=dotenv_path, verbose=True) # Be verbose
logging.info(f".env file found and loaded: {found_dotenv}")
# Removed duplicate load_dotenv()

# Initialize the Flask application
app = Flask(__name__)

# --- Database Configuration ---
basedir = os.path.abspath(os.path.dirname(__file__))
db_path = os.path.join(basedir, 'worksheet_library.db')
app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
# --- End Database Configuration ---
# --- Upload Folder Configuration --- ADD THIS SECTION ---
UPLOAD_FOLDER = os.path.join(basedir, 'static', 'uploads')
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)
    logging.info(f"Created upload folder at: {UPLOAD_FOLDER}")
else:
    logging.info(f"Upload folder exists at: {UPLOAD_FOLDER}")
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024 # Example: 16MB upload limit
# --- End Upload Folder Configuration ---
# Initialize the SQLAlchemy extension
db = SQLAlchemy(app)

# --- Database Model Definitions ---

# Association Table: Links Worksheets and GeneratedItems, storing order
worksheet_items_association = db.Table('worksheet_items_association',
    db.metadata,
    db.Column('worksheet_id', db.Integer, db.ForeignKey('worksheet.id'), primary_key=True),
    db.Column('generated_item_id', db.Integer, db.ForeignKey('generated_item.id'), primary_key=True), # Matches your column name
    db.Column('item_order', db.Integer, nullable=False)
)

# GeneratedItem Model
class GeneratedItem(db.Model):
    __tablename__ = 'generated_item'
    id = db.Column(db.Integer, primary_key=True)
    item_type = db.Column(db.String(50), nullable=False)
    source_topic = db.Column(db.String(250), nullable=True)
    source_url = db.Column(db.String(500), nullable=True)
    grade_level = db.Column(db.String(50), nullable=False)
    content_html = db.Column(db.Text, nullable=False)
    item_data_json = db.Column(db.Text, nullable=True)
    creation_date = db.Column(db.DateTime(timezone=True), nullable=False, default=lambda: datetime.now(timezone.utc))
    last_modified_date = db.Column(db.DateTime(timezone=True), nullable=False, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))

    worksheets = db.relationship(
        'Worksheet',
        secondary='worksheet_items_association',
        back_populates='items',
        lazy='selectin'
    )

    def __repr__(self):
        return f'<GeneratedItem id={self.id} type={self.item_type}>'

# Worksheet Model
class Worksheet(db.Model):
    __tablename__ = 'worksheet'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(250), nullable=False, default="Untitled Worksheet")
    creation_date = db.Column(db.DateTime(timezone=True), nullable=False, default=lambda: datetime.now(timezone.utc))
    last_modified_date = db.Column(db.DateTime(timezone=True), nullable=False, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))

    items = db.relationship(
        'GeneratedItem',
        secondary='worksheet_items_association',
        order_by=worksheet_items_association.c.item_order,
        back_populates='worksheets',
        lazy='selectin'
    )

    def __repr__(self):
        return f'<Worksheet id={self.id} title="{self.title}">'

# Configure mappers after models are defined
db.configure_mappers()

# --- Anthropic Client Initialization ---
client = None
try:
    logging.info("Attempting to initialize Anthropic client...")
    api_key_from_env = os.getenv("ANTHROPIC_API_KEY")
    if not api_key_from_env:
        logging.error("CRITICAL: ANTHROPIC_API_KEY not found in environment variables.")
    else:
        logging.info("ANTHROPIC_API_KEY found. Initializing client...")
        # Initialize without unused proxy setup
        client = anthropic.Anthropic(api_key=api_key_from_env)
        logging.info("Anthropic client object CREATED successfully.")
except Exception as e:
    logging.error(f"CRITICAL: Exception during Anthropic client initialization: {e}", exc_info=True)
    client = None

if client is None:
    logging.warning("Anthropic client is None after initialization attempt.")
else:
    logging.info("Anthropic client appears to be initialized.")

ANTHROPIC_MODEL_NAME = "claude-3-opus-20240229"

# --- Prompt Creation Functions ---
def create_mcq_prompt(topic, grade_level, num_questions=5):
    # ... (keep function as is) ...
    prompt = f"""You are an expert curriculum developer creating assessment questions.
Generate {num_questions} multiple-choice questions (MCQs) about the topic '{topic}'.
The target audience is {grade_level} students.

**CRITICAL INSTRUCTIONS for Output Format:**
1.  **Question Generation:** Create {num_questions} distinct MCQs covering different important aspects of the topic. Adapt vocabulary and complexity for the {grade_level}.
2.  **Options:** For each question, provide exactly four options: one correct answer (labeled A, B, C, or D) and three plausible distractors.
3.  **Formatting:**
    *   Present each question clearly, starting with a number (e.g., "1.", "2.").
    *   List the options below each question, labeled "A.", "B.", "C.", "D.".
    *   **DO NOT** indicate the correct answer within the question/option list itself.
4.  **Answer Key:** After ALL questions and their options are listed, provide a separate section titled exactly "Answer Key:".
5.  **Key Format:** In the Answer Key section, list the question number and the correct option letter (e.g., "1. C", "2. A", "3. B", etc.), each on a new line.
6.  **Strict Output:** Output ONLY the numbered questions with their A/B/C/D options, followed by the "Answer Key:" section and the key itself. No extra text, introductions, or explanations.

Topic: {topic}
Audience: {grade_level}

MCQs:
"""
    return prompt

def create_word_list_prompt(topic, grade_level, num_words=15):
    # ... (keep function as is) ...
    prompt = f"""You are a helpful vocabulary assistant.
Generate a list of exactly {num_words} single keywords or very short (2-word max) key phrases relevant to the topic '{topic}' for a {grade_level} audience.

**Instructions:**
1.  Focus on specific nouns, verbs, or essential terms related to '{topic}'.
2.  Ensure words are appropriate for the {grade_level}.
3.  Provide *only* the list of words/phrases.
4.  Format the output as a numbered list (e.g., "1. Photosynthesis", "2. Chlorophyll", "3. Carbon Dioxide").
5.  Do not include definitions, explanations, or any text other than the numbered list.

Topic: {topic}
Audience: {grade_level}
Number of Words: {num_words}

Keyword List:
"""
    return prompt

def create_text_block_prompt(topic, grade_level, focus=None):
    # ... (keep function as is) ...
    focus_instruction = f"Focus on: {focus}" if focus else "Provide a general overview."
    prompt = f"""You are a helpful assistant generating informational content.
Write a clear and concise text block about the topic '{topic}'.
The target audience is {grade_level} students.
{focus_instruction}
Aim for 1-3 paragraphs unless specified otherwise.
Ensure the language is appropriate for the specified grade level.

**Output ONLY the text block itself.** No titles, introductions, or extra formatting other than paragraphs.

Topic: {topic}
Audience: {grade_level}

Text Block:
"""
    return prompt

def create_true_false_prompt(topic, grade_level, num_statements=8):
    # ... (keep function as is) ...
    prompt = f"""You are an expert educator creating assessment materials.
Generate {num_statements} True/False statements about the core concepts of the topic '{topic}'.
The target audience is {grade_level} students.

**CRITICAL INSTRUCTIONS:**
1.  **Statement Generation:** Create {num_statements} clear statements. Ensure a mix of reasonably challenging statements that are definitively TRUE and definitively FALSE based on common knowledge for the {grade_level} audience regarding the topic '{topic}'. Avoid ambiguity or opinion-based statements.
2.  **Formatting:** Present each statement clearly, starting with a number (e.g., "1.", "2.").
3.  **Answer Key:** After ALL statements are listed, provide a separate section titled exactly "Answer Key:".
4.  **Key Format:** In the Answer Key section, list the statement number followed by the word "True" or "False" (e.g., "1. True", "2. False", "3. True", etc.), each on a new line.
5.  **Strict Output:** Output ONLY the numbered statements, followed by the "Answer Key:" section and the key itself. No extra text, introductions, or explanations.

Topic: {topic}
Audience: {grade_level}

True/False Statements:
"""
    return prompt

def create_gap_fill_prompt(topic, grade_level="middle school", num_sentences=7):
    # ... (keep function as is) ...
    prompt = f"""You are an expert teacher creating educational resources.
Generate a gap-fill (cloze) activity about the topic '{topic}'.
The target audience is {grade_level} students.

**Instructions:**
1.  Create exactly {num_sentences} unique sentences. Each sentence **MUST** focus on a **different** important aspect or key term of the topic '{topic}'. Do not just rephrase the same core idea.
2.  In each sentence, identify the single most important key term or concept specific to that sentence's point and replace it with '_________'.
3.  **CRITICAL REQUIREMENT: Each blank MUST be fillable with a DIFFERENT word.** Do NOT reuse the same answer word for multiple blanks. The goal is to test a variety of key vocabulary related to the topic. Using the exact same word in two or more blanks is forbidden.
4.  After the sentences, provide a numbered list titled 'Answer Key:' that clearly lists the single word removed for each blank in the correct order.
5.  Output ONLY the worksheet sentences and the Answer Key. No introductory phrases, explanations, conversational text, or titles other than 'Answer Key:'.

Topic: {topic}
Audience: {grade_level}
Number of Sentences: {num_sentences}

Worksheet:
"""
    return prompt

def extract_video_id(url): # Keep for now
    # ... (keep function as is) ...
    patterns = [
        r'(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})',
        r'(?:https?:\/\/)?(?:www\.)?youtu\.be\/([a-zA-Z0-9_-]{11})',
        r'(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([a-zA-Z0-9_-]{11})',
        r'(?:https?:\/\/)?(?:www\.)?youtube\.com\/v\/([a-zA-Z0-9_-]{11})',
    ]
    for pattern in patterns:
        match = re.search(pattern, url)
        if match: return match.group(1)
    return None

def create_comprehension_prompt(transcript_text, num_questions=5): # Keep for now
    # ... (keep function as is) ...
    prompt = f"""You are an expert educator. Based on the following video transcript, please generate {num_questions} insightful comprehension questions that test understanding of the key information presented.

**Instructions for Questions:**
1.  Ensure questions cover different aspects of the transcript (e.g., main ideas, specific details, inferences if possible).
2.  Phrase questions clearly and concisely.
3.  The questions should be suitable for someone who has just watched the video (assume context from the transcript).
4.  Do NOT provide the answers to the questions.
5.  Format the output as a numbered list.
6.  Output ONLY the numbered list of questions, nothing else (no preamble like "Here are the questions:").

**Video Transcript:**
--- START TRANSCRIPT ---
{transcript_text}
--- END TRANSCRIPT ---

**{num_questions} Comprehension Questions:**
"""
    return prompt

def create_pasted_comprehension_prompt(pasted_text, num_questions=5):
    # ... (keep function as is) ...
    max_chars = 15000
    truncated_text = pasted_text[:max_chars]
    if len(pasted_text) > max_chars: print(f"Warning: Pasted text truncated to {max_chars} chars for AI prompt.")
    prompt = f"""You are an expert educator designing reading comprehension assessments.
Based *only* on the following provided text passage, generate {num_questions} insightful comprehension questions that test understanding of the key information presented within that text.
Also provide a brief answer key outlining the expected points or a model answer for each question based *only* on the provided text.

**CRITICAL INSTRUCTIONS:**
1.  **Question Generation:** Create {num_questions} distinct questions directly related to the content of the provided text passage. Questions should require recall, explanation, or analysis *of the passage*.
2.  **Question Formatting:** Present each question clearly, starting with a number (e.g., "1.", "2.").
3.  **Answer Key Generation:** After ALL questions are listed, provide a separate section titled exactly "Answer Key:".
4.  **Key Content:** For each question number in the Answer Key section, provide key points or a model answer derived *solely from the provided passage*.
5.  **Key Formatting:** Start each answer key item with the corresponding question number (e.g., "1.", "2.").
6.  **Strict Output:** Output ONLY the numbered list of questions, followed by the "Answer Key:" section and the key itself. No extra text, introductions, or commentary about the text quality.

**Provided Text Passage:**
--- START TEXT ---
{truncated_text}
--- END TEXT ---

**{num_questions} Comprehension Questions:**
[Generate Questions Here Following Format]

Answer Key:
[Generate Answer Key Here Following Format]
"""
    return prompt

def create_short_answer_prompt(topic, grade_level, num_questions=5):
    # ... (keep function as is) ...
    prompt = f"""You are an expert educator designing formative assessments.
Generate {num_questions} open-ended short answer questions about the key aspects of the topic '{topic}'.
Also provide a brief answer key outlining the expected points or a model answer for each question.
The target audience is {grade_level} students.

**CRITICAL INSTRUCTIONS:**
1.  **Question Generation:** Create {num_questions} distinct questions that require students to recall, explain, or briefly analyze information related to '{topic}'. Questions should encourage answers of 1-3 sentences. Adapt vocabulary and complexity for the {grade_level}.
2.  **Question Formatting:** Present each question clearly, starting with a number (e.g., "1.", "2."). List each question on a new line.
3.  **Answer Key Generation:** After ALL questions are listed, provide a separate section titled exactly "Answer Key:".
4.  **Key Content:** For each question number in the Answer Key section, provide either:
    *   A bulleted list of the key facts/points expected in a good answer.
    *   OR a brief model answer (1-2 sentences).
    Keep the answer key concise and focused on grading criteria.
5.  **Key Formatting:** Start each answer key item with the corresponding question number (e.g., "1.", "2.").
6.  **Strict Output:** Output ONLY the numbered list of questions, followed by the "Answer Key:" section and the key itself. No extra text, introductions, or explanations.

Topic: {topic}
Audience: {grade_level}

Short Answer Questions:
[Generate Questions Here Following Format]

Answer Key:
[Generate Answer Key Here Following Format]
"""
    return prompt

def create_similar_questions_prompt(example_question, num_questions=3, grade_level="Not Specified"):
    # ... (keep function as is) ...
    prompt = f"""
You are an expert question designer replicating educational assessment items. Your task is to analyze the provided example question, identify the core concept and calculation type being tested, and then generate {num_questions} NEW questions that assess the SAME core concept at a SIMILAR difficulty level suitable for {grade_level} students.

**Analysis of Example:**
First, briefly state the core concept or skill tested by the example question. (e.g., "Calculating speed given distance and time", "Solving a two-step linear equation", "Calculating molarity").

**Instructions for New Questions:**
1.  **Maintain Core Concept:** Each new question MUST test the exact same fundamental principle or calculation type as the example.
2.  **Maintain Difficulty:** The complexity of the numbers used, the number of steps required, and the required conceptual understanding should closely match the example question and be appropriate for the target {grade_level}.
3.  **Construct Realistic Scenarios:** For each new question:
    a.  **Determine a realistic target answer** appropriate for the concept and grade level (e.g., a percentage yield between 60-95%, a reasonable speed for a car).
    b.  **Work Backwards:** Choose plausible input numbers (like initial mass, theoretical yield, distance, time, etc.) that will mathematically lead to the target answer you determined. Ensure these input numbers are also contextually sensible (e.g., realistic masses, times, distances).
    c.  **Vary Context & Specifics:** Create a genuinely new scenario (different chemicals, objects, situations) using these generated numbers. You can vary units where appropriate (e.g., grams to kg) and potentially the specific variable being solved for (if applicable), while keeping the underlying problem type identical to the example. Do NOT just rephrase the example question.
4.  **Formatting:** Present each new question clearly, starting with a number (e.g., "1.", "2."). List each question on a new line.
5.  **Answer Key Generation:** After ALL new questions are listed, provide a separate section titled exactly "Answer Key:".
6. Key Content: In the Answer Key section, for each question number, show the key calculation steps required to solve the problem, followed by the final numerical answer (including units if appropriate). Make the steps clear and concise.

    Example Format:
    1. Steps:
       Step 1: Formula (e.g., Speed = Distance / Time)
       Step 2: Substitute values (e.g., Speed = 300 miles / 5 hours)
       Step 3: Calculate (e.g., Speed = 60)
       Final Answer: 60 mph
    2. Steps:
       ...
       Final Answer: ...

7.  **Strict Output:** Output ONLY the brief "Analysis of Example", the numbered list of new questions, the "Answer Key:" title, and the key itself. No extra text, introductions, or explanations.

**Example Question Provided:**
--- START EXAMPLE ---
{example_question}
--- END EXAMPLE ---

**Analysis of Example:**
[AI writes analysis here]

**{num_questions} New Similar Questions:**
[AI generates new questions here]

Answer Key:
[AI generates answer key for the NEW questions here]
"""
    return prompt

# --- Word Search Generation Logic (Adapted from make_wordsearch.py) ---

# Constants
NMAX_GRID = 32
ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

# --- Masking Functions ---
def circle_mask(grid, nrows, ncols):
    r2 = min(ncols, nrows)**2 // 4
    cx, cy = ncols//2, nrows // 2
    for irow in range(nrows):
        for icol in range(ncols):
            if (irow - cy)**2 + (icol - cx)**2 > r2:
                grid[irow][icol] = '*'
def squares_mask(grid, nrows, ncols):
    a = int(0.38 * min(ncols, nrows))
    cy = nrows // 2; cx = ncols // 2
    for irow in range(nrows):
        for icol in range(ncols):
            if a <= icol < ncols-a:
                if irow < cy-a or irow > cy+a: grid[irow][icol] = '*'
            if a <= irow < nrows-a:
                if icol < cx-a or icol > cx+a: grid[irow][icol] = '*'
def no_mask(grid, nrows, ncols): pass
apply_mask = {None: no_mask, 'circle': circle_mask, 'squares': squares_mask}

# --- Grid Creation and Filling ---
def make_initial_grid(nrows, ncols, mask_name=None):
    if mask_name not in apply_mask:
        logging.warning(f"Unknown mask name '{mask_name}'. Using no mask.")
        mask_name = None
    grid = [[' ']*ncols for _ in range(nrows)]
    apply_mask[mask_name](grid, nrows, ncols)
    return grid

def fill_grid_randomly(grid, nrows, ncols):
    for irow in range(nrows):
        for icol in range(ncols):
            if grid[irow][icol] == ' ': grid[irow][icol] = random.choice(ALPHABET)

def remove_mask_chars(grid, nrows, ncols):
    for irow in range(nrows):
        for icol in range(ncols):
            if grid[irow][icol] == '*': grid[irow][icol] = ' '

# --- Word Placement Logic ---
def _try_place_words(nrows, ncols, wordlist, allow_backwards_words=True, mask_name=None):
    grid = make_initial_grid(nrows, ncols, mask_name)

    def test_candidate(grid, irow, icol, dx, dy, word):
        word_len = len(word)
        for j in range(word_len):
            test_row, test_col = irow + j*dy, icol + j*dx
            if not (0 <= test_row < nrows and 0 <= test_col < ncols): return False
            if grid[test_row][test_col] not in (' ', word[j]): return False
        return True

    def place_word_in_grid(grid, word):
        word = ''.join(filter(str.isalnum, word)).upper()
        if not word: return None
        dxdy_choices = [(0,1), (1,0), (1,1), (1,-1)]; random.shuffle(dxdy_choices)

        for (dx, dy) in dxdy_choices:
            word_to_place = word
            if allow_backwards_words and random.choice([True, False]): word_to_place = word[::-1]

            n = len(word_to_place)
            colmin = 0; colmax = ncols - n if dx != 0 else ncols - 1
            rowmin = 0 if dy >= 0 else n - 1; rowmax = nrows - n if dy > 0 else nrows - 1
            if dy < 0: rowmax = nrows -1 # Correct range for up-diagonals

            if colmax < colmin or rowmax < rowmin: continue

            candidates = []
            for r in range(rowmin, rowmax + 1):
                 for c in range(colmin, colmax + 1):
                      end_r, end_c = r + (n-1)*dy, c + (n-1)*dx
                      if 0 <= end_r < nrows and 0 <= end_c < ncols:
                           if test_candidate(grid, r, c, dx, dy, word_to_place): candidates.append((r, c))

            if not candidates: continue
            start_row, start_col = random.choice(candidates)
            current_row, current_col = start_row, start_col
            for char in word_to_place:
                grid[current_row][current_col] = char
                current_row += dy; current_col += dx
            logging.debug(f"Placed '{word}' at ({start_row},{start_col}) orientation ({dx},{dy})")
            return True # Indicate success

        logging.warning(f"Failed to place word: {word}")
        return False

    successfully_placed_words = []
    sorted_wordlist = sorted([w for w in wordlist if w], key=len, reverse=True)
    for word in sorted_wordlist:
        if place_word_in_grid(grid, word): successfully_placed_words.append(word.upper())
        else: return None, None

    solution_grid = deepcopy(grid); fill_grid_randomly(grid, nrows, ncols)
    remove_mask_chars(grid, nrows, ncols); remove_mask_chars(solution_grid, nrows, ncols)
    return grid, sorted(successfully_placed_words)

# --- Top-Level Generation Function ---
class PuzzleGenerationError(Exception): pass

def generate_wordsearch_grid(wordlist, nrows, ncols, allow_backwards_words=True, mask_name=None, attempts=10):
    if nrows > NMAX_GRID or ncols > NMAX_GRID: raise ValueError(f'Max grid dimension is {NMAX_GRID}')
    if not wordlist: raise ValueError("Word list cannot be empty.")

    max_dimension = max(nrows, ncols); cleaned_wordlist = []
    for word in wordlist:
         cleaned_word = ''.join(filter(str.isalnum, word)).upper()
         if cleaned_word:
              if len(cleaned_word) > max_dimension: raise ValueError(f"Word '{cleaned_word}' > {max_dimension} chars (grid {nrows}x{ncols})")
              cleaned_wordlist.append(cleaned_word)
    if not cleaned_wordlist: raise ValueError("No valid words after cleaning.")

    for i in range(attempts):
        logging.info(f"Word search generation attempt {i+1}/{attempts}...")
        grid, placed_words = _try_place_words(nrows, ncols, cleaned_wordlist, allow_backwards_words, mask_name)
        if grid is not None:
            logging.info(f"Successfully generated grid in {i+1} attempt(s). Placed {len(placed_words)} words.")
            return grid, placed_words
    raise PuzzleGenerationError(f"Failed to place all words after {attempts} attempts.")
# --- End of Word Search Generation Logic ---
def create_wordsearch_image(grid_list, cell_size=30, font_size=18, font_path=None, grid_line_padding=1):
    """Creates a PIL Image object of the word search grid with complete borders."""
    if not grid_list or not grid_list[0]:
        logging.warning("create_wordsearch_image: Empty grid_list provided.")
        return None

    nrows = len(grid_list)
    ncols = len(grid_list[0])
    
    # Calculate actual grid dimensions
    grid_actual_width = ncols * cell_size
    grid_actual_height = nrows * cell_size

    # Image canvas size includes padding for borders
    img_width = grid_actual_width + (2 * grid_line_padding)
    img_height = grid_actual_height + (2 * grid_line_padding)

    image = Image.new('RGB', (img_width, img_height), 'white')
    draw = ImageDraw.Draw(image)

    try:
        font_to_use = ImageFont.truetype(font_path or "arial.ttf", font_size)
    except IOError:
        logging.warning(f"Word search font not found at '{font_path or "arial.ttf"}'. Using default.")
        font_to_use = ImageFont.load_default()

    # Draw letters and cell backgrounds/internal lines
    for r in range(nrows):
        for c in range(ncols):
            char_to_draw = grid_list[r][c]
            
            # Top-left corner of the cell on the canvas (including padding)
            cell_x0_canvas = c * cell_size + grid_line_padding
            cell_y0_canvas = r * cell_size + grid_line_padding
            
            # Bottom-right corner of the cell on the canvas
            # cell_x1_canvas = cell_x0_canvas + cell_size
            # cell_y1_canvas = cell_y0_canvas + cell_size

            # Draw letter centered in cell
            if char_to_draw and char_to_draw.strip(): # Only draw if there's a character
                try:
                    # Use textbbox for better centering if available (Pillow 9.2.0+)
                    bbox = draw.textbbox((0,0), char_to_draw, font=font_to_use, anchor="lt") # Left-Top anchor for bbox calc
                    text_width = bbox[2] - bbox[0]
                    text_height = bbox[3] - bbox[1] # This includes ascender/descender
                    # For more precise vertical centering, consider font metrics
                    ascent, descent = font_to_use.getmetrics()
                    actual_text_visual_height = ascent # Height above baseline for typical cap height

                    text_draw_x = cell_x0_canvas + (cell_size - text_width) / 2
                    text_draw_y = cell_y0_canvas + (cell_size - actual_text_visual_height) / 2 # Center based on ascent
                    
                    draw.text((text_draw_x, text_draw_y), char_to_draw, fill='black', font=font_to_use)
                except (AttributeError, TypeError): # Fallback for older Pillow or if anchor not supported well
                    text_width, text_height = draw.textsize(char_to_draw, font=font_to_use) # Deprecated
                    text_draw_x = cell_x0_canvas + (cell_size - text_width) / 2
                    text_draw_y = cell_y0_canvas + (cell_size - text_height) / 2
                    draw.text((text_draw_x, text_draw_y), char_to_draw, fill='black', font=font_to_use)

    # Draw grid lines (horizontal and vertical) AFTER letters to ensure they are on top of any cell bg
    # Horizontal lines
    for r in range(nrows + 1):
        y = r * cell_size + grid_line_padding
        draw.line([(grid_line_padding, y), (grid_actual_width + grid_line_padding, y)], fill='grey', width=1)

    # Vertical lines
    for c in range(ncols + 1):
        x = c * cell_size + grid_line_padding
        draw.line([(x, grid_line_padding), (x, grid_actual_height + grid_line_padding)], fill='grey', width=1)

    return image
# --- Standard API Routes ---
# (Generic Error Handlers - Can be refactored later)
def handle_anthropic_error(e):
    if isinstance(e, anthropic.APIConnectionError): code=503; msg=f'AI Connection Error: {e}'
    elif isinstance(e, anthropic.RateLimitError): code=429; msg='AI Rate Limit Exceeded.'
    elif isinstance(e, anthropic.AuthenticationError): code=401; msg=f'AI Authentication Error: {e}'
    elif isinstance(e, anthropic.APIStatusError):
        code = e.status_code; msg = f'AI service error (Status {code})'
        try: error_details = e.response.json(); msg += f": {error_details.get('error', {}).get('message', e.response.text)}"
        except Exception: msg += f": {e.response.text}"
    else: code=500; msg='An unexpected error occurred during AI call.'
    logging.error(f"{msg} - Exception: {e}", exc_info=(code == 500)) # Log traceback for unexpected
    return jsonify({'status': 'error', 'message': msg}), code

# --- List Saved Items Route ---
@app.route('/list_items', methods=['GET'])
def list_items_route():
    logging.info("Received request at /list_items")
    try:
        items = GeneratedItem.query.order_by(GeneratedItem.last_modified_date.desc()).limit(20).all()
        items_list = [{'id': item.id, 'item_type': item.item_type, 'source_topic': item.source_topic,
                       'source_url': item.source_url, 'grade_level': item.grade_level,
                       'last_modified': item.last_modified_date.isoformat()} for item in items]
        return jsonify({'status': 'success', 'items': items_list})
    except Exception as e:
        logging.error(f"Error retrieving items from database: {e}", exc_info=True)
        return jsonify({'status': 'error', 'message': 'Error retrieving items from library.'}), 500

@app.route('/upload_base_image', methods=['POST'])
def upload_base_image():
    logging.info("Received request at /upload_base_image")
    if 'imageFile' not in request.files:
        logging.warning("No 'imageFile' part in the request files.")
        return jsonify({'status': 'error', 'message': 'No image file part in the request'}), 400

    file = request.files['imageFile']
    if file.filename == '':
        logging.warning("'imageFile' present but no selected file.")
        return jsonify({'status': 'error', 'message': 'No selected image file'}), 400

    # Basic file type validation (check MIME type or extension)
    allowed_extensions = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
    file_ext = file.filename.rsplit('.', 1)[1].lower() if '.' in file.filename else ''
    if not file_ext or file_ext not in allowed_extensions:
        logging.warning(f"Disallowed file extension: {file_ext}")
        return jsonify({'status': 'error', 'message': f'Invalid image format. Allowed: {", ".join(allowed_extensions)}'}), 400

    try:
        # Generate a unique filename using UUID
        # Keep original extension for browser compatibility/MIME type detection
        unique_filename = str(uuid.uuid4()) + '.' + file_ext
        # Using secure_filename is still good practice to avoid path traversal issues etc.
        # but we discard its output as we use UUID for uniqueness.
        _ = secure_filename(file.filename) # Run it for validation side-effects
        save_path = os.path.join(app.config['UPLOAD_FOLDER'], unique_filename)
        logging.info(f"Attempting to save uploaded image to: {save_path}")

        file.save(save_path)
        logging.info(f"Image saved successfully as {unique_filename}")

        image_url = f"/static/uploads/{unique_filename}" # URL path for the frontend

        return jsonify({
            'status': 'success',
            'filename': unique_filename,
            'image_url': image_url
        })

    except Exception as e:
        logging.error(f"Error saving uploaded image: {e}", exc_info=True)
        return jsonify({'status': 'error', 'message': 'Server error during image upload.'}), 500

# --- Generate Routes ---
@app.route('/generate_true_false', methods=['POST'])
def generate_true_false_route():
    logging.info("Received request at /generate_true_false")
    if client is None: return jsonify({'status': 'error', 'message': 'Server error: AI client not initialized'}), 500
    if not request.is_json: return jsonify({'status': 'error', 'message': 'Request must be JSON'}), 400
    try:
        data = request.get_json(); topic = data.get('topic'); grade_level = data.get('grade_level', 'middle school'); num_statements_req = data.get('num_statements', 8)
        if not topic: return jsonify({'status': 'error', 'message': 'Missing "topic"'}), 400
        try: num_statements = int(num_statements_req); assert 3 <= num_statements <= 20
        except (ValueError, TypeError, AssertionError): return jsonify({'status': 'error', 'message': 'Invalid num_statements (must be int 3-20)'}), 400
        logging.info(f"T/F request: Topic='{topic}', Grade='{grade_level}', NumStatements={num_statements}")
        prompt_content = create_true_false_prompt(topic, grade_level, num_statements)
        message = client.messages.create(model=ANTHROPIC_MODEL_NAME, max_tokens=1000 + (num_statements * 50), temperature=0.6, messages=[{ "role": "user", "content": prompt_content }])
        if message.content and len(message.content) > 0 and hasattr(message.content[0], 'text'): generated_content = message.content[0].text
        else: raise ValueError("Failed to parse content from AI response.")
        logging.info(f"Generated T/F content length: {len(generated_content)} chars")
        return jsonify({'status': 'success', 'true_false_content': generated_content.strip()})
    except ValueError as ve: logging.warning(f"Validation Error: {ve}"); return jsonify({'status': 'error', 'message': str(ve)}), 400
    except (anthropic.APIError, httpx.RequestError) as e: return handle_anthropic_error(e)
    except Exception as e: logging.error(f"Unexpected error in /generate_true_false: {e}", exc_info=True); return jsonify({'status': 'error', 'message': 'Internal server error.'}), 500

@app.route('/generate_mcq', methods=['POST'])
def generate_mcq_route():
    logging.info("Received request at /generate_mcq")
    if client is None: return jsonify({'status': 'error', 'message': 'Server error: AI client not initialized'}), 500
    if not request.is_json: return jsonify({'status': 'error', 'message': 'Request must be JSON'}), 400
    try:
        data = request.get_json(); topic = data.get('topic'); grade_level = data.get('grade_level', 'middle school'); num_questions_req = data.get('num_questions', 5)
        if not topic: return jsonify({'status': 'error', 'message': 'Missing "topic"'}), 400
        try: num_questions = int(num_questions_req); assert 2 <= num_questions <= 15
        except (ValueError, TypeError, AssertionError): return jsonify({'status': 'error', 'message': 'Invalid num_questions (must be int 2-15)'}), 400
        logging.info(f"MCQ request: Topic='{topic}', Grade='{grade_level}', NumQuestions={num_questions}")
        prompt_content = create_mcq_prompt(topic, grade_level, num_questions)
        message = client.messages.create(model=ANTHROPIC_MODEL_NAME, max_tokens=1500 + (num_questions * 100), temperature=0.7, messages=[{ "role": "user", "content": prompt_content }])
        if message.content and len(message.content) > 0 and hasattr(message.content[0], 'text'): generated_content = message.content[0].text
        else: raise ValueError("Failed to parse content from AI response.")
        logging.info(f"Generated MCQ content length: {len(generated_content)} chars")
        return jsonify({'status': 'success', 'mcq_content': generated_content.strip()})
    except ValueError as ve: logging.warning(f"Validation Error: {ve}"); return jsonify({'status': 'error', 'message': str(ve)}), 400
    except (anthropic.APIError, httpx.RequestError) as e: return handle_anthropic_error(e)
    except Exception as e: logging.error(f"Unexpected error in /generate_mcq: {e}", exc_info=True); return jsonify({'status': 'error', 'message': 'Internal server error.'}), 500

@app.route('/generate_text_block', methods=['POST'])
def generate_text_block_route():
    logging.info("Received request at /generate_text_block")
    if client is None: return jsonify({'status': 'error', 'message': 'Server error: AI client not initialized'}), 500
    if not request.is_json: return jsonify({'status': 'error', 'message': 'Request must be JSON'}), 400
    try:
        data = request.get_json(); topic = data.get('topic'); grade_level = data.get('grade_level', 'middle school'); focus = data.get('focus')
        if not topic: return jsonify({'status': 'error', 'message': 'Missing "topic"'}), 400
        logging.info(f"Text Block request: Topic='{topic}', Grade='{grade_level}', Focus='{focus}'")
        prompt_content = create_text_block_prompt(topic, grade_level, focus)
        message = client.messages.create(model=ANTHROPIC_MODEL_NAME, max_tokens=800, temperature=0.7, messages=[{ "role": "user", "content": prompt_content }])
        if message.content and len(message.content) > 0 and hasattr(message.content[0], 'text'): generated_content = message.content[0].text
        else: raise ValueError("Failed to parse content from AI response.")
        logging.info(f"TextBlock AI: Generated content for text block: '{generated_content[:200]}...'")
        return jsonify({'status': 'success', 'text_block_content': generated_content.strip()})
    except ValueError as ve: logging.warning(f"Validation Error: {ve}"); return jsonify({'status': 'error', 'message': str(ve)}), 400
    except (anthropic.APIError, httpx.RequestError) as e: return handle_anthropic_error(e)
    except Exception as e: logging.error(f"Unexpected error in /generate_text_block: {e}", exc_info=True); return jsonify({'status': 'error', 'message': 'Internal server error.'}), 500

@app.route('/generate_short_answer', methods=['POST'])
def generate_short_answer_route():
    logging.info("Received request at /generate_short_answer")
    if client is None: return jsonify({'status': 'error', 'message': 'Server error: AI client not initialized'}), 500
    if not request.is_json: return jsonify({'status': 'error', 'message': 'Request must be JSON'}), 400
    try:
        data = request.get_json(); topic = data.get('topic'); grade_level = data.get('grade_level', 'middle school'); num_questions_req = data.get('num_questions', 5)
        if not topic: return jsonify({'status': 'error', 'message': 'Missing "topic"'}), 400
        try: num_questions = int(num_questions_req); assert 2 <= num_questions <= 10
        except (ValueError, TypeError, AssertionError): return jsonify({'status': 'error', 'message': 'Invalid num_questions (must be int 2-10)'}), 400
        logging.info(f"SA request: Topic='{topic}', Grade='{grade_level}', NumQuestions={num_questions}")
        prompt_content = create_short_answer_prompt(topic, grade_level, num_questions)
        message = client.messages.create(model=ANTHROPIC_MODEL_NAME, max_tokens=1200 + (num_questions * 100), temperature=0.7, messages=[{ "role": "user", "content": prompt_content }])
        if message.content and len(message.content) > 0 and hasattr(message.content[0], 'text'): generated_content = message.content[0].text
        else: raise ValueError("Failed to parse content from AI response.")
        logging.info(f"Generated SA content length: {len(generated_content)} chars")
        return jsonify({'status': 'success', 'short_answer_content': generated_content.strip()})
    except ValueError as ve: logging.warning(f"Validation Error: {ve}"); return jsonify({'status': 'error', 'message': str(ve)}), 400
    except (anthropic.APIError, httpx.RequestError) as e: return handle_anthropic_error(e)
    except Exception as e: logging.error(f"Unexpected error in /generate_short_answer: {e}", exc_info=True); return jsonify({'status': 'error', 'message': 'Internal server error.'}), 500

@app.route('/generate_pasted_comprehension', methods=['POST'])
def generate_pasted_comprehension_route():
    logging.info("Received request at /generate_pasted_comprehension")
    if client is None: return jsonify({'status': 'error', 'message': 'Server error: AI client not initialized'}), 500
    if not request.is_json: return jsonify({'status': 'error', 'message': 'Request must be JSON'}), 400
    try:
        data = request.get_json(); pasted_text = data.get('pasted_text'); num_questions_req = data.get('num_questions', 5)
        if not pasted_text or not pasted_text.strip(): return jsonify({'status': 'error', 'message': 'Missing "pasted_text"'}), 400
        try: num_questions = int(num_questions_req); assert 2 <= num_questions <= 15
        except (ValueError, TypeError, AssertionError): return jsonify({'status': 'error', 'message': 'Invalid num_questions (must be int 2-15)'}), 400
        logging.info(f"Pasted Text Comp request: NumQuestions={num_questions}, Text Length={len(pasted_text)}")
        prompt_content = create_pasted_comprehension_prompt(pasted_text, num_questions)
        message = client.messages.create(model=ANTHROPIC_MODEL_NAME, max_tokens=1500 + (num_questions * 100), temperature=0.7, messages=[{ "role": "user", "content": prompt_content }])
        if message.content and len(message.content) > 0 and hasattr(message.content[0], 'text'): generated_content = message.content[0].text
        else: raise ValueError("Failed to parse content from AI response.")
        logging.info(f"Generated Pasted Text Comp content length: {len(generated_content)} chars")
        return jsonify({'status': 'success', 'pasted_comprehension_content': generated_content.strip()})
    except ValueError as ve: logging.warning(f"Validation Error: {ve}"); return jsonify({'status': 'error', 'message': str(ve)}), 400
    except (anthropic.APIError, httpx.RequestError) as e: return handle_anthropic_error(e)
    except Exception as e: logging.error(f"Unexpected error in /generate_pasted_comprehension: {e}", exc_info=True); return jsonify({'status': 'error', 'message': 'Internal server error.'}), 500

@app.route('/generate_similar_questions', methods=['POST'])
def generate_similar_questions_route():
    logging.info("Received request at /generate_similar_questions")
    if client is None: return jsonify({'status': 'error', 'message': 'Server error: AI client not initialized'}), 500
    if not request.is_json: return jsonify({'status': 'error', 'message': 'Request must be JSON'}), 400
    try:
        data = request.get_json(); example_question = data.get('example_question'); num_questions_req = data.get('num_questions', 3); grade_level = data.get('grade_level', 'Not Specified')
        if not example_question or not example_question.strip(): return jsonify({'status': 'error', 'message': 'Missing "example_question"'}), 400
        try: num_questions = int(num_questions_req); assert 1 <= num_questions <= 10
        except (ValueError, TypeError, AssertionError): return jsonify({'status': 'error', 'message': 'Invalid num_questions (must be int 1-10)'}), 400
        logging.info(f"SimilarQ request: NumQuestions={num_questions}, Grade='{grade_level}', Example Length={len(example_question)}")
        prompt_content = create_similar_questions_prompt(example_question, num_questions, grade_level)
        message = client.messages.create(model=ANTHROPIC_MODEL_NAME, max_tokens=1000 + (num_questions * 200), temperature=0.75, messages=[{ "role": "user", "content": prompt_content }])
        if message.content and len(message.content) > 0 and hasattr(message.content[0], 'text'): generated_content = message.content[0].text
        else: raise ValueError("Failed to parse content from AI response.")
        logging.info(f"Generated SimilarQ content length: {len(generated_content)} chars")
        return jsonify({'status': 'success', 'similar_questions_content': generated_content.strip()})
    except ValueError as ve: logging.warning(f"Validation Error: {ve}"); return jsonify({'status': 'error', 'message': str(ve)}), 400
    except (anthropic.APIError, httpx.RequestError) as e: return handle_anthropic_error(e)
    except Exception as e: logging.error(f"Unexpected error in /generate_similar_questions: {e}", exc_info=True); return jsonify({'status': 'error', 'message': 'Internal server error.'}), 500

@app.route('/generate_worksheet', methods=['POST']) # This is the Gap Fill route
def generate_worksheet_route():
    logging.info("Received request at /generate_worksheet (Gap Fill)")
    if client is None: return jsonify({'status': 'error', 'message': 'Server error: AI client not initialized'}), 500
    if not request.is_json: return jsonify({'status': 'error', 'message': 'Request must be JSON'}), 400
    try:
        data = request.get_json(); topic = data.get('topic'); grade_level = data.get('grade_level', 'middle school'); num_sentences_req = data.get('num_sentences', 7)
        if not topic: return jsonify({'status': 'error', 'message': 'Missing "topic"'}), 400
        try: num_sentences = int(num_sentences_req); assert 3 <= num_sentences <= 15
        except (ValueError, TypeError, AssertionError): return jsonify({'status': 'error', 'message': 'Invalid num_sentences (must be int 3-15)'}), 400
        logging.info(f"Gap Fill request: Topic='{topic}', Grade='{grade_level}', NumSentences={num_sentences}")
        prompt_content = create_gap_fill_prompt(topic, grade_level, num_sentences)
        message = client.messages.create(model=ANTHROPIC_MODEL_NAME, max_tokens=500 + (num_sentences * 60), temperature=0.7, messages=[{ "role": "user", "content": prompt_content }])
        if message.content and len(message.content) > 0 and hasattr(message.content[0], 'text'): generated_content = message.content[0].text
        else: raise ValueError("Failed to parse content from AI response.")
        logging.info(f"Generated Gap Fill content length: {len(generated_content)} chars")
        return jsonify({'status': 'success', 'worksheet_content': generated_content.strip()})
    except ValueError as ve: logging.warning(f"Validation Error: {ve}"); return jsonify({'status': 'error', 'message': str(ve)}), 400
    except (anthropic.APIError, httpx.RequestError) as e: return handle_anthropic_error(e)
    except Exception as e: logging.error(f"Unexpected error in /generate_worksheet: {e}", exc_info=True); return jsonify({'status': 'error', 'message': 'Internal server error.'}), 500

# --- Word Search Routes ---
@app.route('/generate_word_list', methods=['POST'])
def generate_word_list_route():
    logging.info("Received request at /generate_word_list")
    if client is None: return jsonify({'status': 'error', 'message': 'Server error: AI client not initialized'}), 500
    if not request.is_json: return jsonify({'status': 'error', 'message': 'Request must be JSON'}), 400
    try:
        data = request.get_json(); topic = data.get('topic'); grade_level = data.get('grade_level', 'middle school'); num_words = int(data.get('num_words', 15))
        if not topic: return jsonify({'status': 'error', 'message': 'Missing "topic"'}), 400
        if not 5 <= num_words <= 30: return jsonify({'status': 'error', 'message': 'Number of words must be between 5 and 30'}), 400
        logging.info(f"Word List request: Topic='{topic}', Grade='{grade_level}', NumWords={num_words}")
        prompt_content = create_word_list_prompt(topic, grade_level, num_words)
        message = client.messages.create(model=ANTHROPIC_MODEL_NAME, max_tokens=300 + (num_words * 10), temperature=0.5, messages=[{ "role": "user", "content": prompt_content }])
        if message.content and len(message.content) > 0 and hasattr(message.content[0], 'text'): generated_content = message.content[0].text.strip()
        else: raise ValueError("Failed to parse content from AI response.")
        logging.info(f"Generated word list raw text length: {len(generated_content)} chars")
        return jsonify({'status': 'success', 'word_list_text': generated_content })
    except ValueError as ve: logging.error(f"Validation/Processing Error: {ve}", exc_info=True); return jsonify({'status': 'error', 'message': str(ve)}), 400
    except (anthropic.APIError, httpx.RequestError) as e: return handle_anthropic_error(e)
    except Exception as e: logging.error(f"Unexpected error in /generate_word_list: {e}", exc_info=True); return jsonify({'status': 'error', 'message': 'Internal server error.'}), 500

@app.route('/generate_word_search_grid', methods=['POST'])
def generate_word_search_grid_route():
    logging.info("Received request at /generate_word_search_grid")
    if not request.is_json: return jsonify({'status': 'error', 'message': 'Request must be JSON'}), 400
    try:
        data = request.get_json(); word_list_raw = data.get('word_list'); size_preference = data.get('size', 'medium'); allow_backwards = data.get('allow_backwards', False); mask = data.get('mask', None)
        if not word_list_raw or not isinstance(word_list_raw, list): return jsonify({'status': 'error', 'message': 'Missing or invalid "word_list"'}), 400
        size_map = {"small": 10, "medium": 13, "large": 15}; dimension = size_map.get(size_preference.lower(), 13)
        logging.info(f"Attempting grid generation: Size={dimension}x{dimension}, Backwards={allow_backwards}, Mask={mask}, Words={word_list_raw[:5]}...")
        grid_list, placed_words = generate_wordsearch_grid(wordlist=word_list_raw, nrows=dimension, ncols=dimension, allow_backwards_words=allow_backwards, mask_name=mask, attempts=15)
        html_output = '<div class="worksheet-section word-search-container">'; html_output += '<h3>Word Search</h3>'
        html_output += '<table class="word-search-grid" style="border-collapse: collapse; font-family: monospace; margin-bottom: 15px; border: 1px solid #ddd;">'
        for row_data in grid_list:
            html_output += '<tr>'
            for letter in row_data: display_letter = letter if letter.strip() else ''; html_output += f'<td style="border: 1px solid #eee; width: 25px; height: 25px; text-align: center; vertical-align: middle; padding: 1px;">{display_letter}</td>'
            html_output += '</tr>'
        html_output += '</table>'; html_output += '<h3>Word List</h3>'
        html_output += '<ul class="word-search-list" style="list-style: none; padding-left: 0; columns: 2; -webkit-columns: 2; -moz-columns: 2;">'
        for word in sorted(placed_words): html_output += f'<li style="margin-bottom: 5px;">{word}</li>'
        html_output += '</ul></div>'; logging.info(f"Successfully generated word search grid HTML using internal logic.")
        return jsonify({'status': 'success', 'content_html': html_output})
    except (ValueError, PuzzleGenerationError) as gen_err: logging.warning(f"Word search generation failed: {gen_err}"); return jsonify({'status': 'error', 'message': str(gen_err)}), 400
    except Exception as e: logging.error(f"Unexpected error in /generate_word_search_grid: {e}", exc_info=True); return jsonify({'status': 'error', 'message': 'An internal server error occurred creating the word search.'}), 500

@app.route('/generate_keywords_definitions', methods=['POST'])
def generate_keywords_definitions_route():
    logging.info("Request received: /generate_keywords_definitions")
    if not request.is_json:
        logging.warning("Request aborted: Content-Type is not application/json.")
        return jsonify({'status': 'error', 'message': 'Request must be JSON'}), 400

    data = request.get_json()
    if not data:
        logging.warning("Request aborted: Empty JSON payload received.")
        return jsonify({'status': 'error', 'message': 'Empty JSON payload received.'}), 400

    topic = data.get('topic')
    grade_level = data.get('grade_level')
    try:
        # Default to 10 keywords if not provided or invalid
        num_keywords = int(data.get('num_keywords', 10))
        if num_keywords <= 0:
            num_keywords = 10
            logging.warning("Invalid num_keywords <= 0 received, defaulting to 10.")
    except (ValueError, TypeError):
        num_keywords = 10
        logging.warning("Invalid or missing num_keywords received, defaulting to 10.")


    if not topic or not grade_level:
        logging.warning("Request aborted: Missing 'topic' or 'grade_level' in JSON payload.")
        return jsonify({'status': 'error', 'message': 'Missing "topic" or "grade_level".'}), 400

    logging.debug(f"Parameters received: topic='{topic}', grade_level='{grade_level}', num_keywords={num_keywords}")

    # --- Construct the AI Prompt ---
    prompt = f"""Generate {num_keywords} unique keywords related to the topic "{topic}" suitable for grade level {grade_level}.
For each keyword, provide a concise and clear definition appropriate for that grade level.
Format the output STRICTLY as a JSON list of objects, where each object has a "keyword" key and a "definition" key.
Do not include any other text, explanations, or markdown formatting before or after the JSON list. Just the raw JSON.

Example format:
[
  {{"keyword": "Example Term 1", "definition": "This is the definition for term 1."}},
  {{"keyword": "Example Term 2", "definition": "This is the definition for term 2."}}
]

Begin JSON list now:"""

    try:
        logging.info(f"Sending request to Anthropic API for keywords/definitions...")
        message = client.messages.create(
            model=ANTHROPIC_MODEL_NAME, # Use your configured model name variable
            max_tokens=1500,  # Adjust as needed, maybe calculate based on num_keywords?
            messages=[
                {
                    "role": "user",
                    "content": prompt
                }
            ]
        )

        # Extract the text content from the response
        # Assuming the response structure gives text in message.content[0].text
        if not message.content or not message.content[0].text:
             raise ValueError("Received empty content from Anthropic API.")

        ai_response_text = message.content[0].text.strip()
        logging.debug(f"Raw AI response received:\n{ai_response_text}")

        # --- Parse the JSON Response ---
        # Sometimes the AI might still wrap the JSON in markdown backticks
        if ai_response_text.startswith("```json"):
            ai_response_text = ai_response_text[7:] # Remove ```json
        if ai_response_text.endswith("```"):
            ai_response_text = ai_response_text[:-3] # Remove ```
        ai_response_text = ai_response_text.strip() # Clean whitespace again

        try:
            keyword_data = json.loads(ai_response_text)
        except json.JSONDecodeError as json_err:
            logging.error(f"Failed to parse JSON from AI response: {json_err}")
            logging.error(f"Problematic AI response text: {ai_response_text}")
            # Consider trying to extract JSON manually if needed, but often better to fail
            return jsonify({'status': 'error', 'message': f'AI response format error (not valid JSON).'}), 500

        # --- Basic Validation of Parsed Data ---
        if not isinstance(keyword_data, list):
            logging.error(f"AI response parsed, but it's not a list. Type: {type(keyword_data)}")
            return jsonify({'status': 'error', 'message': 'AI response format error (expected a list).'}), 500

        validated_data = []
        for item in keyword_data:
            if isinstance(item, dict) and 'keyword' in item and 'definition' in item:
                # Basic cleaning
                kw = str(item['keyword']).strip()
                df = str(item['definition']).strip()
                if kw and df: # Ensure they are not empty after stripping
                     validated_data.append({'keyword': kw, 'definition': df})
            else:
                logging.warning(f"Skipping invalid item in AI response list: {item}")

        if not validated_data:
             logging.error("AI response parsed as list, but no valid keyword/definition pairs found.")
             return jsonify({'status': 'error', 'message': 'AI returned no valid keyword/definition pairs.'}), 500

        logging.info(f"Successfully generated and parsed {len(validated_data)} keywords/definitions.")
        return jsonify({'status': 'success', 'keywords': validated_data})

    except Exception as e:
        # Catch errors from the API call itself or other unexpected issues
        logging.error(f"Error during keywords/definitions generation: {e}", exc_info=True)
        # Provide a generic error to the frontend
        return jsonify({'status': 'error', 'message': 'An internal error occurred while generating keywords.'}), 500

# --- Item/Worksheet Persistence Routes ---
@app.route('/save_item', methods=['POST'])
def save_item_route():
    # --- 1. Log that the function started ---
    logging.info("--- save_item route entered ---")

    # --- 2. Check if the incoming request is valid JSON ---
    if not request.is_json:
        logging.error("save_item: Request is not JSON")
        return jsonify({'status': 'error', 'message': 'Request must be JSON'}), 400

    # --- 3. Get the data sent from the frontend ---
    data = request.get_json()
    logging.debug(f"save_item: Received data keys: {list(data.keys())}")

    # --- 4. Extract all the pieces of data we expect ---
    item_type = data.get('item_type')
    source_topic = data.get('source_topic')
    source_url = data.get('source_url')
    grade_level = data.get('grade_level')
    item_data_json = data.get('item_data_json', None) # Get the extra JSON data (like image boxes), default to None if missing
    content_html = data.get('content_html')
    existing_item_id = data.get('existing_item_id') # <<<--- Check if the frontend sent an ID for an item it wants to UPDATE

    # --- 5. Make sure we have the essential pieces ---
    if not item_type or not grade_level or not content_html:
        logging.error(f"save_item: Missing required fields. Got type: {item_type}, grade: {grade_level}, content: {bool(content_html)}")
        return jsonify({'status': 'error', 'message': 'Missing required fields: item_type, grade_level, content_html'}), 400

    # --- 6. Prepare variables ---
    item_to_save = None # This will hold the database item (either found or newly created)
    is_update = False   # This flag tells us if we are updating or creating

    # --- 7. Try to handle database actions (finding, updating, creating) ---
    try:
        # --- 8. Check if an ID for updating was provided ---
        if existing_item_id:
            logging.debug(f"save_item: Received potential existing_item_id: {existing_item_id}")
            try:
                # --- 9. Try to convert the ID to a number and find the item in the database ---
                item_id_int = int(existing_item_id)
                item_to_save = db.session.get(GeneratedItem, item_id_int) # Use db.session.get to find by primary key

                # --- 10. If we found the item, set the flag to true ---
                if item_to_save:
                    is_update = True
                    logging.info(f"save_item: Found existing item ID {item_id_int} for update.")
                else:
                    # If ID was sent but not found, log a warning and proceed to create a NEW item instead.
                    logging.warning(f"save_item: Received existing_item_id {item_id_int}, but item not found in DB. Will create new.")
            except (ValueError, TypeError):
                 # If the ID sent wasn't a valid number, log a warning and proceed to create a NEW item.
                 logging.warning(f"save_item: Invalid existing_item_id format received: {existing_item_id}. Will create new.")
                 # Let the code fall through to the 'create new' section below

        # --- 11. If the 'is_update' flag is true, update the found item ---
        if is_update and item_to_save: # Double-check item_to_save exists
            logging.debug(f"save_item: Updating item ID {item_to_save.id}")
            # --- 12. Update all the fields of the found item with the new data ---
            item_to_save.item_type = item_type
            item_to_save.source_topic = source_topic
            item_to_save.source_url = source_url
            item_to_save.grade_level = grade_level
            item_to_save.item_data_json = item_data_json # Update the extra JSON data too
            item_to_save.content_html = content_html
            # The 'last_modified_date' will update automatically because of 'onupdate' in the model definition
            logging.debug(f"save_item: Item object UPDATED in memory (before commit): {item_to_save}")

        # --- 13. If the 'is_update' flag is false, it means we need to create a new item ---
        else:
            logging.debug(f"save_item: Preparing to create NEW item: type={item_type}, grade={grade_level}")
            # --- 14. Create a new GeneratedItem object with all the data ---
            item_to_save = GeneratedItem(
                item_type=item_type,
                source_topic=source_topic,
                source_url=source_url,
                grade_level=grade_level,
                item_data_json=item_data_json, # Store the extra JSON data
                content_html=content_html
                # 'creation_date' and 'last_modified_date' will get default values automatically
            )
            logging.debug(f"save_item: GeneratedItem object CREATED: {item_to_save}")
            # --- 15. Add this new item object to the database session ---
            db.session.add(item_to_save)
            logging.debug("save_item: Added NEW item to session.")

        # --- 16. Commit the changes to the database (this saves the update OR the new item) ---
        db.session.commit()
        action = "updated" if is_update else "created" # Figure out which word to use in the log message
        logging.info(f"save_item: Commit successful. Item {action}. ID assigned/confirmed: {item_to_save.id}")

        # --- 17. Send a success response back to the frontend, including the item's ID ---
        response_data = {'status': 'success', 'item_id': item_to_save.id}
        logging.debug(f"save_item: Returning success data: {response_data}")
        return jsonify(response_data)

    # --- 18. If anything went wrong in the 'try' block above... ---
    except Exception as e:
        db.session.rollback() # Undo any changes made in this session before the error
        logging.error(f"save_item: Exception during DB operation: {e}", exc_info=True) # Log the full error
        # --- 19. Send an error response back to the frontend ---
        return jsonify({'status': 'error', 'message': f'Database error: {str(e)}'}), 500
@app.route('/get_item/<int:item_id>', methods=['GET'])
def get_item_route(item_id):
    logging.info(f"Received request at /get_item/{item_id}")
    try:
        item = db.session.get(GeneratedItem, item_id)
        if item is None: logging.warning(f"Item with ID {item_id} not found."); return jsonify({'status': 'error', 'message': 'Item not found in library.'}), 404
        logging.info(f"Found item: {item.item_type}")
        item_data = {'id': item.id, 'item_type': item.item_type, 'source_topic': item.source_topic, 'source_url': item.source_url,
                       'grade_level': item.grade_level, 'item_data_json': item.item_data_json, 'content_html': item.content_html, 'creation_date': item.creation_date.isoformat(),
                       'last_modified_date': item.last_modified_date.isoformat()}
        return jsonify({'status': 'success', 'item': item_data})
    except Exception as e: logging.error(f"Error retrieving item {item_id} from database: {e}", exc_info=True); return jsonify({'status': 'error', 'message': 'Error retrieving item details.'}), 500

@app.route('/save_worksheet', methods=['POST'])
def save_worksheet_route():
    logging.info("Received request at /save_worksheet")
    if not request.is_json: return jsonify({'status': 'error', 'message': 'Request must be JSON'}), 400
    data = request.get_json(); worksheet_title = data.get('title', 'Untitled Worksheet'); item_ids_ordered = data.get('item_ids')
    if not item_ids_ordered or not isinstance(item_ids_ordered, list): return jsonify({'status': 'error', 'message': 'Missing or invalid "item_ids" list'}), 400
    logging.info(f"Attempting to save worksheet: Title='{worksheet_title}', Item IDs={item_ids_ordered}")
    try:
        new_worksheet = Worksheet(title=worksheet_title); db.session.add(new_worksheet); db.session.flush(); worksheet_id = new_worksheet.id
        items_to_add = []; order_index = 0
        for item_id in item_ids_ordered:
            generated_item = db.session.get(GeneratedItem, int(item_id))
            if generated_item:
                assoc_insert = worksheet_items_association.insert().values(worksheet_id=worksheet_id, generated_item_id=generated_item.id, item_order=order_index)
                db.session.execute(assoc_insert); items_to_add.append(generated_item.id); order_index += 1
            else: logging.warning(f"GeneratedItem ID {item_id} not found while saving worksheet {worksheet_id}. Skipping.")
        db.session.commit(); logging.info(f"Successfully saved Worksheet ID: {worksheet_id} with item IDs: {items_to_add} in order.")
        return jsonify({'status': 'success', 'message': 'Worksheet saved successfully!', 'worksheet_id': worksheet_id})
    except Exception as e: db.session.rollback(); logging.error(f"Error saving worksheet to database: {e}", exc_info=True); return jsonify({'status': 'error', 'message': f'Database error while saving worksheet: {e}'}), 500

@app.route('/list_worksheets', methods=['GET'])
def list_worksheets_route():
    logging.info("Received request at /list_worksheets")
    try:
        worksheets = Worksheet.query.order_by(Worksheet.last_modified_date.desc()).limit(50).all()
        worksheets_list = [{'id': ws.id, 'title': ws.title, 'creation_date': ws.creation_date.isoformat(),
                            'last_modified_date': ws.last_modified_date.isoformat()} for ws in worksheets]
        return jsonify({'status': 'success', 'worksheets': worksheets_list})
    except Exception as e: logging.error(f"Error retrieving worksheets from database: {e}", exc_info=True); return jsonify({'status': 'error', 'message': 'Error retrieving worksheet list.'}), 500

@app.route('/load_worksheet/<int:worksheet_id>', methods=['GET'])
def load_worksheet_route(worksheet_id):
    logging.info(f"Received request at /load_worksheet/{worksheet_id}")
    try:
        worksheet = db.session.get(Worksheet, worksheet_id)
        if worksheet is None: return jsonify({'status': 'error', 'message': 'Worksheet not found.'}), 404
        ordered_items = worksheet.items # Relationship handles ordering
        items_data = []
        for item in ordered_items:
            items_data.append({
                'id': item.id,
                'item_type': item.item_type,
                'source_topic': item.source_topic,
                'source_url': item.source_url,
                'grade_level': item.grade_level,
                'content_html': item.content_html,
                'item_data_json': item.item_data_json # <<< ADD THIS LINE
            })
        logging.info(f"Returning {len(items_data)} items for Worksheet ID: {worksheet_id}")
        return jsonify({'status': 'success', 'worksheet_title': worksheet.title, 'items': items_data})
    except Exception as e: logging.error(f"Error retrieving worksheet {worksheet_id} from database: {e}", exc_info=True); return jsonify({'status': 'error', 'message': 'Error retrieving worksheet details.'}), 500
@app.route('/generate_similar_written_questions', methods=['POST'])
def generate_similar_written_questions_route():
    logging.info("Request received: /generate_similar_written_questions")
    if not request.is_json:
        logging.warning("Request aborted: Content-Type is not application/json.")
        return jsonify({'status': 'error', 'message': 'Request must be JSON'}), 400

    data = request.get_json()
    if not data:
        logging.warning("Request aborted: Empty JSON payload received.")
        return jsonify({'status': 'error', 'message': 'Empty JSON payload received.'}), 400

    example_question = data.get('example_question')
    grade_level = data.get('grade_level') # Might be "Not Specified"
    try:
        num_questions = int(data.get('num_questions', 3))
        if num_questions <= 0:
            num_questions = 3
            logging.warning("Invalid num_questions <= 0 received, defaulting to 3.")
    except (ValueError, TypeError):
        num_questions = 3
        logging.warning("Invalid or missing num_questions received, defaulting to 3.")

    if not example_question:
        logging.warning("Request aborted: Missing 'example_question' in JSON payload.")
        return jsonify({'status': 'error', 'message': 'Missing "example_question".'}), 400

    # Use grade level if provided, otherwise let AI infer
    grade_level_text = f"potentially intended for grade level '{grade_level}'" if grade_level and grade_level != "Not Specified" else "with an unspecified grade level"

    logging.debug(f"Parameters: num_questions={num_questions}, grade_level='{grade_level}', example='{example_question[:100]}...'")

    # --- Construct the AI Prompt ---
    prompt = f"""You are an expert assessment designer tasked with creating question variations.
Analyze the following example question, {grade_level_text}:

--- Example Question ---
{example_question}
--- End Example Question ---

First, identify and concisely describe the primary skill(s) being assessed by this question.
Second, generate {num_questions} new, distinct questions that assess the *exact same skill(s)* you identified. Ensure these new questions are appropriate for the specified grade level (or maintain the implied level of the example), keep a similar difficulty, but use different scenarios, contexts, or specific details. Avoid simple rephrasing of the example.

Format your response strictly as a JSON object containing two keys:
1. "skills_identified": A string describing the core skill(s) tested (keep this brief, maybe 1-2 sentences).
2. "similar_questions": A JSON list containing exactly {num_questions} strings, where each string is one of the new questions.

Do not include any explanations or text outside the JSON object.

Example JSON Output Format:
{{
  "skills_identified": "Applying the definition of photosynthesis to identify necessary components.",
  "similar_questions": [
    "Besides sunlight, what is one essential reactant that plants need for photosynthesis?",
    "Which part of a plant cell is primarily responsible for carrying out photosynthesis?",
    "If a plant is kept in complete darkness but given water and carbon dioxide, can it perform photosynthesis? Explain why or why not."
  ]
}}

Begin JSON object now:"""

    try:
        logging.info(f"Sending request to Anthropic API for similar written questions...")
        message = client.messages.create(
            model=ANTHROPIC_MODEL_NAME,
            max_tokens=1500, # Adjust as needed
            messages=[{"role": "user", "content": prompt}]
        )

        if not message.content or not message.content[0].text:
             raise ValueError("Received empty content from Anthropic API.")

        ai_response_text = message.content[0].text.strip()
        logging.debug(f"Raw AI response received:\n{ai_response_text}")

        # Clean potential markdown backticks
        if ai_response_text.startswith("```json"):
            ai_response_text = ai_response_text[7:]
        if ai_response_text.endswith("```"):
            ai_response_text = ai_response_text[:-3]
        ai_response_text = ai_response_text.strip()

        try:
            parsed_data = json.loads(ai_response_text)
        except json.JSONDecodeError as json_err:
            logging.error(f"Failed to parse JSON from AI response: {json_err}")
            logging.error(f"Problematic AI response text for similar written q: {ai_response_text}")
            return jsonify({'status': 'error', 'message': 'AI response format error (not valid JSON).'}), 500

        # Validate structure
        if not isinstance(parsed_data, dict):
             logging.error(f"Parsed data is not a dict: {type(parsed_data)}")
             return jsonify({'status': 'error', 'message': 'AI response format error (expected JSON object).'}), 500

        skills = parsed_data.get("skills_identified")
        questions = parsed_data.get("similar_questions")

        if not isinstance(skills, str) or not isinstance(questions, list):
             logging.error(f"Missing/invalid keys in parsed JSON. Skills type: {type(skills)}, Questions type: {type(questions)}")
             return jsonify({'status': 'error', 'message': 'AI response format error (missing/invalid keys).'}), 500

        # Optional: Validate number of questions returned matches request?
        # if len(questions) != num_questions:
        #    logging.warning(f"AI returned {len(questions)} questions, expected {num_questions}")

        validated_questions = [str(q).strip() for q in questions if isinstance(q, str) and str(q).strip()]

        logging.info(f"Successfully generated {len(validated_questions)} similar written questions.")
        # Return the whole parsed object nested under 'data'
        return jsonify({
            'status': 'success',
            'data': {
                 'skills_identified': skills.strip(),
                 'similar_questions': validated_questions
                 }
            })

    except Exception as e:
        logging.error(f"Error during similar written questions generation: {e}", exc_info=True)
        return jsonify({'status': 'error', 'message': 'An internal error occurred while generating questions.'}), 500
# --- Export and Frontend Routes ---
@app.route('/export/docx/<int:worksheet_id>')
def export_worksheet_docx(worksheet_id):
    """Exports a specific worksheet as a DOCX file."""
    logging.info(f"Request: /export/docx/{worksheet_id}")
    try:
        worksheet = Worksheet.query.get_or_404(worksheet_id)
        items = worksheet.items # Assumes items are correctly ordered by the relationship
        logging.info(f"Found worksheet '{worksheet.title}' with {len(items)} items.")

        document = docx.Document()
        logging.debug("Initialized docx Document.")

        # --- Apply Document Formatting ---
        target_font='Century Gothic' # Or 'Arial', 'Calibri' etc.
        try:
            normal_style = document.styles['Normal']
            normal_style.font.name = target_font
            normal_style.paragraph_format.space_after = Pt(6)
            logging.info(f"Set Normal font to {target_font} and paragraph spacing.")
        except Exception as font_e:
            logging.warning(f"Could not set default font/style: {font_e}")

        try:
            h3_style = document.styles['Heading 3']
            h3_style.font.name = target_font
            h3_style.paragraph_format.space_before = Pt(12)
            h3_style.paragraph_format.space_after = Pt(6)
            logging.info(f"Set H3 font to {target_font} and spacing.")
        except Exception as style_e:
            logging.warning(f"Could not modify Heading 3 style: {style_e}")

        try: # Set Margins
            section = document.sections[0]
            section.left_margin=Inches(0.75); section.right_margin=Inches(0.75) # Slightly wider than 0.5
            section.top_margin=Inches(0.75); section.bottom_margin=Inches(0.75)
            logging.info("Set document margins to 0.75 inches.")
        except Exception as margin_e:
            logging.warning(f"Could not set margins: {margin_e}")

        document.add_heading(worksheet.title, level=1)
        document.add_paragraph()
        logging.debug(f"Added worksheet title: {worksheet.title}")

        logging.info("Starting item processing loop...")
        for item_index, item in enumerate(items):
            logging.debug(f"--- Processing item index: {item_index}, ID: {item.id}, Type: {item.item_type} ---")
            soup = BeautifulSoup(item.content_html, 'lxml')
            processed_as_type = "Unknown"

            word_search_container = soup.find('div', class_='word-search-container')

            if word_search_container:
                processed_as_type = "WordSearch"
                logging.debug("Item identified as Word Search.")
                try:
                    heading_ws_el = word_search_container.find('h3')
                    document.add_heading(heading_ws_el.get_text(strip=True) if heading_ws_el else "Word Search", level=3)

                    grid_table = word_search_container.find('table', class_='word-search-grid')
                    grid_list = []
                    if grid_table:
                        for row in grid_table.find_all('tr'):
                            grid_list.append([cell.get_text(strip=True) for cell in row.find_all('td')])
                    
                    if grid_list:
                        grid_image = create_wordsearch_image(grid_list)
                        if grid_image:
                            img_buffer = io.BytesIO(); grid_image.save(img_buffer, format='PNG'); img_buffer.seek(0)
                            try: document.add_picture(img_buffer, width=Inches(6.0)) # Adjust width as needed
                            except Exception as pic_e: logging.error(f"Failed to add picture: {pic_e}"); document.add_paragraph("[Error adding grid image]", style='Comment')
                        else: logging.warning("create_wordsearch_image returned None."); document.add_paragraph("[Error generating grid image]", style='Comment')
                    else: logging.warning("Word search grid table not found in HTML."); document.add_paragraph("[Word search grid table not found in HTML]", style='Comment')

                    word_list_headings = word_search_container.find_all('h3')
                    word_list_heading_text = "Word List"
                    if len(word_list_headings) > 1: # Assumes second H3 is for word list
                        word_list_heading_text = word_list_headings[1].get_text(strip=True)
                    document.add_heading(word_list_heading_text, level=3)
                    
                    word_list_ul = word_search_container.find('ul', class_='word-search-list')
                    words_to_find = [li.get_text(strip=True) for li in word_list_ul.find_all('li')] if word_list_ul else []
                    words_to_find = [word for word in words_to_find if word]

                    if words_to_find:
                        # Simple paragraph for words, consider columns/table for better formatting later
                        p_words = document.add_paragraph()
                        for i, word in enumerate(words_to_find):
                            p_words.add_run(word)
                            if i < len(words_to_find) - 1:
                                p_words.add_run("     ") # Add spacing between words
                    else: document.add_paragraph("[Word list empty or not found in HTML]", style='Comment')
                    document.add_paragraph()
                except Exception as ws_err:
                    logging.error(f"Error processing WordSearch item {item.id}: {ws_err}", exc_info=True)
                    document.add_paragraph(f"[Error processing Word Search item {item.id}]", style='Comment')

            elif item.item_type.startswith('keywords-'):
                processed_as_type = "KeywordsTable"
                logging.debug(f"Processing keywords item {item.id} (Type: {item.item_type}) for DOCX.")
                try:
                    html_table = soup.find('table', class_='keywords-table') # soup is already defined
                    if not html_table: raise ValueError("Could not find 'table.keywords-table' in HTML")
                    rows = html_table.find_all('tr')
                    if not rows: raise ValueError("Keywords table found but contained no rows.")
                    header_cells = rows[0].find_all(['th', 'td'])
                    num_cols = len(header_cells)
                    if num_cols <= 0: raise ValueError("Keywords table found, but header row had no columns.")
                    data_rows = rows[1:]
                    num_data_rows = len(data_rows)

                    docx_table = document.add_table(rows=num_data_rows + 1, cols=num_cols)
                    docx_table.style = 'Table Grid'

                    for j, cell in enumerate(header_cells):
                        if j < num_cols:
                            header_text = ' '.join(cell.get_text(strip=True).split())
                            hdr_cell = docx_table.cell(0, j)
                            hdr_cell.text = header_text
                            if hdr_cell.paragraphs and hdr_cell.paragraphs[0].runs: hdr_cell.paragraphs[0].runs[0].font.bold = True
                            elif hdr_cell.paragraphs: hdr_cell.paragraphs[0].add_run().font.bold = True
                    
                    for i, html_row in enumerate(data_rows):
                        cells = html_row.find_all('td')
                        for j, cell in enumerate(cells):
                            if j < num_cols:
                                cell_text = ' '.join(cell.get_text(strip=True).split())
                                docx_table.cell(i + 1, j).text = cell_text if cell_text else ""
                    
                    if item.item_type == 'keywords-matching' and num_cols == 3:
                        middle_col_index = 1
                        total_rows_in_table = num_data_rows + 1
                        for i_row in range(total_rows_in_table):
                            try:
                                cell_to_modify = docx_table.cell(i_row, middle_col_index)
                                tcPr = cell_to_modify._tc.get_or_add_tcPr()
                                tcBorders = tcPr.first_child_found_in("w:tcBorders")
                                if tcBorders is None: tcBorders = OxmlElement("w:tcBorders"); tcPr.append(tcBorders)
                                for border_name in ['top', 'bottom']: # Only remove top and bottom
                                    border_el = OxmlElement(f'w:{border_name}'); border_el.set(qn('w:val'), 'nil'); tcBorders.append(border_el)
                            except Exception as border_err: logging.error(f"Error modifying borders cell({i_row},{middle_col_index}): {border_err}")
                    document.add_paragraph()
                except Exception as parse_err:
                    logging.error(f"Error processing keywords table item {item.id}: {parse_err}", exc_info=True)
                    document.add_paragraph(f"[Error processing keyword table for item {item.id}]", style='Comment')

            elif item.item_type == 'similarWrittenQ':
                processed_as_type = "SimilarWrittenQ"
                logging.debug(f"Processing similarWrittenQ item {item.id} for DOCX.")
                skills = "Skills not specified."
                questions = []
                try:
                    if item.item_data_json:
                        parsed_data = json.loads(item.item_data_json)
                        if isinstance(parsed_data, dict):
                            skills = parsed_data.get('skills_identified', skills).strip()
                            questions_raw = parsed_data.get('similar_questions', [])
                            if isinstance(questions_raw, list):
                                questions = [str(q).strip() for q in questions_raw if str(q).strip()]
                    else: logging.warning(f"item_data_json not found for similarWrittenQ item {item.id}.")

                    document.add_heading("Skills Tested", level=3)
                    document.add_paragraph(skills)
                    document.add_paragraph()
                    document.add_heading("Generated Questions", level=3)
                    if questions:
                        for q_text in questions: document.add_paragraph(q_text, style='List Number')
                        p_reset = document.add_paragraph(); p_reset.add_run().font.size = Pt(1)
                    else: document.add_paragraph("[No similar questions found in saved data]", style='Comment')
                    document.add_paragraph()
                except Exception as export_err:
                    logging.error(f"Error adding similarWrittenQ item {item.id} to DOCX: {export_err}", exc_info=True)
                    document.add_paragraph(f"[Error processing Similar Written Questions item {item.id}]", style='Comment')
            
            elif item.item_type == 'imageLabel':
                processed_as_type = "ImageLabel"
                logging.debug(f"DOCX Export: Processing imageLabel item ID: {item.id}")
                try:
                    if not item.item_data_json: raise ValueError(f"Missing item_data_json for imageLabel item {item.id}")
                    data = json.loads(item.item_data_json)
                    if not isinstance(data, dict) or 'baseImage' not in data: raise ValueError(f"Invalid structure in item_data_json for item {item.id}")
                    base_image_filename = data['baseImage']
                    boxes_to_process = data.get('boxes_pct', data.get('boxes')) # Prefer _pct
                    is_percent_data = 'boxes_pct' in data
                    
                    image_path = os.path.join(app.config['UPLOAD_FOLDER'], base_image_filename)
                    if not os.path.exists(image_path): raise FileNotFoundError(f"Base image file not found: {image_path}")

                    img = Image.open(image_path).convert("RGB")
                    draw = ImageDraw.Draw(img)
                    
                    calc_ref_width_for_pct = None
                    calc_ref_height_for_pct = None

                    if is_percent_data: # This 'is_percent_data' was defined earlier based on 'boxes_pct' key presence
                        calc_ref_width_for_pct = data.get('refEditorWidth')
                        calc_ref_height_for_pct = data.get('refEditorHeight')
                        if not calc_ref_width_for_pct or not calc_ref_height_for_pct:
                            logging.warning(f"DOCX Export: Item {item.id} uses percentages (boxes_pct) but refEditorWidth/Height missing from JSON. "
                                            f"Falling back to naturalWidth/Height if available, then actual image dimensions. "
                                            f"This might lead to scaling issues if the original editor view was different from natural size.")
                            calc_ref_width_for_pct = data.get('naturalWidth', img.width)
                            calc_ref_height_for_pct = data.get('naturalHeight', img.height)
                        logging.debug(f"DOCX Export: For item {item.id} (percent data), using reference for % calc: {calc_ref_width_for_pct}x{calc_ref_height_for_pct}. Drawing on image of size: {img.width}x{img.height}")
                    else: # Old pixel data
                        # For old pixel data, we assume these pixels were meant for the natural image size,
                        # or if refEditorWidth was stored, maybe that. This path is less certain for old data.
                        # This will be the reference against which the old pixel data is scaled to the current image.
                        calc_ref_width_for_pixels = data.get('refEditorWidth', data.get('naturalWidth', img.width))
                        calc_ref_height_for_pixels = data.get('refEditorHeight', data.get('naturalHeight', img.height))
                        logging.debug(f"DOCX Export: For item {item.id} (pixel data), reference dimensions for old pixels: {calc_ref_width_for_pixels}x{calc_ref_height_for_pixels}. Drawing on image of size: {img.width}x{img.height}")

                    font_main, font_small = None, None
                    try:
                        font_main = ImageFont.truetype("arial.ttf", 14) # Adjust font size as needed
                        font_small = ImageFont.truetype("arial.ttf", 10)
                    except IOError: 
                        logging.warning("Arial font not found, using default for image labels in DOCX.")
                        try:
                            font_main = ImageFont.load_default()
                            font_small = ImageFont.load_default() # Use same default if specific size fails
                        except Exception as font_load_err:
                            logging.error(f"Could not load default PIL font: {font_load_err}")
                            # font_main and font_small will remain None
                    
                    if boxes_to_process and isinstance(boxes_to_process, list):
                        for box_data in boxes_to_process:
                            try:
                                px_x, px_y, px_w, px_h = 0.0, 0.0, 0.0, 0.0 # Pixels to draw on the final 'img'

                                if is_percent_data:
                                    # Convert percentages to absolute pixel values relative to calc_ref_width_for_pct
                                    x_abs_on_ref = (float(box_data.get('x_pct', 0)) / 100.0) * calc_ref_width_for_pct
                                    y_abs_on_ref = (float(box_data.get('y_pct', 0)) / 100.0) * calc_ref_height_for_pct
                                    w_abs_on_ref = (float(box_data.get('width_pct', 10)) / 100.0) * calc_ref_width_for_pct # Default 10%
                                    h_abs_on_ref = (float(box_data.get('height_pct', 5)) / 100.0) * calc_ref_height_for_pct  # Default 5%
                                    
                                    # Now, these absolute pixel values (calculated on the reference dimensions)
                                    # need to be scaled if calc_ref_width_for_pct is different from the actual img.width
                                    # (i.e., if the editor view was scaled relative to the natural image when percentages were saved).
                                    # We are drawing onto 'img' (the natural-sized image).
                                    if calc_ref_width_for_pct == 0 or calc_ref_height_for_pct == 0: # Avoid division by zero
                                        logging.error(f"DOCX Export: calc_ref_width_for_pct or calc_ref_height_for_pct is zero for item {item.id}. Skipping box scaling.")
                                        px_x, px_y, px_w, px_h = x_abs_on_ref, y_abs_on_ref, w_abs_on_ref, h_abs_on_ref # Use unscaled, might be wrong
                                    else:
                                        scale_factor_to_natural_w = img.width / calc_ref_width_for_pct
                                        scale_factor_to_natural_h = img.height / calc_ref_height_for_pct

                                        px_x = x_abs_on_ref * scale_factor_to_natural_w
                                        px_y = y_abs_on_ref * scale_factor_to_natural_h
                                        px_w = w_abs_on_ref * scale_factor_to_natural_w
                                        px_h = h_abs_on_ref * scale_factor_to_natural_h
                                else: # Old pixel data (is_percent_data is False)
                                    # Assume old pixel data was meant to be drawn directly onto an image of 'calc_ref_width_for_pixels'
                                    # And then scale it to the current natural image size ('img.width', 'img.height').
                                    x_old_px = float(box_data.get('x', 0))
                                    y_old_px = float(box_data.get('y', 0))
                                    w_old_px = float(box_data.get('width', 50))  # Default 50px
                                    h_old_px = float(box_data.get('height', 30)) # Default 30px

                                    if calc_ref_width_for_pixels == 0 or calc_ref_height_for_pixels == 0:
                                        logging.error(f"DOCX Export: calc_ref_width_for_pixels or calc_ref_height_for_pixels is zero for item {item.id}. Skipping box scaling for old pixel data.")
                                        px_x, px_y, px_w, px_h = x_old_px, y_old_px, w_old_px, h_old_px
                                    else:
                                        scale_factor_to_natural_w = img.width / calc_ref_width_for_pixels
                                        scale_factor_to_natural_h = img.height / calc_ref_height_for_pixels

                                        px_x = x_old_px * scale_factor_to_natural_w
                                        px_y = y_old_px * scale_factor_to_natural_h
                                        px_w = w_old_px * scale_factor_to_natural_w
                                        px_h = h_old_px * scale_factor_to_natural_h
                                
                                # Draw semi-transparent box
                                # Ensure width and height are at least 1 pixel for drawing
                                draw_w = max(1, int(math.ceil(px_w)))
                                draw_h = max(1, int(math.ceil(px_h)))
                                rect_img_surface = Image.new('RGBA', (draw_w, draw_h), (255, 255, 255, 0)) # Transparent base
                                rect_draw_on_surface = ImageDraw.Draw(rect_img_surface)
                                rect_draw_on_surface.rectangle([(0,0), (draw_w-1, draw_h-1)], outline="black", width=1, fill=(255,255,255,255)) # Semi-transparent white
                                img.paste(rect_img_surface, (int(px_x), int(px_y)), rect_img_surface) # Paste with alpha blending

                                text_content = str(box_data.get('text', ''))
                                if box_data.get('type') != 'blank' and text_content:
                                    font_to_use = font_small if px_h < 25 and font_small else font_main 
                                    if font_to_use:
                                        try: 
                                            center_x = px_x + px_w / 2
                                            center_y = px_y + px_h / 2
                                            draw.text((center_x, center_y), text_content, fill="black", font=font_to_use, anchor="mm")
                                        except (AttributeError, TypeError): 
                                            text_bbox_fallback = draw.textbbox((0,0), text_content, font=font_to_use)
                                            text_w_fallback = text_bbox_fallback[2] - text_bbox_fallback[0]
                                            text_h_fallback = text_bbox_fallback[3] - text_bbox_fallback[1]
                                            ascent_fb, descent_fb = font_to_use.getmetrics()
                                            actual_text_visual_height_fb = ascent_fb 
                                            
                                            draw_text_x_fallback = px_x + (px_w - text_w_fallback) / 2
                                            draw_text_y_fallback = px_y + (px_h - actual_text_visual_height_fb) / 2 
                                            if descent_fb > 0 : # Basic adjustment for descenders if present
                                                draw_text_y_fallback -= descent_fb / 2 
                                            draw.text((draw_text_x_fallback, draw_text_y_fallback), text_content, fill="black", font=font_to_use)
                            except Exception as box_draw_err: 
                                logging.error(f"Error drawing a specific box/text for imageLabel in DOCX: {box_draw_err}", exc_info=True)
                    
                    img_buffer = io.BytesIO(); img.save(img_buffer, format='PNG'); img_buffer.seek(0)
                    page_width_inches = document.sections[0].page_width.inches - document.sections[0].left_margin.inches - document.sections[0].right_margin.inches
                    document.add_picture(img_buffer, width=Inches(min(6.5, page_width_inches)))
                    document.add_paragraph()
                except Exception as img_label_err:
                    logging.error(f"DOCX Export: Unexpected error processing imageLabel item {item.id}: {img_label_err}", exc_info=True)
                    document.add_paragraph(f"[Unexpected Server Error processing Image Labelling item {item.id}. Check server logs.]", style='Comment')
            
            else: # Generic handler for other text-based items
                processed_as_type = "GenericText"
                logging.debug(f"Processing generic text-based item {item.id} (Type: {item.item_type}) for DOCX.")
                try:
                    content_container = soup.find('body') # Or a more specific container if universally present
                    if content_container:
                        for element in content_container.children:
                            if not hasattr(element, 'name') or element.name is None:
                                if isinstance(element, str) and element.strip():
                                    document.add_paragraph(element.strip())
                                continue

                            if element.name == 'h3':
                                document.add_heading(element.get_text(strip=True), level=3)
                            elif element.name == 'p':
                                para = document.add_paragraph()
                                add_runs_from_html_element(para, element)
                            elif element.name in ['ol', 'ul']:
                                list_style = 'ListNumber' if element.name == 'ol' else 'ListBullet'
                                for li in element.find_all('li', recursive=False):
                                    para = document.add_paragraph(style=list_style)
                                    add_runs_from_html_element(para, li)
                                p_reset = document.add_paragraph(); p_reset.add_run().font.size = Pt(1) # Reset list numbering
                            elif element.name == 'div' and 'worksheet-section' in element.get('class', []):
                                section_title_el = element.find('h3', recursive=False)
                                if section_title_el:
                                    document.add_heading(section_title_el.get_text(strip=True), level=3)
                                    section_title_el.decompose() # Avoid re-processing

                                for child_el in element.children: # Process children of worksheet-section
                                    if not hasattr(child_el, 'name') or child_el.name is None:
                                        if isinstance(child_el, str) and child_el.strip(): document.add_paragraph(child_el.strip())
                                        continue
                                    if child_el.name == 'p':
                                        para = document.add_paragraph(); add_runs_from_html_element(para, child_el)
                                    elif child_el.name in ['ol', 'ul']:
                                        child_list_style = 'ListNumber' if child_el.name == 'ol' else 'ListBullet'
                                        for li_child in child_el.find_all('li', recursive=False):
                                            para = document.add_paragraph(style=child_list_style); add_runs_from_html_element(para, li_child)
                                        p_reset_child = document.add_paragraph(); p_reset_child.add_run().font.size = Pt(1)
                                    elif child_el.name == 'div': # E.g., answer key divs
                                        # Check for specific IDs for more targeted formatting if needed
                                        # Example: if child_el.get('id') == 'gap-fill-answers': ...
                                        div_text_content = child_el.get_text(separator='\n', strip=True)
                                        if div_text_content: document.add_paragraph(div_text_content)
                            # Add more specific handlers for other common HTML structures here
                        document.add_paragraph() # Space after generic item
                    else:
                        logging.warning(f"Could not find content container for generic item {item.id}")
                        document.add_paragraph(f"[Content for item {item.id} (type: {item.item_type}) could not be extracted.]", style='Comment')
                except Exception as generic_err:
                    logging.error(f"Error processing generic text-based item {item.id}: {generic_err}", exc_info=True)
                    document.add_paragraph(f"[Error processing item {item.id} (type: {item.item_type})]", style='Comment')

            logging.debug(f"End processing item index {item_index}. Identified as: {processed_as_type}")
            if item_index < len(items) - 1: # If it's not the last item
                # Add a page break only before large visual items if the current item wasn't also one
                # or if the next item is a major section.
                # For now, simpler: page break before WordSearch or ImageLabel if they aren't first.
                next_item_is_visual = items[item_index + 1].item_type in ['wordSearch', 'imageLabel']
                current_item_is_visual = item.item_type in ['wordSearch', 'imageLabel']

                if next_item_is_visual and item_index > -1 : # Always page break before a visual item unless it's the very first
                    logging.debug(f"Adding PAGE BREAK before next visual item: {items[item_index + 1].item_type}")
                    document.add_page_break()
                elif not current_item_is_visual and not next_item_is_visual: 
                    # If both current and next are text-based, add a smaller separator
                    logging.debug(f"Adding paragraph separator after text item: {item.item_type}")
                    sep_para = document.add_paragraph()
                    # You can add a run with '***' or a few empty runs, or just rely on paragraph spacing.
                    # sep_para.add_run("-----").font.size = Pt(8) 
                    # sep_para.alignment = docx.enum.text.WD_ALIGN_PARAGRAPH.CENTER
                    document.add_paragraph() # Just an empty paragraph for spacing
                else:
                    # If current is visual and next is text, or vice-versa and not covered above,
                    # default to a paragraph break.
                    logging.debug(f"Adding default paragraph separator between {item.item_type} and {items[item_index + 1].item_type}")
                    document.add_paragraph()

        logging.info("Finished item processing loop.")
        file_stream = io.BytesIO()
        document.save(file_stream)
        file_stream.seek(0)
        safe_title = re.sub(r'[\\/*?:"<>|]', "", worksheet.title)
        safe_title = re.sub(r'\s+', '_', safe_title).strip('_')
        filename = f"{safe_title.lower() or 'worksheet'}.docx"
        logging.info(f"Sending DOCX file: {filename}")
        return send_file(
            file_stream,
            as_attachment=True,
            download_name=filename,
            mimetype='application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        )
    except Exception as e:
        logging.error(f"CRITICAL Error exporting DOCX for worksheet {worksheet_id}", exc_info=True)
        return f"Error exporting worksheet: {str(e)}<br><pre>{traceback.format_exc()}</pre>", 500

# --- Helper function add_runs_from_html_element ---
def add_runs_from_html_element(paragraph, element):
    """Adds formatted runs to a python-docx paragraph based on basic HTML tags."""
    for content in element.contents:
        if isinstance(content, str):
            text_content_original = content 
            text_content_for_display = content.replace('\xa0', ' ') 

            stripped_text = text_content_original.strip()
            is_just_underscores = False
            if len(stripped_text) > 1 and all(char == '_' for char in stripped_text): 
                is_just_underscores = True
            
            if is_just_underscores:
                paragraph.add_run(" " + "_" * 30 + " ") # Make the gap 30 underscores long
            else:
                text_to_add_final = text_content_for_display.strip()
                if text_to_add_final:
                    paragraph.add_run(text_to_add_final)
        elif content.name in ['strong', 'b']:
            run = paragraph.add_run(content.get_text(strip=True).replace('\xa0', ' '))
            run.bold = True
        elif content.name in ['em', 'i']:
            run = paragraph.add_run(content.get_text(strip=True).replace('\xa0', ' '))
            run.italic = True
        elif content.name == 'span' and 'gap-placeholder' in content.get('class', []): 
            # This will now only be hit if you explicitly use <span class="gap-placeholder"> for some gaps
            paragraph.add_run(" [____________________] ") # Keep it long here too
        elif content.name == 'br':
            paragraph.add_run().add_break() 
        elif hasattr(content, 'name') and content.name: 
            nested_text = content.get_text(strip=True).replace('\xa0', ' ')
            if nested_text:
                paragraph.add_run(nested_text)

@app.route('/')
def serve_index():
    """Serves the index.html file."""
    logging.info("Serving index.html")
    return send_from_directory('.', 'index.html')

# --- Run the App ---
if __name__ == '__main__':
    # Note: debug=True is useful locally but should be False in production
    app.run(host='127.0.0.1', port=5001, debug=True)





<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Worksheet Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <style>
        /* Styles for structured output */
        .worksheet-section { border: 1px solid #e0e0e0; padding: 10px 15px; margin-bottom: 15px; background-color: #fff; border-radius: 4px; }
        .worksheet-section h3 { margin-top: 0; margin-bottom: 10px; border-bottom: 1px solid #ccc; padding-bottom: 5px; }
        .editable-content { outline: 1px dashed blue; background-color: #f0f8ff; cursor: text; padding: 2px 4px; min-height: 1em; border-radius: 2px;}
        #itemPreviewArea p, #itemPreviewArea li { margin-bottom: 0.5em; }
        #libraryOutput li { border-bottom: 1px dashed #eee; margin-bottom: 10px; padding-bottom: 10px; } /* Style library list */
        /* Basic styling */
        body { font-family: sans-serif; padding: 20px; background-color: #f0f0f0; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="text"], input[type="url"], input[type="number"], select, textarea { width: 100%; max-width: 450px; padding: 8px; margin-bottom: 15px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px;} /* Added textarea */
        button { padding: 10px 15px; cursor: pointer; margin-bottom: 15px; margin-left: 5px; border: none; border-radius: 4px; background-color: #007bff; color: white; font-size: 1em;}
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        button#toggleEditButton { background-color: #ffc107; color: black; }
        button#saveButton { background-color: #28a745; }
        button#loadLibraryButton { background-color: #6c757d; }
        #itemPreviewArea { margin-top: 10px; border: 1px solid #ccc; padding: 15px; white-space: pre-wrap; background-color: #fdfdfd; min-height: 150px; border-radius: 4px;}
        #libraryOutput { border: 1px solid #ccc; padding: 15px; background-color: #fff; min-height: 100px; border-radius: 4px; margin-top: 10px; }
        .loading { font-style: italic; color: grey; }
        .hidden { display: none; }
        fieldset { border: 1px solid #ccc; padding: 15px; margin-bottom: 15px; border-radius: 4px; background-color: #fff;}
        legend { font-weight: bold; padding: 0 5px; }
        h1, h2 { color: #333; margin-top: 25px; margin-bottom: 10px;}
        h1:first-of-type { margin-top: 0; }
        hr { margin: 30px 0; border: 0; border-top: 1px solid #ccc; }
        /* Style radio labels */
        fieldset div label { display: inline; font-weight: normal; margin-left: 5px; }
        fieldset div input[type="checkbox"] + label { display: inline; font-weight: normal;} /* Style checkbox label */
        .label-box {
            position: absolute;
            border: 2px solid black;
            background-color: rgba(255, 255, 255, 0.8); /* Semi-transparent white */
            padding: 2px 4px;
            font-size: 14px; /* Adjust as needed */
            font-family: sans-serif;
            cursor: grab; /* Indicate draggable */
            box-sizing: border-box; /* Include border in width/height */
            touch-action: none; /* Required by Interact.js */
            user-select: none; /* Prevent text selection during drag */
            overflow: hidden; /* Prevent content spillover */
            min-width: 20px; /* Prevent boxes becoming too small */
            min-height: 20px;
            display: flex; /* For centering content */
            flex-direction: column;
            /* align-items: center; */
            /* justify-content: center; */
            /* text-align: center; */
        }
                    /* **** ADD New Style for Drag Handle **** */
        .label-box-handle {
            width: 100%;
            height: 12px; /* Small height for the handle bar */
            background-color: rgba(0, 0, 0, 0.1); /* Light grey, slightly transparent */
            cursor: grab; /* Draggable cursor ONLY on the handle */
            text-align: center; /* For a potential drag icon/dots later */
            line-height: 12px; /* Vertically center any text/icon in handle */
            font-size: 10px; /* For any icon/text */
            color: #333;
            border-bottom: 1px solid rgba(0,0,0,0.2); /* Separator */
            box-sizing: border-box;
        }
        /* Style for the content area below the handle */
        .label-box-content {
            padding: 2px 4px;
            flex-grow: 1; /* Takes remaining space */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            width: 100%; /* Ensure span takes full width for centering */
        }
        /* **** END Drag Handle Styles **** */
        .label-box.selected {
            border: 2px solid blue;
            box-shadow: 0 0 5px blue;
            z-index: 10; /* Bring selected box to front */
        }
        .label-box span {
            pointer-events: none; /* Prevent span interfering with drag */
            display: inline-block; /* Needed for sizing? */
            white-space: nowrap; /* Keep custom text on one line? Adjust as needed */
        }
        /* Container for image + static boxes in worksheet item */
.worksheet-image-label-container {
    position: relative; /* Essential for absolute children */
    display: inline-block; /* Shrink-wrap width to image */
    max-width: 100%; /* Responsive width */
    line-height: 0; /* Prevent extra space below image */
    /* border: 1px solid #ccc; /* Optional border for debugging */
}

/* Image within the worksheet item */
.worksheet-image-label-container img {
    display: block; /* Removes bottom space */
    max-width: 100%; /* Scales down */
    height: auto; /* Maintains aspect ratio */
    /* border: 1px dashed blue; /* Optional border */
}

/* Static boxes within the worksheet item */
.static-label-box {
    position: absolute; /* Position relative to container */
    border: 1px solid black;
    background-color: rgba(255, 255, 255, 0.85); /* Slightly less transparent */
    font-size: 8px; /* May need to be small */
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    overflow: hidden;
    box-sizing: border-box; /* Include border in % size */
    /* Prevent text selection */
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    pointer-events: none; /* Prevent interaction with static boxes */
}

.static-label-box span {
     /* Styles for text inside static box if needed */
     display: inline-block;
     max-width: 100%; /* Prevent text overflow */
     white-space: nowrap;
     overflow: hidden;
     text-overflow: ellipsis;
}
    </style>
</head>
<body>
    <h1>AI Worksheet Generator</h1>

    <!-- ======================= -->
    <!-- Section 1: LOAD LIBRARY -->
    <!-- ======================= -->
    <h2>Saved Item Library</h2>
    <button id="loadLibraryButton">Load Saved Items</button>
    <div id="libraryOutput">
        Click "Load Saved Items" to view your library.
    </div>
    <!-- ** ADDED SAVED WORKSHEETS SECTION ** -->
    <h2 style="margin-top: 30px;">Saved Worksheets</h2>
    <button id="loadWorksheetsButton" style="background-color: #6c757d;">Load Worksheet List</button>
    <div id="savedWorksheetsList" style="border: 1px solid #ccc; padding: 15px; background-color: #fff; min-height: 80px; border-radius: 4px; margin-top: 10px;">
        Click "Load Worksheet List" to view saved worksheets.
    </div>

    <hr>

    <!-- ========================== -->
    <!-- Section 2: GENERATE NEW    -->
    <!-- ========================== -->
    <h2>Generate New Item</h2>
    <!-- Mode Selection -->
    <fieldset>
        <legend>Select Generator Type</legend>
        <div><input type="radio" id="modeGapFill" name="generatorMode" value="gapFill" checked><label for="modeGapFill">Gap-Fill</label></div>
        <div><input type="radio" id="modeTextBlock" name="generatorMode" value="textBlock"><label for="modeTextBlock">Text Block</label></div>
        <div><input type="radio" id="modePastedText" name="generatorMode" value="pastedText"><label for="modePastedText">Pasted Text Comp</label></div>
        <div><input type="radio" id="modeMcq" name="generatorMode" value="mcq"><label for="modeMcq">Multiple Choice</label></div>
        <div><input type="radio" id="modeTrueFalse" name="generatorMode" value="trueFalse"><label for="modeTrueFalse">True/False</label></div>
        <div><input type="radio" id="modeShortAnswer" name="generatorMode" value="shortAnswer"><label for="modeShortAnswer">Short Answer</label></div>
        <!-- ** ADD THIS DIV ** -->
        <div>
            <input type="radio" id="modeSimilarQ" name="generatorMode" value="similarQ">
            <label for="modeSimilarQ">Similar Calculation Problems</label>
        </div>
        <div><input type="radio" id="modeWordSearch" name="generatorMode" value="wordSearch"><label for="modeWordSearch">Word Search (from Topic)</label></div>
        <div><input type="radio" id="modeKeywordsDefinitionsRadio" name="generatorMode" value="keywordsDefinitions"><label for="modeKeywordsDefinitionsRadio">Keywords & Definitions</label></div>
        <div><input type="radio" id="modeSimilarWrittenQ" name="generatorMode" value="similarWrittenQ"><label for="modeSimilarWrittenQ">Similar Written Questions</label></div>
       
        <!-- **** ADD THIS DIV for Image Labelling Mode **** -->
        <div>
            <input type="radio" id="modeImageLabel" name="generatorMode" value="imageLabel">
            <label for="modeImageLabel">Image Labelling</label>
        </div>
    </fieldset>

    <!-- Inputs for Gap Fill (Should be visible by default) -->
    <div id="gapFillInputs">
        <fieldset>
            <legend>Gap-Fill Options</legend>
            <div> <label for="topicInput">Enter Topic:</label> <input type="text" id="topicInput" placeholder="e.g., Photosynthesis"> </div>
            <div> <label for="gradeLevelSelect">Grade Level:</label> <select id="gradeLevelSelect" name="grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div><div>
                <label for="gfNumSentencesInput">Number of Sentences (Gaps):</label>
                <input type="number" id="gfNumSentencesInput" value="7" min="3" max="15"> <!-- Default 7, min 3, max 15 -->
            </div>
        </fieldset>
    </div>

    <!-- ** MODIFIED SECTION for Pasted Text ** -->
    <div id="pastedTextInputs" class="hidden"> <!-- Renamed ID -->
        <fieldset>
            <legend>Pasted Text Comprehension Options</legend> <!-- Changed Legend -->
            <!-- YouTube URL Input REMOVED -->
            <div> <!-- Added Textarea -->
                <label for="pastedTextInputArea">Paste Text Here:</label>
                <textarea id="pastedTextInputArea" rows="10" style="width: 100%; max-width: 450px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; padding: 8px;" placeholder="Paste the text you want questions generated for...eg youtube transcript"></textarea>
            </div>
            <div>
                <label for="ptNumQuestionsInput">Number of Questions:</label> <!-- Renamed for attribute -->
                <input type="number" id="ptNumQuestionsInput" value="5" min="2" max="15"> <!-- Renamed ID -->
            </div>
        </fieldset>
    </div>

    <!-- Inputs for Multiple Choice -->
    <div id="mcqInputs" class="hidden">
        <fieldset>
            <legend>Multiple Choice Options</legend>
            <div> <label for="mcqTopicInput">Enter Topic:</label> <input type="text" id="mcqTopicInput" placeholder="e.g., Mitochondria"> </div>
            <div> <label for="mcqGradeLevelSelect">Grade Level:</label> <select id="mcqGradeLevelSelect" name="mcq_grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div>
            <div> <label for="mcqNumQuestionsInput">Number of Questions:</label> <input type="number" id="mcqNumQuestionsInput" value="5" min="2" max="15"> </div>
        </fieldset>
    </div>

    <!-- Inputs for True/False -->
    <div id="trueFalseInputs" class="hidden">
        <fieldset>
            <legend>True/False Options</legend>
            <div> <label for="tfTopicInput">Enter Topic:</label> <input type="text" id="tfTopicInput" placeholder="e.g., The Roman Empire"> </div>
            <div> <label for="tfGradeLevelSelect">Grade Level:</label> <select id="tfGradeLevelSelect" name="tf_grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div>
            <div> <label for="tfNumStatementsInput">Number of Statements:</label> <input type="number" id="tfNumStatementsInput" value="8" min="3" max="20"> </div>
        </fieldset>
    </div>

    <!-- Inputs for Short Answer -->
    <div id="shortAnswerInputs" class="hidden">
        <fieldset>
            <legend>Short Answer Options</legend>
            <div> <label for="saTopicInput">Enter Topic:</label> <input type="text" id="saTopicInput" placeholder="e.g., Climate Change"> </div>
            <div> <label for="saGradeLevelSelect">Grade Level:</label> <select id="saGradeLevelSelect" name="sa_grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div>
            <div> <label for="saNumQuestionsInput">Number of Questions:</label> <input type="number" id="saNumQuestionsInput" value="5" min="2" max="10"> </div>
        </fieldset>
    </div>

    <!-- Inputs for Text Block -->
    <div id="textBlockInputs" class="hidden">
        <fieldset>
            <legend>Text Block Options</legend>
             <div> <input type="checkbox" id="tbGenerateTextCheckbox" name="tb_generate_text" checked style="display: inline; width: auto; margin-bottom: 10px;"> <label for="tbGenerateTextCheckbox">Generate text using AI?</label> </div>
             <div id="tbTopicInputDiv"> <label for="tbTopicInput">Topic (for AI generation):</label> <input type="text" id="tbTopicInput" placeholder="e.g., The Importance of Bees"> </div>
             <div> <label for="tbGradeLevelSelect">Grade Level (for AI generation):</label> <select id="tbGradeLevelSelect" name="tb_grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div>
             <div> <label for="tbDirectInput">Or Enter/Edit Your Text Directly:</label> <textarea id="tbDirectInput" rows="8" placeholder="Type your instructions or text here..."></textarea> </div>
        </fieldset>
    </div>
 
 <!-- ** ADD THIS NEW INPUT SECTION ** -->
 <div id="similarQInputs" class="hidden">
     <fieldset>
         <legend>Similar Questions Options</legend>
         <div>
             <label for="sqExampleInput">Paste Example Question Here:</label>
             <textarea id="sqExampleInput" rows="6" style="width: 100%; max-width: 450px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; padding: 8px;" placeholder="Paste the question you want similar versions of..."></textarea>
         </div>
         <div>
             <label for="sqNumQuestionsInput">Number of Similar Questions:</label>
             <input type="number" id="sqNumQuestionsInput" value="3" min="1" max="10"> <!-- Default 3 -->
         </div>
         <div>
             <label for="sqGradeLevelSelect">Target Grade Level (Optional):</label>
             <select id="sqGradeLevelSelect" name="sq_grade_level">
                 <option value="Not Specified" selected>Not Specified</option> <!-- Add default option -->
                 <option value="elementary school">Elementary</option>
                 <option value="middle school">Middle</option>
                 <option value="high school">High</option>
                 <option value="university">University</option>
                 <option value="general adult">Adult</option>
             </select>
         </div>
         <!-- Add checkboxes for variations here later if desired -->
         <!-- Example:
         <div>
             <input type="checkbox" id="sqAllowUnits" name="sq_allow_units" style="display: inline; width: auto;">
             <label for="sqAllowUnits">Allow Unit Conversions?</label>
         </div>
          -->
     </fieldset>
 </div>
 <!-- ** END OF NEW INPUT SECTION ** -->
  <!-- Inputs for Word Search (Initially Hidden) -->
  <div id="wordSearchInputs" class="hidden">
    <fieldset>
        <legend>Word Search Options</legend>
        <!-- Start with Topic/Grade to generate word list -->
        <div> <label for="wsTopicInput">Enter Topic:</label> <input type="text" id="wsTopicInput" placeholder="e.g., Ancient Egypt"> </div>
        <div> <label for="wsGradeLevelSelect">Grade Level:</label>
            <select id="wsGradeLevelSelect" name="ws_grade_level">
                <option value="elementary school">Elementary</option>
                <option value="middle school" selected>Middle</option>
                <option value="high school">High</option>
                <option value="university">University</option>
                <option value="general adult">Adult</option>
            </select>
         </div>
         <!-- Word list editor and size select will be added here dynamically by JS -->
         <div id="wordSearchDynamicControls"></div>
    </fieldset>
</div>
<div class="generator-mode hidden" id="keywordsDefinitionsInputs">
    <h2>Keywords & Definitions</h2>
    <div class="input-group">
        <label for="keywordsTopic">Topic:</label>
        <input type="text" id="keywordsTopic" placeholder="e.g., Photosynthesis, Solar System">
    </div>
    <div class="input-group">
        <div class="input-group">
            <label for="keywordsGradeLevelSelect">Grade Level:</label> <!-- Changed ID -->
            <select id="keywordsGradeLevelSelect" name="keywords_grade_level"> <!-- Changed ID and added name -->
                <option value="elementary school">Elementary</option>
                <option value="middle school" selected>Middle</option> <!-- Default selected -->
                <option value="high school">High</option>
                <option value="university">University</option>
                <option value="general adult">Adult</option>
            </select>
        </div>
    </div>
    <div class="input-group">
        <label for="keywordsNum">Number of Keywords (Optional):</label>
        <input type="number" id="keywordsNum" placeholder="Default: 10" min="1" max="25"> <!-- Added min/max -->
    </div>
    <button id="generateKeywordsBtn">Generate Keywords</button>
    <hr>

    <!-- Area to display results and controls -->
    <div id="keywordsPreviewArea" style="display: none;"> <!-- Initially hidden -->
        <h3>Generated Keywords/Definitions</h3>

        <!-- Activity Selection Controls -->
        <div id="keywordsActivitySelector" style="margin-bottom: 15px;">
            <label>Select Activity Type:</label><br>
            <input type="radio" id="activityRefTable" name="keywordActivity" value="reference" checked>
            <label for="activityRefTable">Reference Table</label><br>
            <input type="radio" id="activityMatch" name="keywordActivity" value="matching">
            <label for="activityMatch">Matching Activity</label><br>
            <input type="radio" id="activityDefsOnly" name="keywordActivity" value="definitions">
            <label for="activityDefsOnly">Definitions Only</label><br>
            <input type="radio" id="activityKeywordsOnly" name="keywordActivity" value="keywords">
            <label for="activityKeywordsOnly">Keywords Only</label><br>
        </div>

        <!-- The actual generated activity output will go here -->
        <div id="activityOutput" class="worksheet-preview-content" style="border: 1px dashed #ccc; padding: 10px; margin-bottom:10px;">
            <!-- Content generated by JS -->
        </div>

        <!-- Add controls similar to other generators -->
        <button id="addKeywordsToWorksheetBtn">Add to Worksheet</button>
        <button id="saveKeywordsItemBtn">Save Item to Library</button>
        <span id="keywordsItemIdDisplay" class="item-id-display"></span> <!-- To show saved item ID -->
        <p id="keywordsStatus" class="status-message"></p> <!-- For loading/error messages -->

    </div> <!-- End keywordsPreviewArea -->

</div>
<div id="similarWrittenQInputs" class="generator-mode hidden"> <!-- Added generator-mode class too -->
    <fieldset>
        <legend>Similar Written Questions Options</legend>
        <div>
            <label for="swqExampleInput">Paste Example Written Question:</label>
            <textarea id="swqExampleInput" rows="6" placeholder="Paste the question you want variations of..."></textarea> <!-- Inherit styling -->
        </div>
        <div>
            <label for="swqNumQuestionsInput">Number of Similar Questions:</label>
            <input type="number" id="swqNumQuestionsInput" value="3" min="1" max="10">
        </div>
        <div>
            <label for="swqGradeLevelSelect">Target Grade Level:</label>
            <select id="swqGradeLevelSelect" name="swq_grade_level">
                <option value="elementary school">Elementary</option>
                <option value="middle school" selected>Middle</option>
                <option value="high school">High</option>
                <option value="university">University</option>
                <option value="general adult">Adult</option>
                <option value="Not Specified">Not Specified</option> <!-- Optional -->
            </select>
        </div>
    </fieldset>
</div>
<div id="imageLabelInputs" class="generator-mode hidden">
    <fieldset>
        <legend>Image Labelling Options</legend>
        <div>
            <label for="ilBaseImageUpload">1. Upload Base Image:</label>
            <input type="file" id="ilBaseImageUpload" accept="image/*">
            <p id="ilUploadStatus" style="font-style: italic; color: grey; margin-top: 5px;"></p>
        </div>

        <!-- Preview Area for Image Labelling -->
        <div id="ilPreviewContainer" style="position: relative; display: none; border: 1px dashed grey; margin-top: 15px; min-height: 100px; max-width: 600px; /* Adjust as needed */">
            <img id="ilPreviewImage" src="#" alt="Image preview" style="display: block; max-width: 100%; height: auto;">
            <!-- Label boxes will be added here by JS -->
        </div>

        <!-- Controls for adding/editing boxes (shown when image is loaded) -->
        <div id="ilInteractionControls" style="display: none; margin-top: 15px;">
             <div>
                <input type="checkbox" id="ilAddBoxModeToggle" style="display: inline; width: auto;">
                <label for="ilAddBoxModeToggle" style="display: inline; font-weight: bold; color: #007bff;">Enable Add Box Mode (Click on Image to Add)</label>
            </div>

            <!-- Box Property Controls (shown when a box is selected) -->
            <div id="ilBoxControls" style="display: none; margin-top: 10px; padding: 10px; border: 1px solid #ccc; background-color: #f8f9fa; border-radius: 4px;">
                <label style="font-weight: bold;">Selected Box Content:</label><br>
                <input type="radio" id="boxContentTypeNumber" name="boxContentType" value="number" checked> <label for="boxContentTypeNumber">Auto-Number</label><br>
                <input type="radio" id="boxContentTypeBlank" name="boxContentType" value="blank"> <label for="boxContentTypeBlank">Blank Box</label><br>
                <input type="radio" id="boxContentTypeCustom" name="boxContentType" value="custom"> <label for="boxContentTypeCustom">Custom Text:</label>
                <input type="text" id="boxCustomTextInput" placeholder="Enter text" style="width: 150px; display: inline-block; margin-left: 5px; margin-bottom: 0; padding: 4px;">
                <button id="ilDeleteSelectedBoxBtn" style="background-color: #dc3545; color: white; padding: 4px 8px; font-size: 0.9em; margin-left: 15px; float: right;">Delete Selected Box</button>
                <div style="clear: both;"></div>
             </div>
        </div>
    </fieldset>
    <!-- We will need dedicated Save/Add buttons for this mode -->
     <button id="saveImageLabelItemBtn" style="background-color: #28a745;">Save Image Item</button>
     <button id="addImageLabelToWorksheetBtn" style="background-color: #17a2b8;">Add Image Item to Worksheet</button>
     <span id="imageLabelItemIdDisplay" class="item-id-display"></span>
     <p id="imageLabelStatus" class="status-message"></p>
    </div>
    <!-- Generate Button -->
    <button id="generateButton">Generate New</button>

    <hr>

    <!-- ================================== -->
    <!-- Section 3: GENERATED OUTPUT/EDITOR -->
    <!-- ================================== -->
    <button id="saveButton" style="float: right;" disabled>Save to Library</button>
    <button id="toggleEditButton" style="float: right;" disabled>Enable Editing</button>
    <button id="addToSheetButton" style="float: right; background-color: #17a2b8;" disabled>Add Item to Worksheet</button>
    <h2 style="clear: both;">Item preview / Editor</h2>
    <div id="itemPreviewArea"> Generated/loaded item will appear here for preview/editing. </div>
    <hr>
    <h2>Worksheet Assembly Area</h2>
    <div style="margin-bottom: 15px; background-color: #fff; padding: 10px; border-radius: 4px; border: 1px solid #ccc;">
        <label for="worksheetTitleInput" style="display: inline-block; margin-right: 10px;">Worksheet Title:</label>
        <input type="text" id="worksheetTitleInput" placeholder="Enter a title for this worksheet" style="display: inline-block; width: auto; max-width: 300px; margin-bottom: 0;">
        <button id="saveWorksheetButton" style="background-color: #28a745; margin-left: 15px; float: right;">Save This Worksheet</button>
        <div style="clear: both;"></div> <!-- Clear float -->
    </div>
<button id="clearSheetButton" style="background-color: #dc3545;">Clear Worksheet</button> <!-- Added Clear Button -->
<div id="worksheetAssemblyArea" style="border: 2px dashed #6c757d; padding: 20px; background-color: #e9ecef; min-height: 300px; margin-top: 15px;">
    <!-- Items added to the worksheet will appear here -->
    <p style="color: grey; font-style: italic;">Items added to the worksheet will appear here.</p>
</div>

    <script>
        // --- Get Element References (Consolidated) ---
        const modeGapFillRadio = document.getElementById('modeGapFill');
        const modePastedTextRadio = document.getElementById('modePastedText');
        const modeMcqRadio = document.getElementById('modeMcq');
        const modeTrueFalseRadio = document.getElementById('modeTrueFalse');
        const modeShortAnswerRadio = document.getElementById('modeShortAnswer');
        const modeTextBlockRadio = document.getElementById('modeTextBlock');
        const modeSimilarQRadio = document.getElementById('modeSimilarQ');
        const gapFillInputsDiv = document.getElementById('gapFillInputs');
        const pastedTextInputsDiv = document.getElementById('pastedTextInputs');
        const mcqInputsDiv = document.getElementById('mcqInputs');
        const trueFalseInputsDiv = document.getElementById('trueFalseInputs');
        const shortAnswerInputsDiv = document.getElementById('shortAnswerInputs');
        const textBlockInputsDiv = document.getElementById('textBlockInputs');
        const similarQInputsDiv = document.getElementById('similarQInputs');
        const modeWordSearchRadio = document.getElementById('modeWordSearch');
        const wordSearchInputsDiv = document.getElementById('wordSearchInputs');
        const wordSearchDynamicControls = document.getElementById('wordSearchDynamicControls');
        const keywordsDefinitionsInputsDiv = document.getElementById('keywordsDefinitionsInputs');
        const topicInput = document.getElementById('topicInput');
        const gradeLevelSelect = document.getElementById('gradeLevelSelect');
        const gfNumSentencesInput = document.getElementById('gfNumSentencesInput');
        const ptNumQuestionsInput = document.getElementById('ptNumQuestionsInput');
        const pastedTextInputArea = document.getElementById('pastedTextInputArea');
        const mcqTopicInput = document.getElementById('mcqTopicInput');
        const mcqGradeLevelSelect = document.getElementById('mcqGradeLevelSelect');
        const mcqNumQuestionsInput = document.getElementById('mcqNumQuestionsInput');

        const tfTopicInput = document.getElementById('tfTopicInput');
        const tfGradeLevelSelect = document.getElementById('tfGradeLevelSelect');
        const tfNumStatementsInput = document.getElementById('tfNumStatementsInput');

        const saTopicInput = document.getElementById('saTopicInput');
        const saGradeLevelSelect = document.getElementById('saGradeLevelSelect');
        const saNumQuestionsInput = document.getElementById('saNumQuestionsInput');

        const tbGenerateTextCheckbox = document.getElementById('tbGenerateTextCheckbox');
        const tbTopicInputDiv = document.getElementById('tbTopicInputDiv');
        const tbTopicInput = document.getElementById('tbTopicInput');
        const tbGradeLevelSelect = document.getElementById('tbGradeLevelSelect');
        const tbDirectInput = document.getElementById('tbDirectInput');
        const sqExampleInput = document.getElementById('sqExampleInput');
        const sqNumQuestionsInput = document.getElementById('sqNumQuestionsInput');
        const sqGradeLevelSelect = document.getElementById('sqGradeLevelSelect');
        const generateButton = document.getElementById('generateButton');
        const loadLibraryButton = document.getElementById('loadLibraryButton');
        const itemPreviewArea = document.getElementById('itemPreviewArea');
        const addToSheetButton = document.getElementById('addToSheetButton');
        const worksheetAssemblyArea = document.getElementById('worksheetAssemblyArea');
        const clearSheetButton = document.getElementById('clearSheetButton');
        const worksheetTitleInput = document.getElementById('worksheetTitleInput');
        const libraryOutput = document.getElementById('libraryOutput');
        const toggleEditButton = document.getElementById('toggleEditButton');
        const saveButton = document.getElementById('saveButton');
        const modeImageLabelRadio = document.getElementById('modeImageLabel');
        const imageLabelInputsDiv = document.getElementById('imageLabelInputs');
        const ilBaseImageUpload = document.getElementById('ilBaseImageUpload');
        const ilUploadStatus = document.getElementById('ilUploadStatus');
        const ilPreviewContainer = document.getElementById('ilPreviewContainer');
        const ilPreviewImage = document.getElementById('ilPreviewImage');
        const ilInteractionControls = document.getElementById('ilInteractionControls'); // Wrapper div
        const ilAddBoxModeToggle = document.getElementById('ilAddBoxModeToggle');
        const ilBoxControls = document.getElementById('ilBoxControls'); // Box property controls div
        const boxContentTypeNumberRadio = document.getElementById('boxContentTypeNumber');
        const boxContentTypeBlankRadio = document.getElementById('boxContentTypeBlank');
        const boxContentTypeCustomRadio = document.getElementById('boxContentTypeCustom');
        const boxCustomTextInput = document.getElementById('boxCustomTextInput');
        const ilDeleteSelectedBoxBtn = document.getElementById('ilDeleteSelectedBoxBtn');
        const saveImageLabelItemBtn = document.getElementById('saveImageLabelItemBtn');
        const addImageLabelToWorksheetBtn = document.getElementById('addImageLabelToWorksheetBtn');
        const imageLabelItemIdDisplay = document.getElementById('imageLabelItemIdDisplay');
        const imageLabelStatus = document.getElementById('imageLabelStatus');
        
        // --- State Variables ---
        
        
        
        // --- BEGIN Setter Test for currentItemIdInPreview ---
        let isEditingEnabled = false;
        let currentItemIdInPreview = null; // <<<< USE THIS CONSISTENT NAME
        let baseImageFilename = null; 
        currentItemIdInPreview = null; // INITIAL SET on page load
        // --- END Setter Test ---

      // Stores the UUID filename of the uploaded image
        let labelBoxes = []; // Array to hold data objects for each box { id, x, y, w, h, type, text, element }
        let isAddBoxMode = false; // Flag: True when user clicks checkbox to add next box
        let selectedBoxId = null; // ID of the currently selected label box
        let nextBoxNumber = 1; // Counter for auto-numbering boxes
        let isDrawingNewBox = false; // <<< ADD: Flag for drag-to-draw state
        let startDrawX = 0;        // <<< ADD: Starting X for drag-to-draw
        let startDrawY = 0;        // <<< ADD: Starting Y for drag-to-draw
        let tempDrawBox = null;  
let currentKeywordData = [];
let currentKeywordsItemId = null; // To track if the previewed item came from the library

// Get refs for elements INSIDE the keywordsDefinitionsInputs div
const generateKeywordsBtn = document.getElementById('generateKeywordsBtn');
const keywordsPreviewArea = document.getElementById('keywordsPreviewArea');
const keywordsTopicInput = document.getElementById('keywordsTopic');
const keywordsGradeLevelSelect = document.getElementById('keywordsGradeLevelSelect');
const keywordsNumInput = document.getElementById('keywordsNum');
const keywordsStatus = document.getElementById('keywordsStatus');
const activityOutput = document.getElementById('activityOutput');
const activitySelector = document.getElementById('keywordsActivitySelector'); // Container for radio buttons
const addKeywordsToWorksheetBtn = document.getElementById('addKeywordsToWorksheetBtn');
const saveKeywordsItemBtn = document.getElementById('saveKeywordsItemBtn');
const keywordsItemIdDisplay = document.getElementById('keywordsItemIdDisplay');
const modeKeywordsDefinitionsRadio = document.getElementById('modeKeywordsDefinitionsRadio'); // Ref for the radio button
const modeSimilarWrittenQRadio = document.getElementById('modeSimilarWrittenQ');
const similarWrittenQInputsDiv = document.getElementById('similarWrittenQInputs');
const swqExampleInput = document.getElementById('swqExampleInput');
const swqNumQuestionsInput = document.getElementById('swqNumQuestionsInput');
const swqGradeLevelSelect = document.getElementById('swqGradeLevelSelect');
console.log("Value of modeSimilarWrittenQRadio on script load:", modeSimilarWrittenQRadio);
console.log("Value of modeSimilarWrittenQRadio on script load:", modeSimilarWrittenQRadio);
// --- END: Keywords & Definitions Globals/Constants ---
        // --- Helper Functions ---
        
        // Handles showing/hiding topic input for Text Block mode
        function handleTbCheckboxChange() {
            if (tbGenerateTextCheckbox.checked) {
                tbTopicInputDiv.classList.remove('hidden');
            } else {
                tbTopicInputDiv.classList.add('hidden');
            }
        }

        // ** FIXED handleModeChange Function **
        function handleModeChange(isLoadingItem = false, itemIdToPreserve = null) { // Added itemIdToPreserve
            const callSource = new Error().stack.split('\n')[2]?.trim().split(' ')[1] || 'unknown'; 
             console.log(`--- handleModeChange ENTRY --- isLoadingItem: ${isLoadingItem}, itemIdToPreserve: ${itemIdToPreserve}`);
            
            if (isLoadingItem && itemIdToPreserve !== null) {
                console.log(`handleModeChange: LOADING ITEM. Preserving/setting currentItemIdInPreview to: ${itemIdToPreserve} (was ${currentItemIdInPreview})`);
                currentItemIdInPreview = itemIdToPreserve;
            } else if (!isLoadingItem) {
                console.log(`handleModeChange: NOT loading item. currentItemIdInPreview was: ${currentItemIdInPreview}`);
                currentItemIdInPreview = null; 
                console.log(`handleModeChange: currentItemIdInPreview NOW RESET TO NULL.`);
            } else { // isLoadingItem is true, but itemIdToPreserve is null (should not happen if called correctly)
                console.log(`handleModeChange: LOADING ITEM, but no itemIdToPreserve given. currentItemIdInPreview is: ${currentItemIdInPreview}. Not changing it here.`);
            }
            

            // --- Hide all input sections first ---
            gapFillInputsDiv.classList.add('hidden');
            pastedTextInputsDiv.classList.add('hidden');
            mcqInputsDiv.classList.add('hidden');
            trueFalseInputsDiv.classList.add('hidden');
            shortAnswerInputsDiv.classList.add('hidden');
            textBlockInputsDiv.classList.add('hidden');
            similarQInputsDiv.classList.add('hidden');
            wordSearchInputsDiv.classList.add('hidden');
            keywordsDefinitionsInputsDiv.classList.add('hidden');
            similarWrittenQInputsDiv.classList.add('hidden');
            imageLabelInputsDiv.classList.add('hidden');
            // Clear dynamic area if it exists from previous mode
            if (wordSearchDynamicControls) {
                 wordSearchDynamicControls.innerHTML = '';
            }

            // --- Reset main generate button state ---
            generateButton.textContent = 'Generate New';
            generateButton.disabled = false; // Re-enable if it was disabled

            // --- Show the selected input section ---
            if (modeTextBlockRadio.checked) {
                console.log("Mode detected: Text Block");
                textBlockInputsDiv.classList.remove('hidden');
                handleTbCheckboxChange(); // Call helper for checkbox state
            } else if (modePastedTextRadio.checked) {
                 console.log("Mode detected: Pasted Text");
                 pastedTextInputsDiv.classList.remove('hidden');
            } else if (modeMcqRadio.checked) {
                console.log("Mode detected: MCQ");
                mcqInputsDiv.classList.remove('hidden');
            } else if (modeTrueFalseRadio.checked) {
                console.log("Mode detected: True/False");
                trueFalseInputsDiv.classList.remove('hidden');
            } else if (modeShortAnswerRadio.checked) {
                console.log("Mode detected: Short Answer");
                shortAnswerInputsDiv.classList.remove('hidden');
            } else if (modeSimilarQRadio.checked) {
                console.log("Mode detected: Similar Questions");
                similarQInputsDiv.classList.remove('hidden');
            } else if (modeWordSearchRadio.checked) { // Line ~360
                console.log("Mode detected: Word Search");
                wordSearchInputsDiv.classList.remove('hidden');
                generateButton.textContent = 'Get Word List';
            } else if (modeKeywordsDefinitionsRadio.checked) { // Use the new radio button ID
                console.log("Mode detected: Keywords/Definitions");
                keywordsDefinitionsInputsDiv.classList.remove('hidden');
                generateButton.textContent = 'Generate New'; // Main button not used for this mode
                generateButton.disabled = true; // Disable main button for this mode
            } else if (modeImageLabelRadio.checked) {
                console.log("Mode detected: Image Labelling");
                imageLabelInputsDiv.classList.remove('hidden');
                imageLabelInputsDiv.style.display = 'block';
                generateButton.disabled = true; // Disable main generate button for this mode

            // Hide the main central preview area for this mode
                itemPreviewArea.style.display = 'none';
                toggleEditButton.style.display = 'none'; // Hide main editor buttons too
                saveButton.style.display = 'none';
                addToSheetButton.style.display = 'none';

            // Reset Image Labelling specific state IF NOT loading
                if (!isLoadingItem) {
                    console.log("Image Label Mode: Resetting state.");
                    baseImageFilename = null;
                    labelBoxes = [];
                    isAddBoxMode = false;
                    selectedBoxId = null;
                    nextBoxNumber = 1;
                    ilPreviewImage.src = '#';
                    ilPreviewContainer.style.display = 'none';
                    ilInteractionControls.style.display = 'none';
                    ilBoxControls.style.display = 'none';
                    ilBaseImageUpload.value = ''; // Clear file input
                    ilUploadStatus.textContent = '';
                    imageLabelStatus.textContent = '';
                    imageLabelItemIdDisplay.textContent = '';
                    // Clear any drawn boxes
                    const existingBoxes = ilPreviewContainer.querySelectorAll('.label-box');
                    existingBoxes.forEach(box => box.remove());
                    // Reset buttons specific to this mode
                    saveImageLabelItemBtn.disabled = true;
                    addImageLabelToWorksheetBtn.disabled = true;
                } else {
                    console.log("Image Label Mode: Skipping state reset during load.");
                    // Ensure controls are visible if loading happened
                    ilInteractionControls.style.display = 'block';
                    saveImageLabelItemBtn.disabled = false; // Should be enabled after load
                    addImageLabelToWorksheetBtn.disabled = false; // Should be enabled after load
                }
            }
            else if (modeSimilarWrittenQRadio.checked) {
                console.log("Mode detected: Similar Written Questions");
                similarWrittenQInputsDiv.classList.remove('hidden');
                // Ensure main preview/buttons are visible and main generate is enabled
                itemPreviewArea.style.display = 'block';
                toggleEditButton.style.display = 'inline-block';
                saveButton.style.display = 'inline-block';
                addToSheetButton.style.display = 'inline-block';
                generateButton.textContent = 'Generate New';
                generateButton.disabled = false;
            }
            else { // Default case (Gap Fill)
                console.log("Mode detected: Default (Gap Fill)");
                gapFillInputsDiv.classList.remove('hidden');
                generateButton.textContent = 'Generate New'; // Reset text
                generateButton.disabled = false; // Ensure enabled
            }
        }
        function handleUserModeSelectionChange(event) {
            console.log(`User mode selection change event fired for: ${this.value}. Event isTrusted: ${event.isTrusted}`);
            if (event.isTrusted) { // ONLY act if the event was genuinely triggered by the user
                console.log(`   Event was trusted (user click). Calling handleModeChange(false). currentItemIdInPreview was: ${currentItemIdInPreview}`);
                handleModeChange(false, null); 
            } else {
                console.log(`   Event was NOT trusted (programmatic or dispatched). Ignoring for ID reset.`);
            }
        }

    // Reset output and buttons
    itemPreviewArea.innerHTML = 'Enter details for the selected mode and click Generate.';
    toggleEditButton.disabled = true;
    saveButton.disabled = true;
    addToSheetButton.disabled = true;
    toggleEditButton.textContent = 'Enable Editing';
    if (isEditingEnabled) {
        itemPreviewArea.style.border = '1px solid #ccc';
        isEditingEnabled = false;
    }
    // **** ADD Image Upload Listener ****
    ilBaseImageUpload.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) {
            ilUploadStatus.textContent = 'No file selected.';
            return;
        }

        // Basic client-side validation
        if (!file.type.startsWith('image/')) {
            ilUploadStatus.textContent = 'Error: Selected file is not an image.';
            ilUploadStatus.style.color = 'red';
            return;
        }
        // Optional: Size validation (e.g., < 10MB)
        const maxSizeMB = 10;
        if (file.size > maxSizeMB * 1024 * 1024) {
             ilUploadStatus.textContent = `Error: Image size exceeds ${maxSizeMB}MB limit.`;
             ilUploadStatus.style.color = 'red';
             return;
        }

        ilUploadStatus.textContent = 'Uploading image...';
        ilUploadStatus.style.color = 'grey';

        const formData = new FormData();
        formData.append('imageFile', file);

        try {
            const response = await fetch('/upload_base_image', {
                method: 'POST',
                body: formData
            });
            const data = await response.json();

            if (!response.ok || data.status !== 'success') {
                throw new Error(data.message || `HTTP error! Status: ${response.status}`);
            }

            // Success!
            baseImageFilename = data.filename; // Store the unique filename
            ilPreviewImage.src = data.image_url; // Set the preview image source
            ilPreviewImage.dataset.filename = data.filename; // Store on element too if needed
            ilPreviewContainer.style.display = 'block'; // Show the preview container
            ilInteractionControls.style.display = 'block'; // Show the add box toggle etc.
            ilUploadStatus.textContent = 'Image uploaded successfully.';
            ilUploadStatus.style.color = 'green';

            // Reset any existing boxes if a new image is uploaded
            labelBoxes.forEach(boxData => boxData.element.remove()); // Remove from DOM
            labelBoxes = []; // Clear array
            selectedBoxId = null;
            nextBoxNumber = 1;
            ilBoxControls.style.display = 'none';
            ilAddBoxModeToggle.checked = false;
            isAddBoxMode = false;

            // Enable save/add buttons now that we have an image
            saveImageLabelItemBtn.disabled = false;
            addImageLabelToWorksheetBtn.disabled = false; // Enable add only AFTER saving? Plan says add requires saved item ID. Let's disable add for now.
            addImageLabelToWorksheetBtn.disabled = true; // ****** DISABLE ADD initially ******
            imageLabelStatus.textContent = "Image loaded. Add boxes or save.";


        } catch (error) {
            console.error("Error uploading image:", error);
            ilUploadStatus.textContent = `Upload Error: ${error.message}`;
            ilUploadStatus.style.color = 'red';
            ilPreviewContainer.style.display = 'none'; // Hide preview on error
            ilInteractionControls.style.display = 'none';
             // Disable buttons
             saveImageLabelItemBtn.disabled = true;
             addImageLabelToWorksheetBtn.disabled = true;
        }
    });
    // **** END Image Upload Listener ****
    // **** ADD Add Box Toggle Listener ****
    ilAddBoxModeToggle.addEventListener('change', (event) => {
        // **** ADD A LOG HERE ****
        console.log("Checkbox 'change' event fired. Checked state:", event.target.checked);
        isAddBoxMode = event.target.checked; // This line SHOULD set it
        if (isAddBoxMode) {
            ilPreviewImage.style.cursor = 'crosshair';
            console.log("Add Box Mode ENABLED (isAddBoxMode is now true)");
        } else {
            ilPreviewImage.style.cursor = 'default';
            console.log("Add Box Mode DISABLED (isAddBoxMode is now false)");
        }
    });
    // **** END Add Box Toggle Listener ****
// **** ADD Image Click Listener (for Adding Boxes) ****
ilPreviewContainer.addEventListener('pointerdown', (event) => {
        // Only start drawing if in Add Box Mode AND clicking directly on the container/image,
        // not on an existing box handle or resize corner.
        if (isAddBoxMode && baseImageFilename && event.target === ilPreviewImage) { // Ensure click is on image background
             // Prevent default browser drag behavior for images
             event.preventDefault();

            isDrawingNewBox = true;
            const rect = ilPreviewContainer.getBoundingClientRect();
            startDrawX = event.clientX - rect.left; // Coords relative to container
            startDrawY = event.clientY - rect.top;

            // Create temporary visual box
            tempDrawBox = document.createElement('div');
            tempDrawBox.style.position = 'absolute';
            tempDrawBox.style.border = '1px dashed blue'; // Style for drawing feedback
            tempDrawBox.style.left = `${startDrawX}px`;
            tempDrawBox.style.top = `${startDrawY}px`;
            tempDrawBox.style.width = '0px';
            tempDrawBox.style.height = '0px';
            tempDrawBox.style.pointerEvents = 'none'; // Prevent interference
            ilPreviewContainer.appendChild(tempDrawBox);

            console.log(`Start drawing new box at: ${startDrawX.toFixed(1)}, ${startDrawY.toFixed(1)}`);

            // Add move/up listeners to the *window* to capture events even if pointer leaves container
            window.addEventListener('pointermove', handlePointerMoveDraw);
            window.addEventListener('pointerup', handlePointerUpDraw, { once: true }); // {once: true} automatically removes listener after firing once
        }
    });

    function handlePointerMoveDraw(event) {
        if (!isDrawingNewBox || !tempDrawBox) return;

        const rect = ilPreviewContainer.getBoundingClientRect();
        let currentX = event.clientX - rect.left;
        let currentY = event.clientY - rect.top;

        // Calculate dimensions and position (handle drawing in any direction)
        let left = Math.min(startDrawX, currentX);
        let top = Math.min(startDrawY, currentY);
        let width = Math.abs(startDrawX - currentX);
        let height = Math.abs(startDrawY - currentY);

        // Update temporary box style
        tempDrawBox.style.left = `${left}px`;
        tempDrawBox.style.top = `${top}px`;
        tempDrawBox.style.width = `${width}px`;
        tempDrawBox.style.height = `${height}px`;
    }

    function handlePointerUpDraw(event) {
        if (!isDrawingNewBox || !tempDrawBox) {
            // Clean up just in case state is inconsistent
            isDrawingNewBox = false;
            window.removeEventListener('pointermove', handlePointerMoveDraw);
            return;
        }

        // Remove temporary box
        tempDrawBox.remove();
        tempDrawBox = null;

        const rect = ilPreviewContainer.getBoundingClientRect();
        let endDrawX = event.clientX - rect.left;
        let endDrawY = event.clientY - rect.top;

        // Calculate final dimensions (ensure minimum size)
        let finalLeft = Math.min(startDrawX, endDrawX);
        let finalTop = Math.min(startDrawY, endDrawY);
        let finalWidth = Math.abs(startDrawX - endDrawX);
        let finalHeight = Math.abs(startDrawY - endDrawY);

        // Enforce minimum size
        const minBoxSize = 20; // Minimum pixels W or H
        if (finalWidth < minBoxSize || finalHeight < minBoxSize) {
            console.log("Box too small, cancelling.");
            isDrawingNewBox = false;
            window.removeEventListener('pointermove', handlePointerMoveDraw);
            // No need to remove pointerup listener due to {once: true}
            return; // Don't create the box if it's too small
        }

        console.log(`Finished drawing. Creating box at L,T:(${finalLeft.toFixed(1)}, ${finalTop.toFixed(1)}) W,H:(${finalWidth.toFixed(1)}, ${finalHeight.toFixed(1)})`);

        // Create the actual label box using calculated values
        createLabelBox(finalLeft, finalTop, finalWidth, finalHeight);

        // Reset drawing state BUT KEEP Add Box Mode active
        isDrawingNewBox = false;
        // No need to touch isAddBoxMode or the checkbox here

        // Clean up listeners
        window.removeEventListener('pointermove', handlePointerMoveDraw);
         // No need to remove pointerup listener due to {once: true}

        console.log("Box created. Add Box Mode remains ENABLED.");
    }
// **** END Image Click Listener ****
// **** ADD Image Click Listener (for Adding Boxes) ****

    // **** END Image Click Listener ****
        // --- Parsing Functions (Keep all 6 definitions) ---
        function parseAndStructureGapFill(rawText) { /* ... Full function ... */
             const keyIdentifier = "Answer Key:"; const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im')); let contentPart = rawText; let keyPart = ""; let structuredHtml = "";
            if (keyIndex !== -1) { contentPart = rawText.substring(0, keyIndex).trim(); keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim(); } else { console.warn("Could not find 'Answer Key:' separator."); return `<div class="worksheet-section"><h3>Worksheet (Format Issue?)</h3><div>${contentPart.replace(/\n/g, '<br>')}</div></div>`; }
            const sentences = contentPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="gap-fill-sentences"><h3>Worksheet Sentences</h3>'; sentences.forEach((sentence, index) => { structuredHtml += `<p data-index="${index}">${sentence.trim()}</p>`; }); structuredHtml += '</div>';
            const answers = keyPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="gap-fill-answers"><h3>Answer Key</h3><ol>'; answers.forEach((answerLine) => { const cleanedAnswer = answerLine.replace(/^\d+\.\s*/, '').trim(); if (cleanedAnswer) { structuredHtml += `<li>${cleanedAnswer}</li>`; } }); structuredHtml += '</ol></div>'; return structuredHtml;
         }
        function parseAndStructureQuestions(rawText) { /* ... Full function ... */
             const questions = rawText.split('\n').filter(line => line.trim() !== ''); let structuredHtml = '<div class="worksheet-section" id="comprehension-questions"><h3>Comprehension Questions</h3><ol>'; questions.forEach((questionLine) => { const cleanedQuestion = questionLine.replace(/^\d+\.\s*/, '').trim(); if (cleanedQuestion) { structuredHtml += `<li>${cleanedQuestion}</li>`; } }); structuredHtml += '</ol></div>'; return structuredHtml;
        }
        function parseAndStructureMCQ(rawText) { /* ... Full function ... */
            const keyIdentifier = "Answer Key:"; const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im')); let questionsPart = rawText; let keyPart = ""; let structuredHtml = "";
            if (keyIndex !== -1) { questionsPart = rawText.substring(0, keyIndex).trim(); keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim(); } else { console.warn("Could not find 'Answer Key:' separator for MCQs."); return `<div class="worksheet-section"><h3>Questions (Format Issue?)</h3><div>${questionsPart.replace(/\n/g, '<br>')}</div></div>`; }
            structuredHtml += '<div class="worksheet-section" id="mcq-questions"><h3>Multiple Choice Questions</h3>'; const lines = questionsPart.split('\n').filter(line => line.trim() !== ''); let currentQuestionNumber = 0;
            lines.forEach(line => { line = line.trim(); const questionMatch = line.match(/^(\d+)\.\s*(.*)/); const optionMatch = line.match(/^[A-D]\.\s*(.*)/i); if (questionMatch) { currentQuestionNumber = parseInt(questionMatch[1], 10); if (currentQuestionNumber > 1) { structuredHtml += '</ul>'; } structuredHtml += `<p><strong>${questionMatch[1]}. ${questionMatch[2]}</strong></p><ul style="list-style: upper-alpha; margin-left: 20px;">`; } else if (optionMatch) { structuredHtml += `<li>${optionMatch[1]}</li>`; } else if (line) { structuredHtml += `<div>${line}</div>`; } }); if (currentQuestionNumber > 0) { structuredHtml += '</ul>'; } structuredHtml += '</div>';
            const answers = keyPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="mcq-answers"><h3>Answer Key</h3><ol>'; answers.forEach((answerLine) => { const cleanedAnswer = answerLine.trim().replace(/^\d+\.\s*/, ''); if(cleanedAnswer) { structuredHtml += `<li>${cleanedAnswer}</li>`; } }); structuredHtml += '</ol></div>'; return structuredHtml;
         }
        function parseAndStructureTrueFalse(rawText) { /* ... Full function ... */
            const keyIdentifier = "Answer Key:"; const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im')); let statementsPart = rawText; let keyPart = ""; let structuredHtml = "";
            if (keyIndex !== -1) { statementsPart = rawText.substring(0, keyIndex).trim(); keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim(); } else { console.warn("Could not find 'Answer Key:' separator for True/False."); return `<div class="worksheet-section"><h3>Statements (Format Issue?)</h3><div>${statementsPart.replace(/\n/g, '<br>')}</div></div>`; }
            const statements = statementsPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="tf-statements"><h3>True/False Statements</h3><ol>'; statements.forEach((statementLine) => { const cleanedStatement = statementLine.replace(/^\d+\.\s*/, '').trim(); if (cleanedStatement) { structuredHtml += `<li>${cleanedStatement}</li>`; } }); structuredHtml += '</ol></div>';
            const answers = keyPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="tf-answers"><h3>Answer Key</h3><ol>'; answers.forEach((answerLine) => { const cleanedAnswer = answerLine.trim().replace(/^\d+\.\s*/, ''); if(cleanedAnswer) { structuredHtml += `<li>${cleanedAnswer}</li>`; } }); structuredHtml += '</ol></div>'; return structuredHtml;
        }
        function parseAndStructureSimilarQuestions(rawText) {
        console.log("Parsing Similar Questions Text:", rawText.substring(0, 250) + "..."); // Log more context

        // Define markers more flexibly (case-insensitive, optional number/formatting)
        const analysisMarker = "Analysis of Example:"; // Keep this simple
        const questionsMarker = "New Similar Questions:"; // Look for this text after a number/bullet
        const keyMarker = "Answer Key:";

        let analysisPart = ""; // We'll extract but might not display
        let questionsPart = "";
        let keyPart = "";
        let parseSuccess = false;

        // Find indices using case-insensitive search and allowing flexibility
        const analysisIndex = rawText.search(new RegExp(analysisMarker, 'i'));
        // Look for the key marker first, as it should reliably be at the end
        const keyIndex = rawText.search(new RegExp(`^${keyMarker.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im'));

        if (keyIndex !== -1) {
            // If key is found, assume everything before it belongs to questions/analysis
            const beforeKey = rawText.substring(0, keyIndex).trim();
            keyPart = rawText.substring(keyIndex + keyMarker.length).trim();

            // Now try to find the start of the actual questions within the 'beforeKey' part
            // Look for the first line starting with "1." after the analysis section (if analysis exists)
            let questionStartIndex = -1;
            if (analysisIndex !== -1 && analysisIndex < keyIndex) {
                 // Find the end of the analysis block (next newline after analysis marker)
                 const analysisEndIndex = beforeKey.indexOf('\n', analysisIndex);
                 const potentialQuestionArea = analysisEndIndex !== -1 ? beforeKey.substring(analysisEndIndex) : beforeKey;
                 // Find the first "1." in that area
                 questionStartIndex = potentialQuestionArea.search(/^\s*1\.\s+/m);
                 if (questionStartIndex !== -1) {
                     questionStartIndex += (analysisEndIndex !== -1 ? analysisEndIndex : 0); // Adjust index relative to start of beforeKey
                     analysisPart = beforeKey.substring(analysisIndex + analysisMarker.length, questionStartIndex).trim();
                     questionsPart = beforeKey.substring(questionStartIndex).trim();
                     parseSuccess = true;
                 }
            } else {
                 // If no clear analysis marker, assume questions start near the beginning
                 questionStartIndex = beforeKey.search(/^\s*1\.\s+/m);
                 if (questionStartIndex !== -1) {
                     analysisPart = ""; // No analysis extracted
                     questionsPart = beforeKey.substring(questionStartIndex).trim();
                     parseSuccess = true;
                 }
            }

            if(parseSuccess) {
                 console.log("Successfully split SimilarQ into Questions/Key parts (Analysis optional).");
            }

        }

        // If parsing failed, use fallback
        if (!parseSuccess) {
            console.warn("Could not reliably split Similar Questions output. Displaying raw.");
            let fallbackHtml = rawText.replace(/\n/g, '<br>');
            // Try to hide analysis/key roughly if possible in fallback
             const keyIdxFallback = fallbackHtml.search(new RegExp(keyMarker,'i'));
             if(keyIdxFallback !== -1) fallbackHtml = fallbackHtml.substring(0, keyIdxFallback);
             const analysisIdxFallback = fallbackHtml.search(new RegExp(analysisMarker,'i'));
             if(analysisIdxFallback !== -1) fallbackHtml = fallbackHtml.substring(analysisIdxFallback + analysisMarker.length);

            return `<div class="worksheet-section"><h3>Similar Questions (Format Issue?)</h3><div>${fallbackHtml}</div></div>`;
        }
        
        let structuredHtml = "";

        // --- Display Questions Part ONLY ---
        // We are *not* adding the 'analysisPart' to the structuredHtml meant for the worksheet item
        const questions = questionsPart.split('\n').filter(line => line.trim() !== '' && !line.match(/^\d+\s+New Similar Questions:/i)); // Also filter out the title line
        structuredHtml += '<div class="worksheet-section" id="sq-questions"><h3>Generated Questions</h3>';
        structuredHtml += '<ol>';
        questions.forEach((questionLine) => {
            const cleanedQuestion = questionLine.replace(/^\d+\.\s*/, '').trim(); // Remove number
            if (cleanedQuestion) {
                structuredHtml += `<li>${cleanedQuestion}</li>`;
            }
        });
        structuredHtml += '</ol></div>'; // Close sq-questions div

        // --- Process and ADD Answer Key Part (Hidden by default later?) ---
        const answerLines = keyPart.split('\n').filter(line => line.trim() !== '');
        // Maybe hide this section by default later
        structuredHtml += '<div class="worksheet-section answer-key-container" id="sq-answers"><h3>Answer Key</h3>'; // Added answer-key-container class
        structuredHtml += '<ol>';
        let currentAnswerContent = ''; let currentQuestionNumber = null;
        answerLines.forEach((line, index) => {
            line = line.trim(); const numberMatch = line.match(/^(\d+)\.\s*(.*)/);
            if (numberMatch) {
                const questionNum = parseInt(numberMatch[1], 10); const content = numberMatch[2].trim();
                if (currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim().replace(/\n/g,'<br>')}</li>`; }
                currentQuestionNumber = questionNum; currentAnswerContent = content;
            } else if (currentQuestionNumber !== null && line) { currentAnswerContent += `\n<span style="margin-left: 15px;">${line}</span>`; }
            if (index === answerLines.length - 1 && currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim().replace(/\n/g,'<br>')}</li>`; }
        });
        structuredHtml += '</ol></div>'; // Close sq-answers div

        console.log("Finished parsing Similar Questions.");
        return structuredHtml;
    }
    function displayWordListEditor(wordListText) {
            // Find the container for dynamic controls within the word search input div
            const dynamicControlsContainer = document.getElementById('wordSearchDynamicControls');
            if (!dynamicControlsContainer) {
                console.error("Could not find wordSearchDynamicControls container!");
                return;
            }

            // Clear previous dynamic controls if any
            dynamicControlsContainer.innerHTML = '';

            // 1. Parse the word list text
            const words = wordListText.split('\n')
                .map(line => line.replace(/^\d+\.\s*/, '').trim()) // Remove numbering, trim whitespace
                .filter(word => word.length > 0); // Remove empty lines

            // 2. Create Textarea for editing
            const wordListLabel = document.createElement('label');
            wordListLabel.htmlFor = 'wordListEditArea';
            wordListLabel.textContent = 'Edit Word List (one word/phrase per line):';
            wordListLabel.style.marginTop = '15px'; // Add some top margin
            const wordListTextArea = document.createElement('textarea');
            wordListTextArea.id = 'wordListEditArea';
            wordListTextArea.rows = 10; // Adjust size as needed
            wordListTextArea.value = words.join('\n'); // Populate with one word per line
            // Inherit some basic styles if needed, otherwise rely on global styles
            wordListTextArea.style.maxWidth = '450px';
            wordListTextArea.style.width = '100%';

            // 3. Create Size Selector
            const sizeLabel = document.createElement('label');
            sizeLabel.htmlFor = 'wordSearchSizeSelect';
            sizeLabel.textContent = 'Select Grid Size:';
            sizeLabel.style.marginTop = '15px';
            const sizeSelect = document.createElement('select');
            sizeSelect.id = 'wordSearchSizeSelect';
            sizeSelect.style.marginBottom = '15px'; // Add bottom margin
            const sizes = { "small": "Small (~10x10)", "medium": "Medium (~13x13)", "large": "Large (~15x15)" };
            for (const [value, text] of Object.entries(sizes)) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = text;
                if (value === 'medium') option.selected = true; // Default selection
                sizeSelect.appendChild(option);
            }

            // 4. Create "Generate Grid" Button
            const generateGridButton = document.createElement('button');
            generateGridButton.id = 'generateGridButton';
            generateGridButton.textContent = 'Generate Word Search Grid';
            generateGridButton.style.marginLeft = '0'; // Override default button margin if needed

            // 5. Add Event Listener to the new button
            generateGridButton.addEventListener('click', handleGenerateGridClick);

            // 6. Append new elements to the container
            // Hide the original Topic/Grade inputs within the word search fieldset
            document.getElementById('wsTopicInput').parentElement.style.display = 'none';
            document.getElementById('wsGradeLevelSelect').parentElement.style.display = 'none';

            // Append the new controls
            dynamicControlsContainer.appendChild(wordListLabel);
            dynamicControlsContainer.appendChild(wordListTextArea);
            dynamicControlsContainer.appendChild(document.createElement('br')); // Spacing
            dynamicControlsContainer.appendChild(sizeLabel);
            dynamicControlsContainer.appendChild(sizeSelect);
            dynamicControlsContainer.appendChild(document.createElement('br')); // Spacing
            dynamicControlsContainer.appendChild(generateGridButton);

            console.log("Word list editor UI displayed.");
        }
        async function handleGenerateGridClick() {
            console.log(">>> Generate Grid button clicked <<<");

            // Disable button immediately
            const generateGridButton = document.getElementById('generateGridButton');
            if (generateGridButton) generateGridButton.disabled = true;

            // 1. Get words from textarea
            const wordListTextArea = document.getElementById('wordListEditArea');
            const wordsRaw = wordListTextArea.value.trim();
            const words = wordsRaw.split('\n')
                                .map(word => word.trim())
                                .filter(word => word.length > 0);

            if (words.length === 0) {
                alert("Word list is empty. Please enter words.");
                if (generateGridButton) generateGridButton.disabled = false;
                return;
            }

            // 2. Get selected size
            const sizeSelect = document.getElementById('wordSearchSizeSelect');
            const selectedSize = sizeSelect.value;

            // 3. Prepare payload for backend
            const payload = {
                word_list: words,
                size: selectedSize
                // Add allow_backwards or mask options here if you implement UI for them later
            };

            console.log("Sending payload to /generate_word_search_grid:", payload);
            itemPreviewArea.innerHTML = '<div class="loading">Generating grid...</div>'; // Show loading in preview
            toggleEditButton.disabled = true; saveButton.disabled = true; addToSheetButton.disabled = true; // Disable actions

            // 4. Fetch request to backend
            try {
                const response = await fetch('/generate_word_search_grid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                console.log("Received response from grid generation:", data);

                if (!response.ok) {
                    throw new Error(data.message || `HTTP error! status: ${response.status}`);
                }

                if (data.status === 'success' && data.content_html) {
                    itemPreviewArea.innerHTML = data.content_html; // Display grid HTML
                    // Grid generation successful - enable final actions
                    toggleEditButton.disabled = false; // Allow editing (though maybe less useful for grid?)
                    saveButton.disabled = false;    // Allow saving the generated item
                    addToSheetButton.disabled = false; // Allow adding to worksheet
                    // Optionally hide or keep the grid generation controls? Hiding for now.
                    // wordSearchDynamicControls.style.display = 'none';
                } else {
                    throw new Error(data.message || 'Grid generation failed on the server.');
                }

            } catch (error) {
                console.error("Error generating word search grid:", error);
                itemPreviewArea.innerHTML = `<p style="color: red;">Error generating grid: ${error.message}. Please check word lengths or grid size.</p>`;
                // Re-enable button on error
                if (generateGridButton) generateGridButton.disabled = false;
                // Keep main action buttons disabled
                toggleEditButton.disabled = true; saveButton.disabled = true; addToSheetButton.disabled = true;
            }
        }
        function parseAndStructurePastedComprehension(rawText) {
    console.log("Parsing Pasted Text Comprehension:", rawText.substring(0, 150) + "...");
    // This will be similar to Short Answer or MCQ parsing, expecting Questions + Key
    const keyIdentifier = "Answer Key:";
    const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im'));
    let questionsPart = rawText;
    let keyPart = "";
    let structuredHtml = "";

    if (keyIndex !== -1) {
        questionsPart = rawText.substring(0, keyIndex).trim();
        keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim();
        console.log("Split into Questions / Key parts for Pasted Text Comp");
    } else {
        console.warn("Could not find 'Answer Key:' separator for Pasted Text Comp. Treating all as questions.");
        keyPart = ""; // Assume no key if separator not found
    }

    // Process Questions Part
    const questions = questionsPart.split('\n').filter(line => line.trim() !== '');
    // We add a heading for the questions section
    structuredHtml += '<div class="worksheet-section" id="ptc-questions"><h3>Comprehension Questions</h3>';
    structuredHtml += '<ol>'; // Use ordered list for questions
    questions.forEach((questionLine) => {
        const cleanedQuestion = questionLine.replace(/^\d+\.\s*/, '').trim(); // Remove numbering
        if (cleanedQuestion) {
            structuredHtml += `<li>${cleanedQuestion}</li>`; // Add question as list item
        }
    });
    structuredHtml += '</ol></div>'; // Close ptc-questions div

    // Process Key Part (if found) - Reuse logic from Short Answer parser
    if (keyPart) {
        const answerLines = keyPart.split('\n').filter(line => line.trim() !== '');
        structuredHtml += '<div class="worksheet-section" id="ptc-answers"><h3>Answer Key</h3>';
        structuredHtml += '<ol>'; // Main ordered list for question numbers
        let currentAnswerContent = ''; let currentQuestionNumber = null;
        answerLines.forEach((line, index) => {
            line = line.trim(); const numberMatch = line.match(/^(\d+)\.\s*(.*)/);
            if (numberMatch) {
                const questionNum = parseInt(numberMatch[1], 10); const content = numberMatch[2].trim();
                if (currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim()}</li>`; }
                currentQuestionNumber = questionNum; currentAnswerContent = content;
            } else if (currentQuestionNumber !== null && line) { currentAnswerContent += `<br>   ${line}`; }
            if (index === answerLines.length - 1 && currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim()}</li>`; }
        });
        structuredHtml += '</ol></div>'; // Close ptc-answers div
    }

    console.log("Finished parsing Pasted Text Comprehension.");
    return structuredHtml;
    // NOTE: We are NOT displaying the original pasted text here, only the Qs & Key.
    // If you wanted to include the original text, you'd need to pass it to this function
    // or restructure how the output is built. For now, it just parses the AI response.
}
        function parseAndStructureShortAnswer(rawText) { /* ... Full function ... */
            const keyIdentifier = "Answer Key:"; const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im')); let questionsPart = rawText; let keyPart = ""; let structuredHtml = "";
            if (keyIndex !== -1) { questionsPart = rawText.substring(0, keyIndex).trim(); keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim(); } else { console.warn("Could not find 'Answer Key:' separator for Short Answer."); keyPart = ""; }
            const questions = questionsPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="sa-questions"><h3>Short Answer Questions</h3><ol>'; questions.forEach((questionLine) => { const cleanedQuestion = questionLine.replace(/^\d+\.\s*/, '').trim(); if (cleanedQuestion) { structuredHtml += `<li style="margin-bottom: 1.5em;">${cleanedQuestion}<br><span style="color: #999;">Answer: _______________</span></li>`; } }); structuredHtml += '</ol></div>';
            if (keyPart) { const answerLines = keyPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="sa-answers"><h3>Answer Key / Grading Points</h3><ol>'; let currentAnswerContent = ''; let currentQuestionNumber = null; answerLines.forEach((line, index) => { line = line.trim(); const numberMatch = line.match(/^(\d+)\.\s*(.*)/); if (numberMatch) { const questionNum = parseInt(numberMatch[1], 10); const content = numberMatch[2].trim(); if (currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim()}</li>`; } currentQuestionNumber = questionNum; currentAnswerContent = content; } else if (currentQuestionNumber !== null && line) { currentAnswerContent += `<br>${line}`; } if (index === answerLines.length - 1 && currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim()}</li>`; } }); structuredHtml += '</ol></div>'; }
            return structuredHtml;
        }
        function parseAndStructureTextBlock(rawText) { /* ... Full function ... */
             const formattedText = rawText.replace(/\n/g, '<br>'); let structuredHtml = `<div class="worksheet-section" id="text-block-generated"><h3>Text Block</h3><div>${formattedText}</div></div>`; return structuredHtml;
         }
        // --- END OF PARSING FUNCTIONS ---
// --- START: Keywords & Definitions Functions ---

// --- Fisher-Yates Shuffle Function (Helper) ---
function shuffleArray(array) {
    let currentIndex = array.length, randomIndex;
    // While there remain elements to shuffle.
    while (currentIndex !== 0) {
        // Pick a remaining element.
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        // And swap it with the current element.
        [array[currentIndex], array[randomIndex]] = [
            array[randomIndex], array[currentIndex]];
    }
    return array;
}

// --- Function to Display the Selected Keyword Activity ---
function displayKeywordActivity() {
    const selectedActivity = document.querySelector('input[name="keywordActivity"]:checked').value;
    if (!currentKeywordData || currentKeywordData.length === 0) {
        activityOutput.innerHTML = '<p>No keyword data available.</p>';
        return; // Nothing to display
    }

    let tableHTML = '<table class="keywords-table" style="width: 100%; border-collapse: collapse;">';
    let headerHTML = '';
    let tableBodyHTML = '';

    // Determine columns and potentially shuffle data based on activity type
    let displayData = [...currentKeywordData]; // Shallow copy to avoid modifying original
    let definitions = displayData.map(item => item.definition);
    let keywords = displayData.map(item => item.keyword);

    switch (selectedActivity) {
        case 'reference':
            headerHTML = '<thead><tr><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Keyword</th><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Definition</th></tr></thead>';
            displayData.forEach(item => {
                tableBodyHTML += `<tr><td style="border: 1px solid #ddd; padding: 8px;">${item.keyword}</td><td style="border: 1px solid #ddd; padding: 8px;">${item.definition}</td></tr>`;
            });
            break;

        case 'matching':
            headerHTML = '<thead><tr><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Keyword</th><th style="border: 1px solid #ddd; padding: 8px; width: 50px;"></th><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Definition</th></tr></thead>';
            let shuffledDefinitions = shuffleArray([...definitions]); // Shuffle a copy
            keywords.forEach((keyword, index) => {
                tableBodyHTML += `<tr><td style="border: 1px solid #ddd; padding: 8px;">${keyword}</td><td style="border: 1px solid #ddd; padding: 8px;"></td><td style="border: 1px solid #ddd; padding: 8px;">${shuffledDefinitions[index]}</td></tr>`;
            });
            break;

        case 'definitions':
            headerHTML = '<thead><tr><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Keyword</th><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Definition</th></tr></thead>';
             displayData.forEach(item => {
                tableBodyHTML += `<tr><td style="border: 1px solid #ddd; padding: 8px; height: 2.5em;"></td><td style="border: 1px solid #ddd; padding: 8px;">${item.definition}</td></tr>`; // Add height for writing space
            });
            break;

        case 'keywords':
            headerHTML = '<thead><tr><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Keyword</th><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Definition</th></tr></thead>';
            displayData.forEach(item => {
                tableBodyHTML += `<tr><td style="border: 1px solid #ddd; padding: 8px;">${item.keyword}</td><td style="border: 1px solid #ddd; padding: 8px; height: 2.5em;"></td></tr>`; // Add height for writing space
            });
            break;

        default:
             activityOutput.innerHTML = '<p>Invalid activity type selected.</p>';
            return;
    }

    tableHTML += headerHTML + '<tbody>' + tableBodyHTML + '</tbody></table>';
    activityOutput.innerHTML = tableHTML;

    // --- Add Data Attributes for Saving/Export ---
    // Store raw data for potential use in saving/exporting
    activityOutput.dataset.keywords = JSON.stringify(currentKeywordData);
    activityOutput.dataset.activityType = selectedActivity; // Store which view is current

    // Make the preview editable (optional, maybe not needed for tables?)
    activityOutput.contentEditable = "false";
}
// --- END: Keywords & Definitions Functions ---// --- END OF PARSING FUNCTIONS ---
function addWorksheetItemControls(worksheetItemDiv) {    
    const controlsDiv = document.createElement('div');
    controlsDiv.style.marginBottom = '10px';
    controlsDiv.style.textAlign = 'right'; // Align buttons to the right

    // --- 2. Create Move Up Button ---
    const moveUpButton = document.createElement('button');
    moveUpButton.textContent = ' Up';
    moveUpButton.style.backgroundColor = '#6c757d'; // Grey
    moveUpButton.style.color = 'white';
    moveUpButton.style.padding = '3px 8px';
    moveUpButton.style.fontSize = '0.8em';
    moveUpButton.style.marginLeft = '5px';
    moveUpButton.title = 'Move item up';
    moveUpButton.onclick = () => {
        const currentItem = worksheetItemDiv;
        const previousItem = currentItem.previousElementSibling;
        if (previousItem && previousItem.classList.contains('worksheet-item')) {
            worksheetAssemblyArea.insertBefore(currentItem, previousItem);
            console.log("Moved item up.");
            // updateWorksheetItemNumbers(); // Uncomment if needed
        } else {
            console.log("Cannot move first item up.");
        }
    };
    // --- 3. Append Move Up Button to controlsDiv ---
    controlsDiv.appendChild(moveUpButton); // <<< APPEND HERE

    // --- 4. Create Move Down Button ---
    const moveDownButton = document.createElement('button');
    moveDownButton.textContent = ' Down';
    moveDownButton.style.backgroundColor = '#6c757d'; // Grey
    moveDownButton.style.color = 'white';
    moveDownButton.style.padding = '3px 8px';
    moveDownButton.style.fontSize = '0.8em';
    moveDownButton.style.marginLeft = '5px';
    moveDownButton.title = 'Move item down';
    moveDownButton.onclick = () => {
        const currentItem = worksheetItemDiv;
        const nextItem = currentItem.nextElementSibling;
        if (nextItem && nextItem.classList.contains('worksheet-item')) {
            worksheetAssemblyArea.insertBefore(nextItem, currentItem);
            console.log("Moved item down.");
            // updateWorksheetItemNumbers(); // Uncomment if needed
        } else {
            console.log("Cannot move last item down.");
        }
    };
    // --- 5. Append Move Down Button to controlsDiv ---
    controlsDiv.appendChild(moveDownButton); // <<< APPEND HERE

    // --- 6. Create Remove Button ---
    const removeButton = document.createElement('button');
    removeButton.textContent = ' Remove';
    removeButton.style.backgroundColor = '#dc3545'; // Red color
    removeButton.style.color = 'white';
    removeButton.style.padding = '3px 8px';
    removeButton.style.fontSize = '0.8em';
    removeButton.style.marginLeft = '5px';
    removeButton.title = 'Remove item from worksheet';
    removeButton.onclick = () => {
        if (confirm("Are you sure you want to remove this item from the worksheet?")) {
             worksheetItemDiv.remove();
             console.log("Worksheet item removed.");
             if (worksheetAssemblyArea.querySelectorAll('.worksheet-item').length === 0) {
                  worksheetAssemblyArea.innerHTML = '<p style="color: grey; font-style: italic;">Items added to the worksheet will appear here.</p>';
             }
            // updateWorksheetItemNumbers(); // Uncomment if needed
        }
    };
    // --- 7. Append Remove Button to controlsDiv ---
    controlsDiv.appendChild(removeButton); // <<< APPEND HERE

    // --- 8. Add the completed controlsDiv to the worksheetItemDiv ---
    // Prepend ensures controls are always at the top, before the content
    if (worksheetItemDiv.firstChild) {
        worksheetItemDiv.insertBefore(controlsDiv, worksheetItemDiv.firstChild);
    } else {
        worksheetItemDiv.appendChild(controlsDiv);
    }
}
// **** Function to recalculate and apply label positions in worksheet area ****
function updateWorksheetLabels() {
    //console.log("Resize detected, updating worksheet labels...");
    const imageLabelItems = document.querySelectorAll('#worksheetAssemblyArea .worksheet-item[data-item-type="imageLabel"]');

    imageLabelItems.forEach(item => {
        const imageContainer = item.querySelector('.worksheet-image-label-container'); // Find the specific container we added
        const worksheetImage = imageContainer ? imageContainer.querySelector('img') : null; // Find the image inside that container
        const itemDataString = item.dataset.itemData;

        // Ensure we have all necessary elements and data
        if (!imageContainer || !worksheetImage || !itemDataString || !worksheetImage.offsetWidth) {
             // If image has no width yet (e.g., display:none), skip update for this item
            // console.warn("Skipping label update for item - image/container not ready or no data.", item);
            return;
        }

        if (!worksheetImage || !itemDataString || !worksheetImage.offsetWidth || worksheetImage.offsetWidth === 0) {
            // console.warn("updateWorksheetLabels: Skipping label update - image/container not ready or no data for item:", item);
            return;
        }
        try {
            const itemData = JSON.parse(itemDataString);
            const boxesPctData = itemData.boxes_pct; // Get the stored percentage data
            // We need the dimensions the image IS CURRENTLY RENDERED AT in the worksheet
            const wsImageRenderedWidth = worksheetImage.offsetWidth;
            const wsImageRenderedHeight = worksheetImage.offsetHeight;

            // Get all static boxes *within this specific item's container*
            const staticLabels = imageContainer.querySelectorAll('.static-label-box');

            if (boxesPctData && Array.isArray(boxesPctData)) {
                    if (staticLabels.length !== boxesPctData.length) {
                        // console.warn(`updateWorksheetLabels: Mismatch between stored boxes (${boxesPctData.length}) and DOM static labels (${staticLabels.length}) for item. Re-creating them might be needed, or initial placement was incomplete.`);
                        // This could happen if the image onload in addImageLabelToWorksheetBtn didn't finish
                        // For now, we'll proceed, but it might indicate an issue.
                    }
                 // Assuming the order of boxesPctData matches the order of staticLabels created
                 // This could be made more robust by adding a data-box-id attribute if needed
                boxesPctData.forEach((boxPct, index) => {
                    const labelDiv = staticLabels[index]; // Match by index
                    if (labelDiv) {
                        // Recalculate pixel values based on CURRENT rendered image size
                        const px_x = (parseFloat(boxPct.x_pct || 0) / 100) * wsImageRenderedWidth;
                        const px_y = (parseFloat(boxPct.y_pct || 0) / 100) * wsImageRenderedHeight;
                        const px_w = (parseFloat(boxPct.width_pct || 10) / 100) * wsImageRenderedWidth; // Use same defaults as loading
                        const px_h = (parseFloat(boxPct.height_pct || 5) / 100) * wsImageRenderedHeight; // Use same defaults as loading

                        // Update the inline styles of the existing static box
                        labelDiv.style.left = `${px_x}px`;
                        labelDiv.style.top = `${px_y}px`;
                        labelDiv.style.width = `${px_w}px`;
                        labelDiv.style.height = `${px_h}px`;
                    } else {
                        console.warn(`Mismatch: Found % data for index ${index} but no corresponding static label div.`);
                    }
                });
            } else {
                 console.warn("No valid boxes_pct data found in dataset for item:", item);
            }
        } catch (e) {
            console.error("Error parsing itemData or updating labels on resize for item:", item, e);
        }
    });
}
        // --- Event Listeners (Consolidated) ---
        modeGapFillRadio.addEventListener('change', function(event) {
            console.log("GapFill Radio 'change' EVENT FIRED. Event object:", event);
            console.log("  event.isTrusted:", event.isTrusted);
            console.log("  Calling handleModeChange WITHOUT itemIdToPreserve because this is a user/radio change.");
            handleModeChange(false);
        });
        modePastedTextRadio.addEventListener('change', handleModeChange);
        modeMcqRadio.addEventListener('change', function(event) { // Wrap in an anonymous function
            console.log("MCQ Radio 'change' EVENT FIRED. Event object:", event);
            console.log("  event.isTrusted:", event.isTrusted); // true for user, false for programmatic if supported
            console.log("  Calling handleModeChange WITHOUT itemIdToPreserve because this is a user/radio change.");
            handleModeChange(false); // Explicitly pass false, no second arg
        });
        modeGapFillRadio.addEventListener('change', handleUserModeSelectionChange);
        modePastedTextRadio.addEventListener('change', handleUserModeSelectionChange);
        modeMcqRadio.addEventListener('change', handleUserModeSelectionChange);
        modeTrueFalseRadio.addEventListener('change', handleUserModeSelectionChange);
        modeShortAnswerRadio.addEventListener('change', handleUserModeSelectionChange);
        modeTextBlockRadio.addEventListener('change', handleUserModeSelectionChange);
        modeSimilarQRadio.addEventListener('change', handleUserModeSelectionChange);
        modeWordSearchRadio.addEventListener('change', handleUserModeSelectionChange);
        modeKeywordsDefinitionsRadio.addEventListener('change', handleUserModeSelectionChange);
        modeSimilarWrittenQRadio.addEventListener('change', handleUserModeSelectionChange);
        modeImageLabelRadio.addEventListener('change', handleUserModeSelectionChange);
        
        // tbGenerateTextCheckbox listener remains as is:
        tbGenerateTextCheckbox.addEventListener('change', handleTbCheckboxChange);
        generateButton.addEventListener('click', async () => {
            console.log(">>> generateButton clicked! <<<");
            console.log(`Generate Button: currentItemIdInPreview was: ${currentItemIdInPreview}`);
            currentItemIdInPreview = null; // Reset item ID tracking
            console.log("Generate Button: currentItemIdInPreview NOW RESET TO NULL.");

            const selectedMode = document.querySelector('input[name="generatorMode"]:checked').value;
            console.log(">>> Mode Selected:", selectedMode);

            // --- Reset UI ---
            itemPreviewArea.innerHTML = '<div class="loading">Generating... Please wait.</div>';
            generateButton.disabled = true; // Disable button during processing
            toggleEditButton.disabled = true;
            saveButton.disabled = true;
            addToSheetButton.disabled = true;
            toggleEditButton.textContent = 'Enable Editing';
            if (isEditingEnabled) { itemPreviewArea.style.border = '1px solid #ccc'; isEditingEnabled = false; }

            // --- Prepare Payload & Validation ---
            let fetchUrl = '';
            let payload = { item_type: selectedMode }; // Include type early
            let isValid = true;
            let isWordListRequest = false; // Flag for the first step of word search
            let useDirectText = false;

            if (selectedMode === 'gapFill') {
                payload.topic = topicInput.value.trim();
                payload.grade_level = gradeLevelSelect.value;
                payload.num_sentences = parseInt(gfNumSentencesInput.value, 10) || 7;
                if (!payload.topic) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please enter a topic.</p>'; }
                else if (payload.num_sentences < 3 || payload.num_sentences > 15) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Sentences must be 3-15.</p>'; }
                else { fetchUrl = '/generate_worksheet'; }
            } else if (selectedMode === 'textBlock') {
                const generate = tbGenerateTextCheckbox.checked;
                const directTextValue = tbDirectInput.value.trim();
                if (generate) {
                    payload.topic = tbTopicInput.value.trim();
                    payload.grade_level = tbGradeLevelSelect.value;
                    if (!payload.topic) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please enter topic for AI generation.</p>'; }
                    else { fetchUrl = '/generate_text_block'; }
                } else { // Direct text input
                    if (!directTextValue) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Enter text directly or check box.</p>'; }
                    else { useDirectText = true; } // Handled below, no fetch
                }
            } else if (selectedMode === 'pastedText') {
                payload.pasted_text = pastedTextInputArea.value; // Keep raw
                payload.num_questions = parseInt(ptNumQuestionsInput.value, 10) || 5;
                if (!payload.pasted_text || !payload.pasted_text.trim()) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please paste text.</p>'; }
                else if (payload.num_questions < 2 || payload.num_questions > 15) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Questions must be 2-15.</p>'; }
                else { fetchUrl = '/generate_pasted_comprehension'; payload.grade_level = "mixed"; } // Set default grade
            } else if (selectedMode === 'mcq') {
                payload.topic = mcqTopicInput.value.trim();
                payload.grade_level = mcqGradeLevelSelect.value;
                payload.num_questions = parseInt(mcqNumQuestionsInput.value, 10) || 5;
                if (!payload.topic) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please enter topic.</p>'; }
                else if (payload.num_questions < 2 || payload.num_questions > 15) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Questions must be 2-15.</p>'; }
                else { fetchUrl = '/generate_mcq'; }
            } else if (selectedMode === 'trueFalse') {
                payload.topic = tfTopicInput.value.trim();
                payload.grade_level = tfGradeLevelSelect.value;
                payload.num_statements = parseInt(tfNumStatementsInput.value, 10) || 8;
                if (!payload.topic) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please enter topic.</p>'; }
                else if (payload.num_statements < 3 || payload.num_statements > 20) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Statements must be 3-20.</p>'; }
                else { fetchUrl = '/generate_true_false'; }
            } else if (selectedMode === 'shortAnswer') {
                payload.topic = saTopicInput.value.trim();
                payload.grade_level = saGradeLevelSelect.value;
                payload.num_questions = parseInt(saNumQuestionsInput.value, 10) || 5;
                if (!payload.topic) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please enter topic.</p>'; }
                else if (payload.num_questions < 2 || payload.num_questions > 10) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Questions must be 2-10.</p>'; }
                else { fetchUrl = '/generate_short_answer'; }
            } else if (selectedMode === 'similarQ') {
                payload.example_question = sqExampleInput.value; // Keep raw
                payload.num_questions = parseInt(sqNumQuestionsInput.value, 10) || 3;
                payload.grade_level = sqGradeLevelSelect.value;
                if (!payload.example_question || !payload.example_question.trim()) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please paste example question.</p>'; }
                else if (payload.num_questions < 1 || payload.num_questions > 10) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Questions must be 1-10.</p>'; }
                else { fetchUrl = '/generate_similar_questions'; }
            }
            // --- ADDED: Word Search Mode Handling ---
            else if (selectedMode === 'similarWrittenQ') {
                payload.example_question = swqExampleInput.value.trim();
                payload.num_questions = parseInt(swqNumQuestionsInput.value, 10) || 3;
                payload.grade_level = swqGradeLevelSelect.value; // Will be "Not Specified" if user selects that
                if (!payload.example_question) {
                    isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please paste an example question.</p>';
                } else if (payload.num_questions < 1 || payload.num_questions > 10) {
                    isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Number of questions must be 1-10.</p>';
                } else {
                    fetchUrl = '/generate_similar_written_questions';
                }
            } else if (selectedMode === 'wordSearch') {
                // This click is for the FIRST step: getting the word list
                isWordListRequest = true; // Set flag
                payload.topic = document.getElementById('wsTopicInput').value.trim(); // Use specific ID
                payload.grade_level = document.getElementById('wsGradeLevelSelect').value; // Use specific ID
                // Optional: Add num_words input if desired
                // payload.num_words = parseInt(document.getElementById('wsNumWords').value, 10) || 15;
                if (!payload.topic) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please enter topic.</p>'; }
                else { fetchUrl = '/generate_word_list'; } // Target the word list route
            }
            // --- End Word Search Mode ---
            else {
                itemPreviewArea.innerHTML = '<p style="color: red;">Invalid mode selected (JS Error).</p>';
                isValid = false;
            }

            // --- Exit if validation failed ---
            if (!isValid) {
                 if (!itemPreviewArea.innerHTML.includes('color: red')) { itemPreviewArea.innerHTML = '<p style="color: red;">Input error.</p>'; }
                 generateButton.disabled = false; // Re-enable button
                 // Ensure other buttons remain disabled
                 toggleEditButton.disabled = true; saveButton.disabled = true; addToSheetButton.disabled = true;
                 return;
            }

            // --- Handle Direct Text (no fetch needed) ---
            if (useDirectText) {
                 console.log("Using direct text input.");
                 const directTextContent = tbDirectInput.value;
                 itemPreviewArea.innerHTML = parseAndStructureTextBlock(directTextContent);
                 toggleEditButton.disabled = false; saveButton.disabled = false; addToSheetButton.disabled = false; // Enable actions
                 generateButton.disabled = false; // Re-enable generate button
                 return; // Exit listener
            }

            // --- Make API Call (if fetchUrl is set) ---
            if (fetchUrl) {
                 try {
                    console.log(`Fetching ${fetchUrl} with final payload:`, payload);
                    const response = await fetch(fetchUrl, {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) });
                    const data = await response.json();
                    console.log('Raw data received from backend:', data);
                    if (selectedMode === 'textBlock') {
                        console.log("===> TextBlock SPECIFIC CHECK:");
                        console.log("   data.text_block_content exists:", data.hasOwnProperty('text_block_content'));
                        console.log("   Value of data.text_block_content:", data.text_block_content ? data.text_block_content.substring(0,70) + "..." : data.text_block_content);
                        if (data.text_block_content) {
                             console.log("   data.text_block_content is TRUTHY - the if block SHOULD run.");
                        } else {
                             console.log("   data.text_block_content is FALSY - the if block WILL NOT run.");
                        }
                    }
                    if (!response.ok) { throw new Error(data.message || `HTTP error! status: ${response.status}`); }

                    if (data.status === 'success') {
                        // --- Check if this was the Word List request ---
                        if (isWordListRequest && data.word_list_text) {
                             console.log("Received word list text.");
                             itemPreviewArea.innerHTML = '<p><i>Edit word list below and generate grid...</i></p>'; // Clear preview
                             displayWordListEditor(data.word_list_text); // Call new function to update UI
                             generateButton.disabled = true; // Keep main button disabled until grid generated or mode changed
                             // Do NOT enable save/edit/add buttons here
                             toggleEditButton.disabled = true; saveButton.disabled = true; addToSheetButton.disabled = true;
                        }
                        // --- Handle standard item generation ---
                        else {
                            let rawContent = ''; let outputHtml = '';
                            // Select parser based on mode/key (keep existing logic)
                            if (selectedMode === 'gapFill' && data.worksheet_content) { rawContent = data.worksheet_content; outputHtml = parseAndStructureGapFill(rawContent);
                                itemPreviewArea.innerHTML = outputHtml;
                                toggleEditButton.disabled = false;
                                saveButton.disabled = false;
                                addToSheetButton.disabled = false; 
                            }
                            else if (selectedMode === 'pastedText' && data.pasted_comprehension_content) { rawContent = data.pasted_comprehension_content; outputHtml = parseAndStructurePastedComprehension(rawContent);
                                itemPreviewArea.innerHTML = outputHtml;
                                toggleEditButton.disabled = false;
                                saveButton.disabled = false;
                                addToSheetButton.disabled = false; }
                            
                            else if (selectedMode === 'mcq' && data.mcq_content) { rawContent = data.mcq_content; outputHtml = parseAndStructureMCQ(rawContent);
                            console.log("MCQ Block: Setting innerHTML and enabling buttons."); // Optional log
                            itemPreviewArea.innerHTML = outputHtml;
                            toggleEditButton.disabled = false;
                            saveButton.disabled = false;
                            addToSheetButton.disabled = false; }
                            else if (selectedMode === 'trueFalse' && data.true_false_content) { rawContent = data.true_false_content; outputHtml = parseAndStructureTrueFalse(rawContent);
                                itemPreviewArea.innerHTML = outputHtml;
                                toggleEditButton.disabled = false;
                                saveButton.disabled = false;
                                addToSheetButton.disabled = false; }
                            
                            else if (selectedMode === 'shortAnswer' && data.short_answer_content) { rawContent = data.short_answer_content; outputHtml = parseAndStructureShortAnswer(rawContent);
                                itemPreviewArea.innerHTML = outputHtml;
                                toggleEditButton.disabled = false;
                                saveButton.disabled = false;
                                addToSheetButton.disabled = false; }
                            
                            else if (selectedMode === 'similarQ' && data.similar_questions_content) { rawContent = data.similar_questions_content; outputHtml = parseAndStructureSimilarQuestions(rawContent);
                                itemPreviewArea.innerHTML = outputHtml;
                                toggleEditButton.disabled = false;
                                saveButton.disabled = false;
                                addToSheetButton.disabled = false;
                             }
                            else if (selectedMode === 'similarWrittenQ' && data.data) { // Check for the nested 'data' key
                                console.log("SWQ Block: Entered.");
                                const resultData = data.data;
                                console.log("SWQ Block: Got resultData:", resultData);
                                console.log("Received Similar Written Q data:", resultData);
                                let outputHtml = '<div class="worksheet-section" data-item-type="similar-written-q">'; // Add item type for saving later?
                                console.log("SWQ Block: Initialized outputHtml.");
                                // Store raw data on the preview area itself for saving
                                try {
                                    itemPreviewArea.dataset.rawSwqData = JSON.stringify(resultData);
                                    console.log("SWQ Block: Set rawSwqData dataset.");
                                } catch (e) { console.error("SWQ Block: Error setting dataset:", e); }
                                outputHtml += `<h3>Skills Tested</h3><p>${resultData.skills_identified || 'Not specified'}</p>`;
                                outputHtml += '<h3>Generated Questions</h3>';
                                if (resultData.similar_questions && resultData.similar_questions.length > 0) {
                                    console.log("SWQ Block: Has similar_questions array.");
                                    outputHtml += '<ol>';
                                        resultData.similar_questions.forEach((q, index) => {
                                        console.log(`SWQ Block: Processing question index ${index}`);
                                        // Basic sanitization - replace potential HTML tags just in case
                                        const sanitizedQ = q.replace(/</g, "<").replace(/>/g, ">");
                                        outputHtml += `<li style="margin-bottom: 0.8em;">${sanitizedQ}</li>`; // Add list item style
                                    });
                                    outputHtml += '</ol>';
                                    console.log("SWQ Block: Finished questions loop.")
                                } else {
                                    outputHtml += '<p>No similar questions generated.</p>';
                                }
                                outputHtml += '</div>';
                                outputHtml = outputHtml; // Assign to the variable used below (or directly set innerHTML)
                                rawContent = "N/A"; // No single raw text blob for this type
                                console.log("SWQ Block: FINAL outputHtml to be set:\n", outputHtml);
                                console.log("SWQ Block: Attempting to set innerHTML...");
                                itemPreviewArea.innerHTML = outputHtml; // <<< SET THE PREVIEW CONTENT HERE
                                console.log("SWQ Block: Successfully SET innerHTML.");

                                // Enable save/add buttons specifically for this type
                                console.log("SWQ Block: Attempting to enable buttons...");
                                toggleEditButton.disabled = false; // Allow editing if needed
                                saveButton.disabled = false;    // Use the main save button
                                addToSheetButton.disabled = false;// Use the main add button
                                console.log("SWQ Block: Successfully enabled buttons.");
                            }


                            else if (selectedMode === 'textBlock' && data.text_block_content) { 
                                rawContent = data.text_block_content; 
                                console.log("===> TextBlock AI: Raw content received:", rawContent); 
                                outputHtml = parseAndStructureTextBlock(rawContent); 
                                console.log("===> TextBlock AI: Parsed HTML:", outputHtml.substring(0, 500));
                                try {
                                    console.log("===> TextBlock AI: Attempting to update tbDirectInput and itemPreviewArea...");

                                    if (!tbDirectInput) {
                                        console.error("ERROR: tbDirectInput element is null! Check getElementById('tbDirectInput').");
                                    } else {
                                        tbDirectInput.value = rawContent; // Populate textarea - KEEP THIS LINE
                                        console.log("===> TextBlock AI: tbDirectInput.value set.");
                                    }

                                    if (!itemPreviewArea) {
                                        console.error("ERROR: itemPreviewArea element is null! Check getElementById('itemPreviewArea').");
                                    } else {
                                        itemPreviewArea.innerHTML = outputHtml; // Set preview - KEEP THIS LINE
                                        console.log("===> TextBlock AI: itemPreviewArea.innerHTML set.");
                                    }

                                    // Re-enable buttons
                                    toggleEditButton.disabled = false;    // KEEP
                                    saveButton.disabled = false;       // KEEP
                                    addToSheetButton.disabled = false; // KEEP
                                    generateButton.disabled = false;   // KEEP
                                    console.log("===> TextBlock AI: Buttons re-enabled.");

                                } catch (uiUpdateError) {
                                    console.error("===> TextBlock AI: ERROR during UI update:", uiUpdateError);
                                    // Still try to re-enable generate button so user isn't stuck, even on UI error
                                    generateButton.disabled = false;
                                }
                                tbDirectInput.value = rawContent; }
                            else { console.error("Success status but missing expected content key.", data); throw new Error('Generation succeeded but expected content key was not found.'); }
                    
                        }
                    } else { // data.status !== 'success'
                        console.error("Backend returned status !== 'success'", data);
                        throw new Error(data.message || 'Generation failed on the server.');
                    }
                 } catch (error) { // Catch fetch or processing errors
                    console.error('Error during generation fetch/processing:', error);
                    itemPreviewArea.innerHTML = `<p style="color: red;">Error: ${error.message}. Check console.</p>`;
                    generateButton.disabled = false; // Re-enable button on error
                    console.log("===> TextBlock AI: Buttons re-enabled.");
                    generateButton.textContent = (selectedMode === 'wordSearch') ? 'Get Word List' : 'Generate New'; // Reset text appropriately
                    // Keep other buttons disabled
                    toggleEditButton.disabled = true; saveButton.disabled = true; addToSheetButton.disabled = true;
                 }
            } else { // Should not happen if validation is correct
                console.error("LOGIC ERROR: No fetch URL set for mode:", selectedMode);
                itemPreviewArea.innerHTML = `<p style="color: red;">Internal JS error for mode '${selectedMode}'.</p>`;
                generateButton.disabled = false;
            }
        });
// --- START: Keywords & Definitions Event Listeners ---

// --- Event Listener for Generate Button ---
generateKeywordsBtn.addEventListener('click', async () => {
    const topic = keywordsTopicInput.value.trim();
    const gradeLevel = keywordsGradeLevelSelect.value;
    const numKeywords = keywordsNumInput.value; // Let backend handle default/validation

    if (!topic || !gradeLevel) {
        keywordsStatus.textContent = 'Please enter both Topic and Grade Level.';
        keywordsStatus.className = 'status-message error';
        return;
    }

    keywordsStatus.textContent = 'Generating keywords...';
    keywordsStatus.className = 'status-message loading';
    keywordsPreviewArea.style.display = 'none'; // Hide previous results
    currentKeywordData = []; // Clear old data
    currentKeywordsItemId = null; // Reset item ID tracking
    keywordsItemIdDisplay.textContent = '';

    try {
        const response = await fetch('/generate_keywords_definitions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ topic, grade_level: gradeLevel, num_keywords: numKeywords }),
        });

        const result = await response.json();

        if (response.ok && result.status === 'success') {
            keywordsStatus.textContent = 'Keywords generated successfully.';
            keywordsStatus.className = 'status-message success';
            currentKeywordData = result.keywords;
            keywordsPreviewArea.style.display = 'block'; // Show preview area
            // Display the default activity (Reference Table)
            document.getElementById('activityRefTable').checked = true; // Ensure default is selected
            displayKeywordActivity();
        } else {
            throw new Error(result.message || 'Failed to generate keywords.');
        }
    } catch (error) {
        console.error("Error generating keywords:", error);
        keywordsStatus.textContent = `Error: ${error.message}`;
        keywordsStatus.className = 'status-message error';
        keywordsPreviewArea.style.display = 'none'; // Keep hidden on error
    }
});

// --- Event Listener for Activity Selector Radio Buttons ---
activitySelector.addEventListener('change', (event) => {
    if (event.target.type === 'radio' && event.target.name === 'keywordActivity') {
        displayKeywordActivity(); // Re-render the table with the new selection
    }
});

// --- Event Listener for "Add to Worksheet" Button ---
addKeywordsToWorksheetBtn.addEventListener('click', () => {
    if (currentItemIdInPreview === null) {
        console.log("addKeywordsToWorksheetBtn: Check FAILED - item not saved yet."); // Add log
        alert("Please save the current Keywords/Definitions item to the library before adding it to the worksheet.");
        return; // Stop the function here
    }
    console.log(`addKeywordsToWorksheetBtn: Check PASSED - Item ID is ${currentItemIdInPreview}.`);
    // Clone the current activity output to add to the worksheet
    const activityContent = activityOutput.innerHTML.trim(); // Get the generated table HTML
    const activityType = activityOutput.dataset.activityType || 'keywords-reference'; // Get stored type
    const keywordsJson = activityOutput.dataset.keywords || '[]'; // Get stored raw data

    if (!activityContent) {
        alert("No activity content to add.");
        return;
    }

    const worksheetItem = document.createElement('div');
    worksheetItem.className = 'worksheet-item';
    // Set a specific data-item-type based on the activity shown
    worksheetItem.dataset.itemType = `keywords-${activityType}`; // e.g., keywords-matching
    // Store the raw data if needed for export later
    worksheetItem.dataset.keywordsData = keywordsJson;

    // Add item ID if it was loaded from library
    if (currentItemIdInPreview) {
        worksheetItem.dataset.generatedItemId = currentItemIdInPreview;
        console.log(`Adding item from library with ID: ${currentItemIdInPreview}`);
    }

    // Embed the actual HTML content inside a container
    const contentWrapper = document.createElement('div');
    contentWrapper.className = 'item-content-wrapper'; // For potential styling
    contentWrapper.innerHTML = activityContent; // Add the table HTML
    worksheetItem.appendChild(contentWrapper);

    // Add controls (Move Up/Down, Remove) - Reuse your existing functions/logic
    addWorksheetItemControls(worksheetItem); // Assuming you have this function

    // Append to the worksheet assembly area
    const placeholder = worksheetAssemblyArea.querySelector('p');
    if (placeholder && placeholder.textContent.includes('Items added to the worksheet')) {
     worksheetAssemblyArea.innerHTML = ''; // Clear the placeholder
    }
    console.log("Placeholder removed from worksheet assembly area.");
    document.getElementById('worksheetAssemblyArea').appendChild(worksheetItem);

     // Add visual separation
    document.getElementById('worksheetAssemblyArea').appendChild(document.createElement('hr'));

    // updateWorksheetItemNumbers(); // Assuming you have this function
});

// --- Event Listener for "Save Item" Button ---
saveKeywordsItemBtn.addEventListener('click', async () => {
    const activityContentHtml = activityOutput.innerHTML.trim();
    const activityType = activityOutput.dataset.activityType || 'reference';
    const itemType = `keywords-${activityType}`; // e.g., keywords-matching
    const keywordsJson = activityOutput.dataset.keywords || '[]'; // Get raw data

    if (!activityContentHtml || !currentKeywordData || currentKeywordData.length === 0) {
        alert("No content generated to save.");
        return;
    }

    // Try to get source/grade from inputs
    const sourceTopic = keywordsTopicInput.value.trim() || "Unknown Topic";
    const gradeLevel = keywordsGradeLevelSelect.value; // Read value from the select element
// You might still want a check here if a default/unknown option is possible
if (!gradeLevel || gradeLevel === "Not Specified") { // Example check
     alert("Please select a valid grade level before saving.");
     isValidMeta = false; // Assuming isValidMeta is used for validation check
     // return; // Or return early
}

    keywordsStatus.textContent = 'Saving item...';
    keywordsStatus.className = 'status-message loading';

    try {
        const response = await fetch('/save_item', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                item_type: itemType,
                content_html: activityContentHtml,
                source_topic: sourceTopic,
                grade_level: gradeLevel,
                item_data_json: keywordsJson,
                // Optionally send the raw data if your backend saves it
                // item_data_json: keywordsJson
            }),
        });
        const result = await response.json();

        if (response.ok && result.item_id) {
            keywordsStatus.textContent = `Item saved successfully (ID: ${result.item_id})`;
            keywordsStatus.className = 'status-message success';
            currentItemIdInPreview = result.item_id; // Track the saved ID
            console.log(`Keywords Save: Updated GLOBAL currentItemIdInPreview to ${currentItemIdInPreview}`);
            keywordsItemIdDisplay.textContent = `Saved as ID: ${result.item_id}`;
             // Refresh library list if you have one displayed
             if (typeof loadLibraryItems === 'function') {
                loadLibraryItems();
            }
        } else {
            throw new Error(result.message || 'Failed to save item.');
        }
    } catch (error) {
        console.error("Error saving item:", error);
        keywordsStatus.textContent = `Error: ${error.message}`;
        keywordsStatus.className = 'status-message error';
        currentItemIdInPreview = null; // Reset on failure
         keywordsItemIdDisplay.textContent = '';
    }
});
// **** ADD createLabelBox Function ****
function createLabelBox(x, y, w, h) {
    console.log(`--- createLabelBox called with x=${x}, y=${y}, w=${w}, h=${h} ---`);
    const boxId = `labelbox-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    const boxDiv = document.createElement('div');
    boxDiv.id = boxId;
    boxDiv.className = 'label-box'; // Apply CSS styling
    boxDiv.style.left = `${x}px`;
    boxDiv.style.top = `${y}px`;
    boxDiv.style.width = `${w}px`;
    boxDiv.style.height = `${h}px`;

    const dragHandle = document.createElement('div');
    dragHandle.className = 'label-box-handle';
    dragHandle.innerHTML = ''; // Optional: Hamburger icon or dots for visual cue
    boxDiv.appendChild(dragHandle);

    const contentArea = document.createElement('div');
    contentArea.className = 'label-box-content';
    const contentSpan = document.createElement('span');
    contentSpan.textContent = '';
    contentArea.appendChild(contentSpan);
    boxDiv.appendChild(contentArea); 

    ilPreviewContainer.appendChild(boxDiv);
    console.log("Box div (with handle and content) appended to ilPreviewContainer.");

    // Create the data object for our state array
    const boxData = {
        id: boxId,
        x: x,
        y: y,
        w: w,
        h: h,
        type: 'blank', // Default type
        text: '', // Store the number
        element: boxDiv, // Reference to the DOM element
        handleElement: dragHandle
    };
    labelBoxes.push(boxData);
    console.log("Added box to labelBoxes array:", boxData);

    // --- Initialize Interact.js ---
    console.log(`Attempting to initialize Interact.js for ${boxId}`);
    try {
            // --- Initialize Draggable on the Handle ---
            interact(dragHandle)
                .draggable({
                    listeners: {
                        start (event) {
                            console.log(`Box ${boxId} drag START via handle`);
                            let mainBox = event.target.parentNode;
                            mainBox.setAttribute('data-initial-x', parseFloat(mainBox.style.left || 0));
                            mainBox.setAttribute('data-initial-y', parseFloat(mainBox.style.top || 0));
                            mainBox.classList.add('dragging-active');
                        },
                        move (event) {
                            let mainBox = event.target.parentNode;
                            let initialX = parseFloat(mainBox.getAttribute('data-initial-x') || 0);
                            let initialY = parseFloat(mainBox.getAttribute('data-initial-y') || 0);
                            let newX = initialX + (event.pageX - event.x0);
                            let newY = initialY + (event.pageY - event.y0);
                            mainBox.style.transform = `translate(${newX - initialX}px, ${newY - initialY}px)`;
                        },
                        end (event) {
                            let mainBox = event.target.parentNode;
                            console.log(`Box ${mainBox.id} drag END via handle. PageX/Y: ${event.pageX.toFixed(1)},${event.pageY.toFixed(1)}. StartX0/Y0: ${event.x0.toFixed(1)},${event.y0.toFixed(1)}`);
                            const targetBoxData = labelBoxes.find(b => b.id === mainBox.id);

                            if (targetBoxData) {
                                const initialX = parseFloat(mainBox.getAttribute('data-initial-x'));
                                const initialY = parseFloat(mainBox.getAttribute('data-initial-y'));

                                if (isNaN(initialX) || isNaN(initialY)) {
                                    console.error(`Could not retrieve valid initial-x/y for box ${mainBox.id} during drag. Position might be inaccurate.`);
                                    // Attempt fallback using current data - less accurate but better than nothing
                                    // initialX = targetBoxData.x;
                                    // initialY = targetBoxData.y;
                                }

                                let finalX = initialX + (event.pageX - event.x0);
                                let finalY = initialY + (event.pageY - event.y0);

                                console.log(`  Draggable End - Initial X/Y: ${initialX?.toFixed(1)},${initialY?.toFixed(1)}`);
                                console.log(`  Draggable End - Delta X/Y: ${(event.pageX - event.x0).toFixed(1)},${(event.pageY - event.y0).toFixed(1)}`);
                                console.log(`  Draggable End - Calculated Final X/Y: ${finalX.toFixed(1)},${finalY.toFixed(1)}`);

                                targetBoxData.x = finalX;
                                targetBoxData.y = finalY;

                                mainBox.style.left = `${targetBoxData.x}px`;
                                mainBox.style.top = `${targetBoxData.y}px`;
                                mainBox.style.transform = ''; // Reset transform

                                mainBox.removeAttribute('data-initial-x');
                                mainBox.removeAttribute('data-initial-y');
                                mainBox.classList.remove('dragging-active');

                                console.log(`  Final drag pos stored in labelBoxes for box ${mainBox.id}: (${targetBoxData.x.toFixed(1)}, ${targetBoxData.y.toFixed(1)})`);
                            } else {
                                console.error(`Could not find targetBoxData for box ID: ${mainBox.id} in drag end event.`);
                            }
                        }
                    },
                    inertia: true,
                    modifiers: [
                        interact.modifiers.restrictRect({
                            restriction: 'parent',
                            elementRect: { top: 0, left: 0, bottom: 1, right: 1 }, // Use main box rect for restriction
                            endOnly: false
                        })
                    ],
                    cursorChecker: () => 'grab'
                }); // End draggable config for handle

            // --- Initialize Resizable and Tap on the Box itself ---
            interact(boxDiv) // Separate interact() call for the main box
                .resizable({
                    edges: { left: true, right: true, top: true, bottom: true },
                    listeners: {
                        start (event) {
                            console.log(`Box ${boxId} resize START`);
                            let target = event.target;
                            target.setAttribute('data-start-x', parseFloat(target.style.left || 0));
                            target.setAttribute('data-start-y', parseFloat(target.style.top || 0));
                        },
                        move (event) {
                            let target = event.target;
                            let initialX = parseFloat(target.getAttribute('data-start-x') || 0);
                            let initialY = parseFloat(target.getAttribute('data-start-y') || 0);
                            target.style.width = event.rect.width + 'px';
                            target.style.height = event.rect.height + 'px';
                            let translateX = (event.deltaRect ? event.deltaRect.left : 0);
                            let translateY = (event.deltaRect ? event.deltaRect.top : 0);
                            target.style.transform = 'translate(' + translateX + 'px,' + translateY + 'px)';
                        },
                        end (event) {
                            console.log(`Box ${boxId} resize END`);
                            const targetBoxData = labelBoxes.find(b => b.id === event.target.id); // Use event.target.id
                            let target = event.target;
                            if (targetBoxData) {
                                targetBoxData.w = event.rect.width;
                                targetBoxData.h = event.rect.height;
                                const initialX = parseFloat(target.getAttribute('data-start-x') || targetBoxData.x);
                                const initialY = parseFloat(target.getAttribute('data-start-y') || targetBoxData.y);
                                targetBoxData.x = initialX + (event.deltaRect ? event.deltaRect.left : 0);
                                targetBoxData.y = initialY + (event.deltaRect ? event.deltaRect.top : 0);
                                target.style.width = `${targetBoxData.w}px`;
                                target.style.height = `${targetBoxData.h}px`;
                                target.style.left = `${targetBoxData.x}px`;
                                target.style.top = `${targetBoxData.y}px`;
                                target.style.transform = '';
                                target.removeAttribute('data-start-x');
                                target.removeAttribute('data-start-y');
                                console.log(`  Final size stored: ${targetBoxData.w.toFixed(1)}x${targetBoxData.h.toFixed(1)}, Final pos: (${targetBoxData.x.toFixed(1)}, ${targetBoxData.y.toFixed(1)})`);
                            } else {
                                 console.error(`Could not find targetBoxData for box ID: ${event.target.id} in resize end event.`);
                            }
                        }
                    },
                    inertia: false,
                    modifiers: [
                        interact.modifiers.restrictRect({
                            restriction: 'parent',
                            endOnly: false
                        }),
                        interact.modifiers.restrictSize({
                            min: { width: 30, height: 20 }
                        })
                    ]
                }) // End resizable config for box
                .on('tap', function(event) { // Use an anonymous function to explicitly pass the correct element
                    console.log("Interact.js 'tap' event fired on boxDiv. Event object:", event);
                    // event.currentTarget should be boxDiv
                    handleBoxSelect(event.currentTarget); 
                }); // Chain tap listener onto box interaction

            console.log(`Interact.js drag/resize/tap initialized for ${boxId}`);

        } catch(interactErr) { // Catch errors from EITHER initialization
             console.error(`*** Error initializing Interact.js for ${boxId}:`, interactErr);
        }
        //handleBoxSelect(boxId);
        return boxData;
}
// Helper function to get selected box data
function getSelectedBoxData() {
    if (!selectedBoxId) return null;
    return labelBoxes.find(box => box.id === selectedBoxId);
}

// **** ADD handleBoxSelect Function (can be called by tap or click) ****
function handleBoxSelect(elementOrId) {
    console.log("--- handleBoxSelect CALLED with:", elementOrId); 
    let targetElement = null;
    let boxIdToSelect = null;

    if (typeof elementOrId === 'string') { // Called directly with an ID string
        boxIdToSelect = elementOrId;
        const boxData = labelBoxes.find(b => b.id === boxIdToSelect);
        if (boxData) {
            targetElement = boxData.element;
        } else {
            console.warn("handleBoxSelect: ID string provided, but no box found for ID:", boxIdToSelect);
            return;
        }
        console.log("handleBoxSelect: Called with ID string. Target element ID:", targetElement ? targetElement.id : 'Not Found');
    } else if (elementOrId instanceof Element && elementOrId.classList.contains('label-box')) { // Called with a DOM element
        targetElement = elementOrId;
        boxIdToSelect = targetElement.id;
        console.log("handleBoxSelect: Called with DOM element. Target element ID:", boxIdToSelect);
    } else {
        console.warn("handleBoxSelect: Called with invalid argument type or non-label-box element:", elementOrId);
        return; // Exit if we don't have a valid target
    }

    if (!targetElement || !boxIdToSelect) { // Should be caught by above, but double check
        console.error("handleBoxSelect: Could not determine targetElement or boxIdToSelect. Aborting.");
        return;
    }

    console.log(`Box selected: ${boxIdToSelect}`);

    // Remove selection from previously selected box
    if (selectedBoxId && selectedBoxId !== boxIdToSelect) {
        const previousSelectedData = labelBoxes.find(box => box.id === selectedBoxId);
        if (previousSelectedData && previousSelectedData.element) {
            previousSelectedData.element.classList.remove('selected');
        }
    }

    targetElement.classList.add('selected');
    selectedBoxId = boxIdToSelect;

    ilBoxControls.style.display = 'block';
    console.log("handleBoxSelect: ilBoxControls.style.display SET TO 'block'. Current display style:", getComputedStyle(ilBoxControls).display);
    
    const selectedData = getSelectedBoxData();
    if (selectedData) {
        boxContentTypeNumberRadio.checked = (selectedData.type === 'number');
        boxContentTypeBlankRadio.checked = (selectedData.type === 'blank'); // Should be true for new blank boxes
        boxContentTypeCustomRadio.checked = (selectedData.type === 'custom');

        boxCustomTextInput.value = (selectedData.type === 'custom' || selectedData.type === 'number') ? selectedData.text : ''; // Also show number if type is number
        boxCustomTextInput.disabled = (selectedData.type !== 'custom');
        
        // Ensure the correct radio is selected for default blank boxes
        if (selectedData.type === 'blank') {
             boxContentTypeBlankRadio.checked = true;
        } else if (selectedData.type === 'number') {
             boxContentTypeNumberRadio.checked = true;
        }


        console.log("handleBoxSelect: Controls populated for box type:", selectedData.type);
    } else {
        console.error("handleBoxSelect: Selected data not found for ID:", selectedBoxId, "- this shouldn't happen.");
        ilBoxControls.style.display = 'none';
        selectedBoxId = null;
    }
}
// **** END handleBoxSelect Function ****
// **** ADD Box Controls Listener ****
ilBoxControls.addEventListener('input', (event) => { // Use 'input' for text, 'change' for radio
    const selectedData = getSelectedBoxData();
    if (!selectedData) return;

    const target = event.target;

    // Handle Radio Button Change
    if (target.type === 'radio' && target.name === 'boxContentType') {
        selectedData.type = target.value;
        console.log(`Box ${selectedData.id} type changed to: ${selectedData.type}`);

        if (selectedData.type === 'number') {
            selectedData.text = nextBoxNumber; // Assign the current next available number
            nextBoxNumber++;                   // Increment for the *next* box that gets auto-numbered
            boxCustomTextInput.value = '';     // Clear custom text input
            boxCustomTextInput.disabled = true;
        
        } else { // Custom
            selectedData.text = boxCustomTextInput.value; // Use current text input value
            boxCustomTextInput.disabled = false;
            boxCustomTextInput.focus(); // Focus the input
        }
    }
    // Handle Custom Text Input Change
    else if (target.id === 'boxCustomTextInput') {
         if (selectedData.type === 'custom') { // Only update if type is custom
             selectedData.text = target.value;
         }
    }

    // Update the visual content of the box
    const contentSpan = selectedData.element.querySelector('span');
    if (contentSpan) {
        contentSpan.textContent = (selectedData.type === 'blank') ? '' : selectedData.text;
    }

    console.log(`Box ${selectedData.id} data updated:`, selectedData);
});
// **** END Box Controls Listener ****
  // **** ADD Delete Selected Box Listener ****
ilDeleteSelectedBoxBtn.addEventListener('click', () => {
    const selectedData = getSelectedBoxData();
    if (!selectedData) {
        alert("No box selected to delete.");
        return;
    }

    if (confirm(`Are you sure you want to delete box ${selectedData.id}?`)) {
        // Remove from DOM
        selectedData.element.remove();

        // Remove from state array
        const indexToRemove = labelBoxes.findIndex(box => box.id === selectedBoxId);
        if (indexToRemove > -1) {
            labelBoxes.splice(indexToRemove, 1);
            console.log(`Removed box ${selectedBoxId} from labelBoxes array.`);
        }

        // Reset selection state
        selectedBoxId = null;
        ilBoxControls.style.display = 'none'; // Hide controls
        // Optionally re-number boxes if type 'number' was deleted? More complex.

        imageLabelStatus.textContent = "Box deleted.";
    }
});
// **** END Delete Selected Box Listener ****      
 // **** Listener for Save Image Label Item Button ****
     // **** Listener for Save Image Label Item Button ****
     saveImageLabelItemBtn.addEventListener('click', async () => {
        imageLabelStatus.textContent = 'Saving...';
        imageLabelStatus.style.color = 'grey';
        saveImageLabelItemBtn.disabled = true;

        if (!baseImageFilename) {
            alert("Error: No base image has been uploaded or loaded.");
            imageLabelStatus.textContent = 'Save failed: No base image.';
            imageLabelStatus.style.color = 'red';
            saveImageLabelItemBtn.disabled = false;
            return;
        }

        // <===== ADDED: Get natural dimensions of the preview image =====>
            const editorRenderedWidth = ilPreviewImage.offsetWidth;  // <--- USE RENDERED SIZE
            const editorRenderedHeight = ilPreviewImage.offsetHeight; // <--- USE RENDERED SIZE
            const editorNaturalWidth = ilPreviewImage.naturalWidth;   // Still store natural for reference
            const editorNaturalHeight = ilPreviewImage.naturalHeight;
            if (!editorRenderedWidth || !editorRenderedHeight || !editorNaturalWidth || !editorNaturalHeight) {
                alert("Error: Cannot determine critical editor image dimensions for saving.");
                imageLabelStatus.textContent = 'Save failed: Editor image dimensions unknown.';
                imageLabelStatus.style.color = 'red';
                saveImageLabelItemBtn.disabled = false;
                return;
            }
        // <===== END: Get natural dimensions =====>

        if (labelBoxes.length === 0) {
             console.log("Saving image item with no boxes. This is allowed.");
        }

        // <===== CHANGED: Create data to save with percentages and specific keys =====>
        const boxDataToSave = labelBoxes.map(box => ({
        x_pct: (box.x / editorRenderedWidth) * 100,   // <--- CHANGE TO RENDERED
        y_pct: (box.y / editorRenderedHeight) * 100,  // <--- CHANGE TO RENDERED
        width_pct: (box.w / editorRenderedWidth) * 100, // <--- CHANGE TO RENDERED
        height_pct: (box.h / editorRenderedHeight) * 100,// <--- CHANGE TO RENDERED
        type: box.type,
        text: box.text
        }));

        // <===== CHANGED: item_data_json now stores percentages and natural dimensions =====>
        const item_data_json_string = JSON.stringify({
            baseImage: baseImageFilename,
            boxes_pct: boxDataToSave,         // Key changed to 'boxes_pct'
            refEditorWidth: editorRenderedWidth,
            refEditorHeight: editorRenderedHeight,
            naturalWidth: editorNaturalWidth,        // <===== USE editorNaturalWidth
            naturalHeight: editorNaturalHeight       // <===== USE editorNaturalHeight
        });

        // Simple HTML content placeholder (remains largely the same)
        const content_html_string = `<div class="image-label-placeholder" data-filename="${baseImageFilename}">
                                        <p><strong>Image Labelling Activity</strong></p>
                                        <p>Base Image: ${baseImageFilename}</p>
                                        <p>${boxDataToSave.length} label box(es).</p>
                                        <p><i>(Interactive view available in editor, static image generated for worksheet/export)</i></p>
                                     </div>`;

        const payload = {
            item_type: 'imageLabel',
            source_topic: `Image Label: ${baseImageFilename}`,
            grade_level: 'middle school', // Or get from a dedicated select if added
            content_html: content_html_string,
            item_data_json: item_data_json_string,
            existing_item_id: currentItemIdInPreview // For updating existing items
        };

        console.log("Saving Image Label Item Payload (with percentages):", payload);

        try {
            const response = await fetch('/save_item', {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify(payload)
             });
            const result = await response.json();

            if (!response.ok || result.status !== 'success' || !result.item_id) {
                throw new Error(result.message || 'Failed to save item or retrieve ID.');
            }

            currentItemIdInPreview = result.item_id; // Update the global ID
            imageLabelItemIdDisplay.textContent = `Saved as ID: ${currentItemIdInPreview}`;
            imageLabelStatus.textContent = `Item saved successfully (ID: ${currentItemIdInPreview})`;
            imageLabelStatus.style.color = 'green';
            console.log(`Image Label Item saved/updated. currentItemIdInPreview set to: ${currentItemIdInPreview}`);

            addImageLabelToWorksheetBtn.disabled = false; // Enable "Add to Worksheet" now that it's saved

            if (typeof loadLibraryItems === 'function') { loadLibraryItems(); }

        } catch (error) {
            console.error("Error saving image label item:", error);
            imageLabelStatus.textContent = `Save Error: ${error.message}`;
            imageLabelStatus.style.color = 'red';
            imageLabelItemIdDisplay.textContent = '';
            // Don't reset currentItemIdInPreview if save failed for an existing item update attempt
        } finally {
             saveImageLabelItemBtn.disabled = false; // Re-enable save button
        }
    });
    // **** END Listener for Save Image Label Item Button ****
        toggleEditButton.addEventListener('click', () => { /* ... Keep unchanged ... */
             isEditingEnabled = !isEditingEnabled; const contentElements = itemPreviewArea.querySelectorAll('.worksheet-section p, .worksheet-section li'); if (isEditingEnabled) { toggleEditButton.textContent = 'Disable Editing'; saveButton.disabled = true; contentElements.forEach(el => { el.contentEditable = true; el.classList.add('editable-content'); }); itemPreviewArea.style.border = '2px solid blue'; console.log("Editing enabled."); } else { toggleEditButton.textContent = 'Enable Editing'; saveButton.disabled = false; contentElements.forEach(el => { el.contentEditable = false; el.classList.remove('editable-content'); }); itemPreviewArea.style.border = '1px solid #ccc'; console.log("Editing disabled."); }
        });

        saveButton.addEventListener('click', async () => {
             // Check if editing is enabled
             if (isEditingEnabled) {
                 alert("Please disable editing before saving.");
                 return;
             }

            const selectedMode = document.querySelector('input[name="generatorMode"]:checked').value;
            // Declare metadata variables
            let item_type = selectedMode;
            let source_topic = null;
            let source_url = null; // Keep null for now unless a mode uses it
            let gradeLevel = null;
            let isValidMeta = true; // ** Declare isValidMeta **

            // Gather metadata based on the mode ACTIVE WHEN SAVING
            // Uses the values currently shown in the inputs for context
            if (selectedMode === 'gapFill') {
                source_topic = topicInput.value.trim();
                gradeLevel = gradeLevelSelect.value;
                if (!source_topic) { alert("Cannot save without topic context."); isValidMeta = false; }
            } else if (selectedMode === 'textBlock') {
                 source_topic = tbTopicInput.value.trim() || "User Provided Text"; // Use topic if available
                 gradeLevel = tbGradeLevelSelect.value;
            } else if (selectedMode === 'pastedText') {
                 source_topic = "Pasted Text Comprehension"; // Placeholder topic
                 gradeLevel = "middle school"; // Placeholder grade
                 source_url = null;
            } else if (selectedMode === 'mcq') {
                source_topic = mcqTopicInput.value.trim();
                gradeLevel = mcqGradeLevelSelect.value;
                item_type = selectedMode;
                if (!source_topic) { alert("Cannot save without topic context."); isValidMeta = false; }
            } else if (selectedMode === 'trueFalse') {
                 source_topic = tfTopicInput.value.trim();
                 gradeLevel = tfGradeLevelSelect.value;
                 if (!source_topic) { alert("Cannot save without topic context."); isValidMeta = false; }
            } else if (selectedMode === 'shortAnswer') {
                 source_topic = saTopicInput.value.trim();
                 gradeLevel = saGradeLevelSelect.value;
                 if (!source_topic) { alert("Cannot save without topic context."); isValidMeta = false; }
            } else if (selectedMode === 'similarQ') {
                 // Save the example question as the topic for now? Or first few words?
                 source_topic = sqExampleInput.value.substring(0, 50).trim() + "... (Similar Q)";
                 gradeLevel = sqGradeLevelSelect.value;
                 if (!sqExampleInput.value.trim()) { alert("Cannot save similar question without original example text."); isValidMeta = false; }
                 else if (selectedMode === 'similarWrittenQ') {
                    source_topic = swqExampleInput.value.substring(0, 75).trim() + "... (Similar Written Q)"; // Use example Q as topic base
                    gradeLevel = swqGradeLevelSelect.value;
                    item_type = selectedMode; // Use 'similarWrittenQ'
                    // Retrieve the raw data stored on the preview area
                    payload.item_data_json = itemPreviewArea.dataset.rawSwqData || null; // Add raw data to payload
                    if (!swqExampleInput.value.trim()) { alert("Cannot save without the original example question text."); isValidMeta = false; }
                    if (!payload.item_data_json) { console.warn("Could not retrieve raw SWQ data from preview area dataset for saving."); }
                }
            } else if (selectedMode === 'wordSearch') {
                // Get topic/grade from the specific word search inputs
                source_topic = document.getElementById('wsTopicInput').value.trim() || "Word Search";
                gradeLevel = document.getElementById('wsGradeLevelSelect').value;
                item_type = selectedMode; // Set item_type
                // Optional validation:
                // if (!document.getElementById('wsTopicInput').value.trim()) {
                //     alert("Word Search Topic is recommended for saving context.");
                //     // isValidMeta = false; // Optionally make it mandatory
                // }
            } else if (selectedMode === 'similarWrittenQ') {
                source_topic = swqExampleInput.value.substring(0, 75).trim() + "... (Similar Written Q)";
                gradeLevel = swqGradeLevelSelect.value;
                item_type = selectedMode; // Set item_type
                item_data_json_to_save = itemPreviewArea.dataset.rawSwqData || null;
                if (!swqExampleInput.value.trim()) {
                    alert("Cannot save without the original example question text.");
                    isValidMeta = false;
                }
                // Check for raw data (removed the console.warn from here, handled in payload creation)
                // if (!item_data_json_to_save) {
                //     console.warn("Could not retrieve raw SWQ data from preview area dataset for saving.");
                // }
                 // Ensure item_data_json is set correctly for payload later
                 // This variable 'item_data_json_to_save' will be used when creating the payload
            } else { // Handles any unknown mode (Should include keywords here eventually if needed)
                alert(`Unknown item type selected for saving: ${selectedMode}`);
                isValidMeta = false;
                item_type = 'unknown'; // Set a default unknown type
            }
            // --- END: Corrected Metadata Gathering Chain ---

            // --- Grade Level Check (This should now work correctly) ---
            if (!gradeLevel) { // Check if gradeLevel was successfully assigned above
                 alert("Could not determine Grade Level for saving. Please select a grade.");
                 isValidMeta = false;
            }

            // --- Payload Creation (Ensure item_data_json is handled) ---
            if (!isValidMeta) { return; } // Exit if metadata gathering failed

            const content_html = itemPreviewArea.innerHTML;
            // ... (content_html validation) ...

            const payload = {
                item_type: item_type, // Use the variable set above
                source_topic: source_topic,
                source_url: source_url, // Still likely null
                grade_level: gradeLevel,
                content_html: content_html,
                // Assign item_data_json based on mode AFTER checking isValidMeta
                item_data_json: (selectedMode === 'similarWrittenQ') ? item_data_json_to_save : (selectedMode === 'keywordsDefinitions') ? itemPreviewArea.dataset.keywords : null
                 // ^^^^ Added logic for keywords mode here too ^^^^
            };
            if (!gradeLevel) {
                 alert("Could not determine Grade Level for saving. Please select a grade.");
                 // Maybe try reading from a default select if others fail?
                 // gradeLevel = gradeLevelSelect.value; // Fallback? Risky.
                 isValidMeta = false;
            }

            if (!isValidMeta) { return; }

            if (!content_html || content_html.includes('click Generate') || content_html.includes('<div class="loading">')) {
                alert("Cannot save empty or placeholder content.");
                return;
            }
            // Exit if basic metadata validation failed
            if (!isValidMeta) { return; }


            // Ensure the item_data_json from the SWQ logic above overwrites the null if necessary
            if (selectedMode === 'similarWrittenQ' && itemPreviewArea.dataset.rawSwqData) {
                payload.item_data_json = itemPreviewArea.dataset.rawSwqData;
            };

            console.log("Saving payload:", payload);
            saveButton.disabled = true;
            saveButton.textContent = 'Saving...';

            // Make fetch call
            try {
                const response = await fetch('/save_item', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const result = await response.json();
                if (!response.ok || result.status !== 'success') { throw new Error(result.message || `HTTP error! status: ${response.status}`); }
                alert("Item saved successfully!");
                if (result.item_id) {
                    currentItemIdInPreview = result.item_id;
                    console.log('Item saved successfully! Stored ID:', currentItemIdInPreview);
                    alert(`Item saved successfully! ID: ${currentItemIdInPreview}`);
                } else {
                    // This case should ideally not happen if backend is correct
                    currentItemIdInPreview = null; // Ensure ID is null if not returned
                    console.warn('Item saved, but item_id was missing in the response:', result);
                    alert("Item saved, but failed to retrieve its ID.");
                }
                saveButton.textContent = 'Saved!'; // Indicate success
            } catch (error) {
                console.error("Error saving item:", error);
                alert(`Error saving item: ${error.message}`);
                saveButton.textContent = 'Save to Library'; // Reset text
                saveButton.disabled = false; // Re-enable on error
                currentItemIdInPreview = null;
            }
        }); // <-- End of saveButton listener
        // --- SAVE WORKSHEET LISTENER ---
        saveWorksheetButton.addEventListener('click', async () => {
        const worksheetTitle = worksheetTitleInput.value.trim() || "Untitled Worksheet"; // Get title or use default
        const itemsInWorksheet = worksheetAssemblyArea.querySelectorAll('.worksheet-item'); // Get all item divs

        if (itemsInWorksheet.length === 0) {
            alert("Cannot save an empty worksheet. Please add items first.");
            return;
        }

        // --- Extract Ordered Item IDs ---
        // We need to have stored the original GeneratedItem ID on each worksheet item div when it was added
        const orderedItemIds = [];
        itemsInWorksheet.forEach(itemDiv => {
            const itemId = itemDiv.dataset.generatedItemId; // ** We need to ADD this data attribute later **
            if (itemId) {
                orderedItemIds.push(itemId);
            } else {
                console.warn("Found a worksheet item without a generatedItemId dataset.", itemDiv);
                // Optionally alert the user or skip? For now, we skip.
            }
        });

        if (orderedItemIds.length === 0) {
             alert("Could not find item IDs to save. Ensure items were added correctly.");
             return;
        }

        // --- Prepare Payload ---
        const payload = {
            title: worksheetTitle,
            item_ids: orderedItemIds // Send the array of IDs in order
        };
        console.log("Saving Worksheet Payload:", payload);

        // --- Send to Backend ---
        saveWorksheetButton.disabled = true;
        saveWorksheetButton.textContent = 'Saving...';
        try {
            const response = await fetch('/save_worksheet', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();
            if (!response.ok || result.status !== 'success') {
                throw new Error(result.message || `HTTP error! status: ${response.status}`);
            }
            alert(`Worksheet '${worksheetTitle}' saved successfully! (ID: ${result.worksheet_id})`);
            worksheetTitleInput.value = ''; // Clear title input maybe?
            saveWorksheetButton.textContent = 'Worksheet Saved';
            // Optionally reload the worksheet list?
            // loadWorksheetsButton.click(); // Trigger loading the list again

        } catch (error) {
            console.error("Error saving worksheet:", error);
            alert(`Error saving worksheet: ${error.message}`);
            saveWorksheetButton.textContent = 'Save This Worksheet';
            saveWorksheetButton.disabled = false; // Re-enable on error
        } finally {
             // Decide if button should stay disabled after successful save or re-enable
             // saveWorksheetButton.disabled = false;
        }
    });
    // --- END OF SAVE WORKSHEET LISTENER ---
    // --- LOAD WORKSHEETS LIST LISTENER ---
    loadWorksheetsButton.addEventListener('click', async () => {
        savedWorksheetsList.innerHTML = '<div class="loading">Loading worksheet list...</div>';
        loadWorksheetsButton.disabled = true;
        try {
            const response = await fetch('/list_worksheets');
            const data = await response.json();
            if (!response.ok || data.status !== 'success') {
                throw new Error(data.message || `HTTP error! status: ${response.status}`);
            }

            if (data.worksheets && data.worksheets.length > 0) {
                savedWorksheetsList.innerHTML = ''; // Clear
                const list = document.createElement('ul');
                list.style.listStyle = 'none'; list.style.padding = '0';
                data.worksheets.forEach(ws => {
                    const listItem = document.createElement('li');
                    listItem.style.borderBottom = '1px dashed #eee';
                    listItem.style.marginBottom = '10px';
                    listItem.style.paddingBottom = '10px';
                    listItem.innerHTML = `
                        <strong>${ws.title}</strong> (ID: ${ws.id})<br>
                        <small>Last Modified: ${new Date(ws.last_modified_date).toLocaleString()}</small>
                        <button data-worksheet-id="${ws.id}" class="load-worksheet-button" style="margin-left: 15px; padding: 2px 8px; font-size: 0.8em; background-color:#ffc107; color:black;">Load This Worksheet</button>
                        <button data-worksheet-id="${ws.id}" class="export-docx-button" style="margin-left: 5px; padding: 2px 8px; font-size: 0.8em; background-color:#007bff; color:white;">Export DOCX</button>
                        <!-- Add Delete Worksheet button later -->
                    `;
                    list.appendChild(listItem);
                });
                savedWorksheetsList.appendChild(list);
            } else {
                savedWorksheetsList.innerHTML = '<p>No saved worksheets found.</p>';
            }
        } catch (error) {
            console.error("Error loading worksheet list:", error);
            savedWorksheetsList.innerHTML = `<p style="color: red;">Error loading worksheet list: ${error.message}</p>`;
        } finally {
            loadWorksheetsButton.disabled = false;
        }
    });
    // --- END OF LOAD WORKSHEETS LIST LISTENER ---
    // --- LOAD SPECIFIC WORKSHEET LISTENER (Event Delegation) ---
    savedWorksheetsList.addEventListener('click', async (event) => {

// --- Handler for LOAD WORKSHEET Button ---
if (event.target.classList.contains('load-worksheet-button')) {
    const button = event.target;
    const worksheetId = button.dataset.worksheetId;
    if (!worksheetId) return;

    console.log(`Load worksheet button clicked for ID: ${worksheetId}`); // Correct log for loading
    worksheetAssemblyArea.innerHTML = '<div class="loading">Loading worksheet items...</div>';
    // Disable buttons while loading
    button.disabled = true;
    loadWorksheetsButton.disabled = true;
    clearSheetButton.disabled = true;

    try {
        const response = await fetch(`/load_worksheet/${worksheetId}`);
        const data = await response.json();

        if (!response.ok || data.status !== 'success') {
            throw new Error(data.message || `HTTP error! status: ${response.status}`);
        }

        // --- Rebuild Worksheet Assembly Area ---
        worksheetAssemblyArea.innerHTML = '';
        worksheetTitleInput.value = data.worksheet_title || '';

        if (data.items && data.items.length > 0) {
            data.items.forEach(itemData => {
                const worksheetItem = document.createElement('div');
                worksheetItem.classList.add('worksheet-item');
                worksheetItem.dataset.generatedItemId = itemData.id;
                worksheetItem.dataset.itemType = itemData.item_type; // Store item type

                // Apply common styles
                worksheetItem.style.border = '1px solid #a0a0a0';
                worksheetItem.style.padding = '15px';
                worksheetItem.style.marginBottom = '15px';
                worksheetItem.style.backgroundColor = 'white';
                worksheetItem.style.overflow = 'hidden';

                addWorksheetItemControls(worksheetItem); // Add controls (Remove, Move Up, Down)

                const contentDiv = document.createElement('div');
                contentDiv.style.clear = 'both'; // Ensure content clears floated controls

                if (itemData.item_type === 'imageLabel' && itemData.item_data_json) {
                    console.log(`Loading ImageLabel item ${itemData.id} into worksheet.`);
                    try {
                        const labelItemJsonData = JSON.parse(itemData.item_data_json);
                        if (!labelItemJsonData.baseImage || !labelItemJsonData.boxes_pct || !labelItemJsonData.refEditorWidth || !labelItemJsonData.refEditorHeight) {
                            throw new Error("ImageLabel item_data_json is missing crucial fields for worksheet display.");
                        }

                        // Store itemData for resize handler (updateWorksheetLabels)
                        worksheetItem.dataset.itemData = itemData.item_data_json;

                        const imageContainer = document.createElement('div');
                        imageContainer.className = 'worksheet-image-label-container';
                        // Styles are applied by CSS class mostly

                        const worksheetImgElement = document.createElement('img');
                        worksheetImgElement.src = `/static/uploads/${labelItemJsonData.baseImage}`;
                        // Styles are applied by CSS class

                        imageContainer.appendChild(worksheetImgElement);
                        contentDiv.appendChild(imageContainer);

                        worksheetImgElement.onload = () => {
                            const wsImageRenderedWidth = worksheetImgElement.offsetWidth;
                            const wsImageRenderedHeight = worksheetImgElement.offsetHeight;
                            console.log(`Worksheet ImageLabel ${itemData.id} ONLOAD. Rendered WxH: ${wsImageRenderedWidth}x${wsImageRenderedHeight}`);

                            if (wsImageRenderedWidth === 0 || wsImageRenderedHeight === 0) {
                                console.warn(`Worksheet ImageLabel ${itemData.id} has 0 dimensions on load. Boxes may not appear correctly.`);
                                // No need to return, static boxes might still be placed if dimensions update later via resize.
                            }
                            
                            // Clear any pre-existing static boxes (should not be needed if new item)
                            imageContainer.querySelectorAll('.static-label-box').forEach(sb => sb.remove());

                            labelItemJsonData.boxes_pct.forEach(boxPct => {
                                // Percentages (boxPct.x_pct etc.) are relative to refEditorWidth/Height.
                                // We need to scale them to the wsImageRenderedWidth/Height.
                                // This assumes the aspect ratio of refEditor and wsImageRendered is similar,
                                // or that percentages are applied to corresponding dimensions.
                                // For DOCX, we used refEditorWidth for width_pct and refEditorHeight for height_pct.
                                // For worksheet display, we scale to the *rendered* worksheet image.

                                let px_x, px_y, px_w, px_h;

                                // Option 1: Scale based on rendered worksheet image size, assuming percentages apply to that aspect ratio
                                // px_x = (parseFloat(boxPct.x_pct || 0) / 100) * wsImageRenderedWidth;
                                // px_y = (parseFloat(boxPct.y_pct || 0) / 100) * wsImageRenderedHeight;
                                // px_w = (parseFloat(boxPct.width_pct || 10) / 100) * wsImageRenderedWidth;
                                // px_h = (parseFloat(boxPct.height_pct || 5) / 100) * wsImageRenderedHeight;

                                // Option 2: More robust - Scale based on how editor percentages relate to original image,
                                // then apply to worksheet image. This uses the refEditorWidth/Height stored with percentages.
                                // This is what `updateWorksheetLabels` and DOCX export effectively do.
                                const orig_px_x = (parseFloat(boxPct.x_pct || 0) / 100) * labelItemJsonData.refEditorWidth;
                                const orig_px_y = (parseFloat(boxPct.y_pct || 0) / 100) * labelItemJsonData.refEditorHeight;
                                const orig_px_w = (parseFloat(boxPct.width_pct || 10) / 100) * labelItemJsonData.refEditorWidth;
                                const orig_px_h = (parseFloat(boxPct.height_pct || 5) / 100) * labelItemJsonData.refEditorHeight;

                                // Now scale these "original editor pixels" to the current worksheet image.
                                // Requires knowing the natural dimensions of the image the editor % were based on,
                                // or assuming refEditorWidth corresponds to naturalWidth for scaling.
                                // For simplicity and consistency with updateWorksheetLabels, let's use the direct % application to rendered size.
                                // updateWorksheetLabels will correct this on resize anyway if needed.

                                px_x = (parseFloat(boxPct.x_pct || 0) / 100) * wsImageRenderedWidth;
                                px_y = (parseFloat(boxPct.y_pct || 0) / 100) * wsImageRenderedHeight;
                                px_w = (parseFloat(boxPct.width_pct || 10) / 100) * wsImageRenderedWidth;
                                px_h = (parseFloat(boxPct.height_pct || 5) / 100) * wsImageRenderedHeight;


                                const staticBoxDiv = document.createElement('div');
                                staticBoxDiv.className = 'static-label-box';
                                staticBoxDiv.style.left = `${px_x}px`;
                                staticBoxDiv.style.top = `${px_y}px`;
                                staticBoxDiv.style.width = `${px_w}px`;
                                staticBoxDiv.style.height = `${px_h}px`;
                                // CSS class should handle other styles

                                const span = document.createElement('span');
                                span.textContent = (boxPct.type === 'blank') ? '' : String(boxPct.text).replace(/</g, "<");
                                staticBoxDiv.appendChild(span);
                                imageContainer.appendChild(staticBoxDiv);
                            });
                            console.log(`Worksheet ImageLabel ${itemData.id}: Static boxes positioned.`);
                             // Call updateWorksheetLabels once after initial placement if needed, though resize handles it.
                             // updateWorksheetLabels(); 
                        };
                        worksheetImgElement.onerror = () => {
                            console.error(`Error loading image for worksheet item ${itemData.id}: ${worksheetImgElement.src}`);
                            imageContainer.innerHTML = `<p style="color:red; font-size:small;">Error loading item image.</p>`;
                        };
                    } catch (e) {
                        console.error(`Error processing imageLabel item ${itemData.id} for worksheet:`, e);
                        contentDiv.innerHTML = `<p style="color:red;">Error displaying image label item: ${e.message}</p><p><small>${itemData.content_html}</small></p>`; // Show placeholder and error
                    }
                } else {
                    // For all other item types, just use the content_html
                    contentDiv.innerHTML = itemData.content_html;
                }
                worksheetItem.appendChild(contentDiv);
                worksheetAssemblyArea.appendChild(worksheetItem);
                // Optionally add a horizontal rule or other separator between items in the worksheet view
                if (data.items.indexOf(itemData) < data.items.length - 1) {
                     worksheetAssemblyArea.appendChild(document.createElement('hr'));
                }
            });
            // After all items are added, trigger a label update in case images loaded fast or were cached
            setTimeout(updateWorksheetLabels, 100);
        } else {
             worksheetAssemblyArea.innerHTML = '<p style="color: grey; font-style: italic;">Worksheet loaded but contains no items.</p>';
        }
        console.log(`Worksheet ${worksheetId} loaded successfully.`);

    } catch (error) {
        console.error(`Error loading worksheet ${worksheetId}:`, error);
        worksheetAssemblyArea.innerHTML = `<p style="color: red;">Error loading worksheet: ${error.message}</p>`;
    } finally {
         // Re-enable buttons
         loadWorksheetsButton.disabled = false;
         clearSheetButton.disabled = false;
         // Re-enable specific button?
         // button.disabled = false; // Maybe not, let user reload list if needed
    }
} // --- END of 'load-worksheet-button' Handler ---


// --- Handler for EXPORT DOCX Button ---
else if (event.target.classList.contains('export-docx-button')) {
    const button = event.target;
    const worksheetId = button.dataset.worksheetId;
    if (!worksheetId) {
        console.error("Export DOCX button clicked but worksheet ID is missing.");
        return;
    }
    // Use the CORRECT log message here
    console.log(`Export DOCX button clicked for ID: ${worksheetId}`);
    console.log(`Attempting to navigate to: /export/docx/${worksheetId}`); // Add this log

    // Directly navigate to the export URL - the backend will handle the download
    window.location.href = `/export/docx/${worksheetId}`;

    // Optional: Add visual feedback? e.g., briefly disable button
    button.disabled = true;
    button.textContent = 'Exporting...'
    setTimeout(() => { // Re-enable after a short delay
         button.disabled = false;
         button.textContent = 'Export DOCX';
    }, 2000); // Re-enable after 2 seconds

} // --- END of 'export-docx-button' Handler ---

// --- Add other handlers (e.g., delete) using else if blocks here ---

}); // --- END of savedWorksheetsList listener ---

    // --- END OF LOAD SPECIFIC WORKSHEET LISTENER ---
        loadLibraryButton.addEventListener('click', async () => { /* ... Keep unchanged ... */
             libraryOutput.innerHTML = '<div class="loading">Loading library...</div>'; loadLibraryButton.disabled = true; try { const response = await fetch('/list_items'); const data = await response.json(); if (!response.ok || data.status !== 'success') { throw new Error(data.message || `HTTP error! Status: ${response.status}`); } if (data.items && data.items.length > 0) { libraryOutput.innerHTML = ''; const list = document.createElement('ul'); list.style.listStyle = 'none'; list.style.padding = '0'; data.items.forEach(item => { const listItem = document.createElement('li'); let description = `Type: ${item.item_type}`; if(item.source_topic) description += `, Topic: ${item.source_topic}`; if(item.source_url) description += `, URL: <small>${item.source_url}</small>`; description += `, Grade: ${item.grade_level}`; listItem.innerHTML = `<strong>ID: ${item.id}</strong> - ${description} <br><small>Last Modified: ${new Date(item.last_modified).toLocaleString()}</small><button data-item-id="${item.id}" class="load-item-button" style="margin-left: 15px; padding: 2px 8px; font-size: 0.8em;">Load Item</button>`; list.appendChild(listItem); }); libraryOutput.appendChild(list); } else { libraryOutput.innerHTML = '<p>No saved items found in the library.</p>'; } } catch (error) { console.error("Error loading library:", error); libraryOutput.innerHTML = `<p style="color: red;">Error loading library: ${error.message}</p>`; } finally { loadLibraryButton.disabled = false; }
        });
        addToSheetButton.addEventListener('click', () => {
            const activeModeRadio = document.querySelector('input[name="generatorMode"]:checked');
            const activeModeValue = activeModeRadio ? activeModeRadio.value : 'none';
            console.log(`ADD TO SHEET CLICKED: currentItemIdInPreview IS: ${currentItemIdInPreview}, Active Mode: ${activeModeValue}`); // Modified log
            console.log("Add to Sheet button clicked (raw log).");
    // Ensure editing is off before adding
    if (isEditingEnabled) {
        alert("Please disable editing before adding the item to the worksheet.");
        return;
    }
    if (currentItemIdInPreview === null) {
        alert("Cannot add item to worksheet. Please save the current item first, or load an existing item from the library.");
        return;
    }

    // Get the HTML content from the preview area
    const previewContent = itemPreviewArea.innerHTML;
    console.log("--- AddToSheet: Content being added ---");
    console.log(previewContent); // Log the actual HTML string
    console.log("--- End AddToSheet Content ---");

    // Check if the preview content is valid (not empty, loading, or placeholder)
    if (!previewContent || previewContent.trim() === '' || previewContent.includes('will appear here') || previewContent.includes('<div class="loading">')) {
        alert("No valid item in the preview area to add.");
        return;
    }

    // --- Create a wrapper div for the item on the worksheet ---
    const worksheetItem = document.createElement('div');
    worksheetItem.classList.add('worksheet-item'); // For potential future styling/identification
    worksheetItem.dataset.generatedItemId = currentItemIdInPreview;
    // Add some basic inline styles for visibility for now
    worksheetItem.style.border = '1px solid #a0a0a0';
    worksheetItem.style.padding = '15px';
    worksheetItem.style.marginBottom = '15px';
    worksheetItem.style.backgroundColor = 'white';
    worksheetItem.style.overflow = 'hidden'; // Contains floats

    // --- Add controls to the item (e.g., Remove button) ---
    addWorksheetItemControls(worksheetItem);
    const contentDiv = document.createElement('div');
    contentDiv.style.clear = 'both'; // Ensure content clears floated controls if any were used
    contentDiv.innerHTML = previewContent; // Put the preview HTML inside this div
    worksheetItem.appendChild(contentDiv);
    

    // --- Append the complete item to the Assembly Area ---
    // Clear placeholder text if it's the first item being added
    const placeholder = worksheetAssemblyArea.querySelector('p');
    if (placeholder && placeholder.textContent.includes('Items added to the worksheet')) {
         worksheetAssemblyArea.innerHTML = ''; // Clear the placeholder
    }
    console.log("--- AddToSheet: Final worksheetItem structure BEFORE appending to assembly area ---");
    console.log(worksheetItem.outerHTML);
    console.log(`WorksheetItem children count: ${worksheetItem.children.length}`);
    if (worksheetItem.children.length > 1) {
         console.log("First child (should be controls):", worksheetItem.children[0].tagName, worksheetItem.children[0].className);
         console.log("Second child (should be content):", worksheetItem.children[1].tagName, worksheetItem.children[1].className);
    }
    worksheetAssemblyArea.appendChild(worksheetItem); // Add the new item

    console.log("Item appended to worksheet assembly area.");

    // Optional: Clear preview area and disable buttons after adding?
    // itemPreviewArea.innerHTML = 'Item added to worksheet below. Generate or load another.';
    // toggleEditButton.disabled = true;
    // saveButton.disabled = true;
    // addToSheetButton.disabled = true;
});
    // **** Listener for Add Image Label Item to Worksheet Button ****
    addImageLabelToWorksheetBtn.addEventListener('click', () => {
        console.log("===> START addImageLabelToWorksheetBtn");
        imageLabelStatus.textContent = '';

        if (currentItemIdInPreview === null) { alert("Please save the image item to the library before adding it to the worksheet."); imageLabelStatus.textContent = 'Error: Item must be saved first.'; imageLabelStatus.style.color = 'red'; return; }
        console.log("===> AddToWorksheet: Item is saved (ID:", currentItemIdInPreview, ")");

        if (!baseImageFilename || !labelBoxes) { alert("Cannot add to worksheet. Image or box data is missing from current state."); imageLabelStatus.textContent = 'Error: Current image/box data missing.'; imageLabelStatus.style.color = 'red'; return; }
        console.log("===> AddToWorksheet: Base image and labelBoxes exist.");

        // Get RENDERED and NATURAL dimensions from the EDITOR's preview image
        const editorRenderedWidth = ilPreviewImage.offsetWidth;
        const editorRenderedHeight = ilPreviewImage.offsetHeight;
        const editorNaturalWidth = ilPreviewImage.naturalWidth;
        const editorNaturalHeight = ilPreviewImage.naturalHeight;

        if (!editorRenderedWidth || !editorRenderedHeight || !editorNaturalWidth || !editorNaturalHeight) {
            alert("Error: Cannot determine critical editor image dimensions. Cannot add to worksheet accurately.");
            imageLabelStatus.textContent = 'Error: Editor image dimensions unknown.';
            imageLabelStatus.style.color = 'red';
            return;
        }
        console.log(`===> AddToWorksheet: Editor rendered WxH: ${editorRenderedWidth}x${editorRenderedHeight}, Natural WxH: ${editorNaturalWidth}x${editorNaturalHeight}`);

        // --- Create worksheetItem and store percentage data for DOCX/Resize ---
        const worksheetItem = document.createElement('div');
        worksheetItem.classList.add('worksheet-item');
        worksheetItem.dataset.generatedItemId = currentItemIdInPreview;
        worksheetItem.dataset.itemType = 'imageLabel';

        // Percentages calculated relative to EDITOR'S RENDERED size
        const boxDataForDataset = labelBoxes.map(b => ({
            x_pct: (b.x / editorRenderedWidth) * 100,
            y_pct: (b.y / editorRenderedHeight) * 100,
            width_pct: (b.w / editorRenderedWidth) * 100,
            height_pct: (b.h / editorRenderedHeight) * 100,
            type: b.type,
            text: b.text
        }));
        worksheetItem.dataset.itemData = JSON.stringify({
             baseImage: baseImageFilename,
             boxes_pct: boxDataForDataset,
             refEditorWidth: editorRenderedWidth,   // The dimensions these % are relative to
             refEditorHeight: editorRenderedHeight,
             naturalWidth: editorNaturalWidth,     // Original image natural dimensions
             naturalHeight: editorNaturalHeight
        });
        console.log("===> AddToWorksheet: Stored itemData (for DOCX/resize):", worksheetItem.dataset.itemData);

        addWorksheetItemControls(worksheetItem);

        // --- Create the content structure ---
        const contentDiv = document.createElement('div');
        contentDiv.style.clear = 'both';

        const imageContainer = document.createElement('div');
        imageContainer.className = 'worksheet-image-label-container'; // Used by updateWorksheetLabels
        imageContainer.style.position = 'relative';
        imageContainer.style.maxWidth = '100%';
        imageContainer.style.display = 'inline-block';
        imageContainer.style.lineHeight = '0';

        const worksheetImgElement = document.createElement('img');
        worksheetImgElement.src = `/static/uploads/${baseImageFilename}`;
        worksheetImgElement.style.display = 'block';
        worksheetImgElement.style.maxWidth = '100%';
        worksheetImgElement.style.height = 'auto';
        worksheetImgElement.style.border = '1px dashed #ddd'; // For debugging

        imageContainer.appendChild(worksheetImgElement);
        contentDiv.appendChild(imageContainer);
        worksheetItem.appendChild(contentDiv);

        const placeholder = worksheetAssemblyArea.querySelector('p');
        if (placeholder && placeholder.textContent.includes('Items added to the worksheet')) {
            worksheetAssemblyArea.innerHTML = '';
            console.log("===> AddToWorksheet: Placeholder removed.");
        }
        worksheetAssemblyArea.appendChild(worksheetItem);
        worksheetAssemblyArea.appendChild(document.createElement('hr'));
        console.log("===> AddToWorksheet: WorksheetItem structure appended to DOM.");

        // --- Position the Static Boxes using PIXELS AFTER the worksheet image has loaded ---
        worksheetImgElement.onload = () => {
            const wsImageRenderedWidth = worksheetImgElement.offsetWidth;
            const wsImageRenderedHeight = worksheetImgElement.offsetHeight;
            console.log(`===> AddToWorksheet: worksheetImgElement ONLOAD. Rendered WxH in worksheet: ${wsImageRenderedWidth}x${wsImageRenderedHeight}`);

            // Clear any pre-existing static boxes (should not be needed if innerHTML was not used, but safe)
            imageContainer.querySelectorAll('.static-label-box').forEach(sb => sb.remove());

            // Use the `boxDataForDataset` (which contains percentages relative to editor's rendered size)
            boxDataForDataset.forEach(boxPct => {
                // Calculate PIXEL positions relative to the CURRENT RENDERED size of the image in the worksheet
                const px_x = (boxPct.x_pct / 100) * wsImageRenderedWidth;
                const px_y = (boxPct.y_pct / 100) * wsImageRenderedHeight;
                const px_w = (boxPct.width_pct / 100) * wsImageRenderedWidth;
                const px_h = (boxPct.height_pct / 100) * wsImageRenderedHeight;

                console.log(`  Box % (x,y,w,h): ${boxPct.x_pct.toFixed(1)}, ${boxPct.y_pct.toFixed(1)}, ${boxPct.width_pct.toFixed(1)}, ${boxPct.height_pct.toFixed(1)} -> Px (L,T,W,H): ${px_x.toFixed(1)}, ${px_y.toFixed(1)}, ${px_w.toFixed(1)}, ${px_h.toFixed(1)}`);

                const staticBoxDiv = document.createElement('div');
                staticBoxDiv.className = 'static-label-box';
                staticBoxDiv.style.position = 'absolute';
                staticBoxDiv.style.left = `${px_x}px`; // Apply calculated pixels
                staticBoxDiv.style.top = `${px_y}px`;  // Apply calculated pixels
                staticBoxDiv.style.width = `${px_w}px`;// Apply calculated pixels
                staticBoxDiv.style.height = `${px_h}px`;// Apply calculated pixels
                // Apply other necessary styles from your .static-label-box CSS definition
                staticBoxDiv.style.border = '1px solid black';
                staticBoxDiv.style.backgroundColor = 'rgba(255,255,255,0.8)';
                staticBoxDiv.style.fontSize = '8px'; // Adjust as needed
                staticBoxDiv.style.display = 'flex';
                staticBoxDiv.style.alignItems = 'center';
                staticBoxDiv.style.justifyContent = 'center';
                staticBoxDiv.style.textAlign = 'center';
                staticBoxDiv.style.overflow = 'hidden';
                staticBoxDiv.style.boxSizing = 'border-box';

                const span = document.createElement('span');
                const content = (boxPct.type === 'blank') ? '' : boxPct.text;
                span.textContent = String(content).replace(/</g, "<").replace(/>/g, ">");
                staticBoxDiv.appendChild(span);
                imageContainer.appendChild(staticBoxDiv); // Append to the relative container
            });
            console.log(`===> AddToWorksheet: Initial static boxes (pixel-based) positioned for item ${currentItemIdInPreview}.`);
        };
        worksheetImgElement.onerror = () => {
             console.error(`===> AddToWorksheet: Error loading worksheet image: ${worksheetImgElement.src}`);
             imageContainer.innerHTML += '<p style="color:red; font-size:small;">Error loading item image in worksheet.</p>';
         };

        console.log(`===> AddToWorksheet: Image Label item ${currentItemIdInPreview} fully processed and added.`);
        imageLabelStatus.textContent = `Item ${currentItemIdInPreview} added to worksheet.`;
        imageLabelStatus.style.color = 'green';
    });
    // **** END Listener ****
libraryOutput.addEventListener('click', async (event) => {
             if (event.target.classList.contains('load-item-button')) {
                 const button = event.target;
                 const itemId = button.dataset.itemId;
                 if (!itemId) { console.error("Load button clicked but item ID is missing."); return; }
                 console.log(`Load button clicked for item ID: ${itemId}`);
                 libraryOutput.querySelectorAll('.load-item-button').forEach(btn => btn.disabled = true);
                 itemPreviewArea.innerHTML = '<div class="loading">Loading item...</div>';
                 toggleEditButton.disabled = true;
                 saveButton.disabled = true;
                 addToSheetButton.disabled = true;
                 try { // <--------------------------------------------- START OF TRY BLOCK
                     const response = await fetch(`/get_item/${itemId}`);
                     const data = await response.json();
                     if (!response.ok) { // Check response status early
                          throw new Error(data.message || `HTTP error! Status: ${response.status}`);
                     }

                     // --- START: NEW LOGIC PASTED INSIDE TRY ---
                     if (data.item) {
                         const itemType = data.item.item_type;
                         const contentHtml = data.item.content_html;
                         const loadedItemIdFromResponse = data.item.id; 
                         const itemDataJsonString = data.item.item_data_json;

                         console.log(`Processing loaded item ID: ${loadedItemIdFromResponse} (Type: ${typeof loadedItemIdFromResponse}), Raw item.id: ${data.item.id}, Type: ${itemType}`); // Enhanced Log 1
                         
                         console.log(`BEFORE ASSIGNMENT - currentItemIdInPreview: ${currentItemIdInPreview}, loadedItemIdFromResponse: ${loadedItemIdFromResponse}`); // ADD THIS
                         currentItemIdInPreview = loadedItemIdFromResponse; 
                         console.log(`AFTER ASSIGNMENT - currentItemIdInPreview: ${currentItemIdInPreview}, loadedItemIdFromResponse: ${loadedItemIdFromResponse}`);

                         // Reset UI elements common to most load paths
                         itemPreviewArea.innerHTML = ''; // Clear main preview first
                         itemPreviewArea.style.display = 'none';
                         keywordsPreviewArea.style.display = 'none'; // Hide keywords preview specifically
                         imageLabelInputsDiv.style.display = 'none'; // Hide image label inputs
                         ilPreviewContainer.style.display = 'none'; // Hide image preview container

                         // Hide main action buttons by default, enable per type
                         toggleEditButton.style.display = 'none';
                         saveButton.style.display = 'none';
                         addToSheetButton.style.display = 'none';
                         
                         // Hide keyword-specific buttons by default
                         addKeywordsToWorksheetBtn.disabled = true;
                         saveKeywordsItemBtn.disabled = true;
                         // Hide image-label-specific buttons by default
                         saveImageLabelItemBtn.disabled = true;
                         addImageLabelToWorksheetBtn.disabled = true;
                         ilInteractionControls.style.display = 'none';


                         if (itemType && itemType.startsWith('keywords-')) {
                             console.log(`Loading KEYWORDS item specific logic... ID: ${currentItemIdInPreview}`);
                             let keywordsJsonData = '[]';
                             if (itemDataJsonString) { // data.item.item_data_json
                                 keywordsJsonData = itemDataJsonString;
                             } else {
                                 console.warn("Keywords item_data_json missing from loaded item. Content may be incomplete.");
                             }
                             try {
                                 currentKeywordData = JSON.parse(keywordsJsonData || '[]');
                                 if (!Array.isArray(currentKeywordData)) currentKeywordData = [];
                             } catch (parseError) {
                                 console.error("Error parsing stored keywords JSON:", parseError, "JSON was:", keywordsJsonData);
                                 currentKeywordData = [];
                             }

                             const specificActivityType = itemType.substring('keywords-'.length);
                             console.log("Programmatically checking Keywords radio. Temporarily removing listener.");
                             modeKeywordsDefinitionsRadio.removeEventListener('change', handleUserModeSelectionChange);
                             modeKeywordsDefinitionsRadio.checked = true;
                             modeKeywordsDefinitionsRadio.addEventListener('change', handleUserModeSelectionChange);
                             console.log("Keywords radio checked. Listener re-added.");
                             handleModeChange(true, currentItemIdInPreview); // true to indicate loading

                             const radioToSelectKeywords = document.querySelector(`input[name="keywordActivity"][value="${specificActivityType}"]`);
                             if (radioToSelectKeywords) radioToSelectKeywords.checked = true;
                             else document.getElementById('activityRefTable').checked = true; // Default

                             if (currentKeywordData.length > 0) displayKeywordActivity();
                             else activityOutput.innerHTML = '<p>Keyword data loaded but appears empty or invalid.</p>';
                             
                             keywordsPreviewArea.style.display = 'block';
                             keywordsItemIdDisplay.textContent = `Loaded ID: ${currentItemIdInPreview}`;
                             keywordsStatus.textContent = `Item ${currentItemIdInPreview} loaded.`;
                             keywordsStatus.className = 'status-message info';
                             addKeywordsToWorksheetBtn.disabled = false; // Enable because loaded
                             saveKeywordsItemBtn.disabled = false; // Enable for updates

                         } else if (itemType === 'similarWrittenQ') {
                             console.log(`Loading SIMILARWRITTENQ item specific logic... ID: ${currentItemIdInPreview}`);
                             let resultData = null;
                             let skills = "Skills not found in saved data.";
                             let questions = [];

                             if (itemDataJsonString) {
                                 try {
                                     resultData = JSON.parse(itemDataJsonString);
                                     if (resultData && typeof resultData === 'object') {
                                         skills = resultData.skills_identified || skills;
                                         questions = resultData.similar_questions || [];
                                         if (!Array.isArray(questions)) questions = [];
                                     }
                                 } catch(e) { console.error("Error parsing SWQ item_data_json:", e); }
                             } else {
                                 console.warn("Raw data (item_data_json) not found for similarWrittenQ item.");
                             }

                             let reconstructedHtml = '<div class="worksheet-section" data-item-type="similar-written-q">';
                             itemPreviewArea.dataset.rawSwqData = itemDataJsonString || '{}'; // Store for re-saving
                             reconstructedHtml += `<h3>Skills Tested</h3><p>${skills.replace(/</g, "<")}</p>`;
                             reconstructedHtml += '<h3>Generated Questions</h3>';
                             if (questions.length > 0) {
                                 reconstructedHtml += '<ol>';
                                 questions.forEach(q => {
                                     reconstructedHtml += `<li style="margin-bottom: 0.8em;">${String(q).replace(/</g, "<")}</li>`;
                                 });
                                 reconstructedHtml += '</ol>';
                             } else {
                                 reconstructedHtml += '<p>No similar questions found in saved data.</p>';
                             }
                             reconstructedHtml += '</div>';

                             console.log("Programmatically checking SimilarWrittenQ radio. Temporarily removing listener.");
                             modeSimilarWrittenQRadio.removeEventListener('change', handleUserModeSelectionChange);
                             modeSimilarWrittenQRadio.checked = true;
                             modeSimilarWrittenQRadio.addEventListener('change', handleUserModeSelectionChange);
                             console.log("SimilarWrittenQ radio checked. Listener re-added.");
                             handleModeChange(true, currentItemIdInPreview); // Pass true to prevent ID reset
                             
                             itemPreviewArea.innerHTML = reconstructedHtml;
                             itemPreviewArea.style.display = 'block'; // Show main preview
                             toggleEditButton.style.display = 'inline-block';
                             saveButton.style.display = 'inline-block';
                             addToSheetButton.style.display = 'inline-block';
                             toggleEditButton.disabled = false;
                             saveButton.disabled = false; // Allow re-saving
                             addToSheetButton.disabled = false; // Allow adding
                             isEditingEnabled = false;
                             toggleEditButton.textContent = 'Enable Editing';

                         } else if (itemType === 'imageLabel') {
                             console.log(`Loading IMAGELABEL item specific logic... ID: ${currentItemIdInPreview}`);
                             imageLabelStatus.textContent = `Loading Item ${currentItemIdInPreview}...`;
                             imageLabelStatus.style.color = 'grey';

                             if (!itemDataJsonString) {
                                 console.error("Image Labelling item loaded, but item_data_json is missing.");
                                 imageLabelStatus.textContent = 'Error: Saved item data is missing.';
                                 imageLabelStatus.style.color = 'red';
                                 saveImageLabelItemBtn.disabled = true; addImageLabelToWorksheetBtn.disabled = true; ilInteractionControls.style.display = 'none';
                                 return; 
                             }

                             let loadedLabelData;
                             try {
                                 loadedLabelData = JSON.parse(itemDataJsonString);
                                 if (!loadedLabelData || !loadedLabelData.baseImage || !loadedLabelData.boxes_pct ) {
                                     throw new Error("Invalid structure in item_data_json for imageLabel (missing baseImage or boxes_pct).");
                                 }
                             } catch (parseError) {
                                 console.error("Error parsing item_data_json for imageLabel:", parseError);
                                 imageLabelStatus.textContent = `Error: Failed to parse image data.`;
                                 saveImageLabelItemBtn.disabled = true; addImageLabelToWorksheetBtn.disabled = true; ilInteractionControls.style.display = 'none';
                                 return;
                             }
                             
                             console.log("Programmatically checking ImageLabel radio. Temporarily removing listener.");
                             modeImageLabelRadio.removeEventListener('change', handleUserModeSelectionChange);
                             modeImageLabelRadio.checked = true;
                             modeImageLabelRadio.addEventListener('change', handleUserModeSelectionChange);
                             console.log("ImageLabel radio checked. Listener re-added.");
                             handleModeChange(true, currentItemIdInPreview); 

                             baseImageFilename = loadedLabelData.baseImage;
                             const imageUrl = `/static/uploads/${baseImageFilename}`;
                             ilPreviewImage.dataset.filename = baseImageFilename;
                             
                             // --- More Aggressive Visibility & Reflow ---
                             imageLabelInputsDiv.classList.remove('hidden'); // Re-ensure parent is not hidden
                             imageLabelInputsDiv.style.display = 'block !important'; // Force display
                             // Temporarily give imageLabelInputsDiv some dimensions to see if it helps children
                             // imageLabelInputsDiv.style.height = '500px'; 
                             // imageLabelInputsDiv.style.border = '2px solid red'; // Visual debug

                             ilPreviewContainer.style.display = 'block'; 
                             // ilPreviewContainer.style.border = '2px solid blue'; // Visual debug
                             ilInteractionControls.style.display = 'block'; 
                             ilPreviewImage.style.display = 'block';

                             console.log(`IMAGELABEL LOAD: Forcing reflow check. imageLabelInputsDiv offsetH: ${imageLabelInputsDiv.offsetHeight}, ilPreviewContainer offsetH: ${ilPreviewContainer.offsetHeight}`);
                             // --- End More Aggressive Visibility & Reflow ---

                             console.log(`IMAGELABEL LOAD: All containers set to visible. Preparing to set src for ${imageUrl}`); // Existing log

                             console.log(`IMAGELABEL LOAD: All containers set to visible. Preparing to set src for ${imageUrl}`);

                             // Define the core logic that needs dimensions
                             const setupBoxesWithDimensions = () => {
                                console.log(`Inside setupBoxesWithDimensions. Checking dimensions: ilPreviewImage offsetW/H: ${ilPreviewImage.offsetWidth}x${ilPreviewImage.offsetHeight}`);
                                console.log(`  Parent ilPreviewContainer offsetW/H: ${ilPreviewContainer.offsetWidth}x${ilPreviewContainer.offsetHeight}`);

                                ilUploadStatus.textContent = `Loaded base image: ${baseImageFilename}`;
                                ilUploadStatus.style.color = 'green';
    
                                let referenceWidthForConversion = loadedLabelData.refEditorWidth;
                                let referenceHeightForConversion = loadedLabelData.refEditorHeight;
    
                                if (!referenceWidthForConversion || !referenceHeightForConversion) {
                                    console.warn(`Item ${currentItemIdInPreview}: refEditorW/H missing. Fallback to naturalW/H.`);
                                    referenceWidthForConversion = loadedLabelData.naturalWidth;
                                    referenceHeightForConversion = loadedLabelData.naturalHeight;
                                }
                                if (!referenceWidthForConversion || !referenceHeightForConversion) {
                                    console.warn(`Item ${currentItemIdInPreview}: naturalW/H also missing. Fallback to current naturalW/H.`);
                                    referenceWidthForConversion = ilPreviewImage.naturalWidth;
                                    referenceHeightForConversion = ilPreviewImage.naturalHeight;
                                }
                                if (!referenceWidthForConversion || !referenceHeightForConversion || referenceWidthForConversion === 0 || referenceHeightForConversion === 0) {
                                    console.error(`CRITICAL ERROR: Item ${currentItemIdInPreview}: Invalid reference dimensions (${referenceWidthForConversion}x${referenceHeightForConversion}). Aborting.`);
                                    imageLabelStatus.textContent = 'Error: Invalid reference dimensions.';
                                    saveImageLabelItemBtn.disabled = true; addImageLabelToWorksheetBtn.disabled = true;
                                    return;
                                }
                                console.log(`Item ${currentItemIdInPreview}: Using reference for % -> px: ${referenceWidthForConversion}x${referenceHeightForConversion}`);
    
                                const currentEditorImageRenderedWidth = ilPreviewImage.offsetWidth;
                                const currentEditorImageRenderedHeight = ilPreviewImage.offsetHeight;
    
                                if (!currentEditorImageRenderedWidth || !currentEditorImageRenderedHeight) {
                                    console.error(`CRITICAL ERROR (in setupBoxesWithDimensions): Item ${currentItemIdInPreview}: ilPreviewImage rendered dimensions are 0x0. Aborting.`);
                                    imageLabelStatus.textContent = 'Error: Editor image not rendering with dimensions.';
                                    saveImageLabelItemBtn.disabled = true; addImageLabelToWorksheetBtn.disabled = true;
                                    return;
                                }
                                console.log(`Item ${currentItemIdInPreview}: Editor image RENDERED (in setupBoxesWithDimensions): ${currentEditorImageRenderedWidth}x${currentEditorImageRenderedHeight}`);
    
                                labelBoxes.forEach(boxData => { if (boxData.element) boxData.element.remove(); });
                                labelBoxes = []; selectedBoxId = null; nextBoxNumber = 1; 
                                ilBoxControls.style.display = 'none';
    
                                let maxLoadedNumber = 0;
                                const boxesToProcess = loadedLabelData.boxes_pct || loadedLabelData.boxes;
                                const inputArePercentages = !!loadedLabelData.boxes_pct; 
    
                                if (boxesToProcess && Array.isArray(boxesToProcess)) {
                                    boxesToProcess.forEach(box => {
                                        let px_x_on_ref, px_y_on_ref, px_w_on_ref, px_h_on_ref;
                                        let final_px_x_in_editor, final_px_y_in_editor, final_px_w_in_editor, final_px_h_in_editor;
    
                                        if (inputArePercentages) {
                                            px_x_on_ref = (parseFloat(box.x_pct || 0) / 100) * referenceWidthForConversion;
                                            px_y_on_ref = (parseFloat(box.y_pct || 0) / 100) * referenceHeightForConversion;
                                            px_w_on_ref = (parseFloat(box.width_pct || 10) / 100) * referenceWidthForConversion;
                                            px_h_on_ref = (parseFloat(box.height_pct || 5) / 100) * referenceHeightForConversion;
    
                                            if (referenceWidthForConversion === 0 || referenceHeightForConversion === 0) {
                                                console.error("Ref W/H for conversion is zero.");
                                                final_px_x_in_editor = px_x_on_ref; final_px_y_in_editor = px_y_on_ref;
                                                final_px_w_in_editor = px_w_on_ref; final_px_h_in_editor = px_h_on_ref;
                                            } else {
                                                const scaleFactorWidth = currentEditorImageRenderedWidth / referenceWidthForConversion;
                                                const scaleFactorHeight = currentEditorImageRenderedHeight / referenceHeightForConversion;
                                                final_px_x_in_editor = px_x_on_ref * scaleFactorWidth;
                                                final_px_y_in_editor = px_y_on_ref * scaleFactorHeight;
                                                final_px_w_in_editor = px_w_on_ref * scaleFactorWidth;
                                                final_px_h_in_editor = px_h_on_ref * scaleFactorHeight;
                                            }
                                        } else { 
                                            const oldRefWidth = loadedLabelData.refEditorWidth || loadedLabelData.naturalWidth || ilPreviewImage.naturalWidth;
                                            const oldRefHeight = loadedLabelData.refEditorHeight || loadedLabelData.naturalHeight || ilPreviewImage.naturalHeight;
                                            px_x_on_ref = parseFloat(box.x || 0); px_y_on_ref = parseFloat(box.y || 0);
                                            px_w_on_ref = parseFloat(box.width || 50); px_h_on_ref = parseFloat(box.height || 30);
                                            if (oldRefWidth === 0 || oldRefHeight === 0) {
                                                console.error("Old Ref W/H for conversion is zero.");
                                                final_px_x_in_editor = px_x_on_ref; final_px_y_in_editor = px_y_on_ref;
                                                final_px_w_in_editor = px_w_on_ref; final_px_h_in_editor = px_h_on_ref;
                                            } else {
                                                const scaleFactorWidth = currentEditorImageRenderedWidth / oldRefWidth;
                                                const scaleFactorHeight = currentEditorImageRenderedHeight / oldRefHeight;
                                                final_px_x_in_editor = px_x_on_ref * scaleFactorWidth;
                                                final_px_y_in_editor = px_y_on_ref * scaleFactorHeight;
                                                final_px_w_in_editor = px_w_on_ref * scaleFactorWidth;
                                                final_px_h_in_editor = px_h_on_ref * scaleFactorHeight;
                                            }
                                        }
                                        const newBoxData = createLabelBox(final_px_x_in_editor, final_px_y_in_editor, final_px_w_in_editor, final_px_h_in_editor);
                                        newBoxData.type = box.type; newBoxData.text = box.text;
                                        const contentSpan = newBoxData.element.querySelector('.label-box-content span');
                                        if (contentSpan) {
                                            if (box.type === 'blank') contentSpan.textContent = ''; else contentSpan.textContent = box.text;
                                        }
                                        if (box.type === 'number') {
                                            const num = parseInt(box.text);
                                            if (!isNaN(num)) maxLoadedNumber = Math.max(maxLoadedNumber, num);
                                        }
                                    });
                                    nextBoxNumber = maxLoadedNumber + 1;
                                }
                                imageLabelItemIdDisplay.textContent = `Loaded ID: ${currentItemIdInPreview}`;
                                imageLabelStatus.textContent = `Item ${currentItemIdInPreview} loaded.`;
                                saveImageLabelItemBtn.disabled = false; 
                                addImageLabelToWorksheetBtn.disabled = false;
                             }; // End of setupBoxesWithDimensions

                             const imageLoadErrorProxy = () => {
                                 console.error(`Error loading image ${imageUrl} for item ${currentItemIdInPreview} (via proxy error handler).`);
                                 ilUploadStatus.textContent = `Error: Could not load image file ${baseImageFilename}.`;
                                 ilUploadStatus.style.color = 'red';
                                 ilPreviewContainer.style.display = 'none';
                                 ilInteractionControls.style.display = 'none';
                                 imageLabelStatus.textContent = `Failed to load image for item ${currentItemIdInPreview}.`;
                                 saveImageLabelItemBtn.disabled = true; addImageLabelToWorksheetBtn.disabled = true;
                             };
                             
                             // Clean up potential old listeners (defensive)
                             ilPreviewImage.onload = null;
                             ilPreviewImage.onerror = null;

                             // Set src first
                             ilPreviewImage.src = imageUrl;
                             console.log(`IMAGELABEL LOAD: src set to ${imageUrl}. Checking 'complete' and 'naturalWidth'.`);

                             // Check if image is already loaded (e.g., from cache)
                             if (ilPreviewImage.complete && ilPreviewImage.naturalWidth > 0) {
                                 console.log("IMAGELABEL LOAD: Image was already complete and had naturalWidth. Proceeding to setup boxes directly.");
                                 // If already complete, run the setup logic, perhaps after a minimal delay for rendering consistency
                                 setTimeout(setupBoxesWithDimensions, 0); 
                             } else if (ilPreviewImage.complete && ilPreviewImage.naturalWidth === 0) {
                                // This is an edge case: complete but no dimensions means it likely failed to decode/render
                                console.error("IMAGELABEL LOAD: Image is 'complete' but naturalWidth is 0. Treating as an error.");
                                imageLoadErrorProxy();
                             } else {
                                 // If not complete, attach listeners to wait for load or error
                                 console.log("IMAGELABEL LOAD: Image not yet complete. Attaching load/error listeners.");
                                 ilPreviewImage.onload = setupBoxesWithDimensions;
                                 ilPreviewImage.onerror = imageLoadErrorProxy;
                             }

                         } else if (contentHtml) { // Fallback for OTHER STANDARD TEXT ITEMS (MCQ, GapFill, TrueFalse, ShortAnswer, TextBlock, SimilarQ, WordSearch)
                             console.log(`Loading STANDARD TEXT item type: ${itemType} with ID: ${currentItemIdInPreview}`);
                             
                             // Select the corresponding mode radio button
                             let radioToSelect = null;
                            if (itemType === 'gapFill') radioToSelect = modeGapFillRadio;
                            else if (itemType === 'pastedText') radioToSelect = modePastedTextRadio;
                            else if (itemType === 'mcq') radioToSelect = modeMcqRadio;
                            else if (itemType === 'trueFalse') radioToSelect = modeTrueFalseRadio;
                            else if (itemType === 'shortAnswer') radioToSelect = modeShortAnswerRadio;
                            else if (itemType === 'textBlock') radioToSelect = modeTextBlockRadio;
                            else if (itemType === 'similarQ') radioToSelect = modeSimilarQRadio;
                            else if (itemType === 'wordSearch') radioToSelect = modeWordSearchRadio;
                            // No need to handle similarWrittenQ, keywords, imageLabel here as they have their own `else if` blocks

                            if (radioToSelect) {
                                console.log(`Programmatically checking radio for ${itemType}. Temporarily removing listener.`);
                                radioToSelect.removeEventListener('change', handleUserModeSelectionChange);
                                radioToSelect.checked = true;
                                radioToSelect.addEventListener('change', handleUserModeSelectionChange);
                                console.log(`Radio for ${itemType} checked. Listener re-added.`);
                            } else {
                                // This case handles if an item type from the DB doesn't match any above,
                                // and it's not keywords, similarWrittenQ, or imageLabel.
                                // It would fall through to the generic item preview if contentHtml exists.
                                // We might want to default to a specific radio or log an unhandled type.
                                // For now, we'll let handleModeChange decide based on `modeImageLabelRadio.checked`, etc.
                                // but ideally, every known itemType should have a corresponding radio button logic.
                                // Let's assume for now that if it's in this `else if (contentHtml)` block,
                                // and not one of the specific text types, it's an older/generic item.
                                // The `handleModeChange` will then determine active inputs based on which radio *is* checked.
                                // This path is less ideal. It's better if every `itemType` maps to a specific radio.
                                // However, your `handleModeChange` has a final `else` for `modeGapFillRadio` if nothing else matches.
                                console.warn(`No specific radio button logic for itemType: ${itemType} in standard text loading. Defaulting behavior.`);
                                // To be safe, if no specific radio is selected, ensure the default one is and then call handleModeChange
                                if (!document.querySelector('input[name="generatorMode"]:checked')) {
                                    modeGapFillRadio.checked = true; // Fallback if nothing got checked
                                }
                            }
                             console.log(`IMMEDIATELY BEFORE handleModeChange(true, ${currentItemIdInPreview}) - currentItemIdInPreview IS: ${currentItemIdInPreview} (Log B)`); 
                             const tempId = currentItemIdInPreview;
                             console.log("Value of tempId right before direct call:", tempId);
                             handleModeChange(true, tempId); // true to indicate loading, prevents ID reset
 
                             itemPreviewArea.innerHTML = contentHtml;
                             itemPreviewArea.style.display = 'block';
                             toggleEditButton.style.display = 'inline-block';
                             saveButton.style.display = 'inline-block';
                             addToSheetButton.style.display = 'inline-block';
 
                             toggleEditButton.disabled = false;
                             saveButton.disabled = false; // Allow re-saving (which will act as update)
                             addToSheetButton.disabled = false; // Allow adding to sheet
                             isEditingEnabled = false;
                             toggleEditButton.textContent = 'Enable Editing';
                             // saveButton.textContent = 'Update Item'; // Optional: change text
 
                         } else { // Should ideally not be reached if item has an ID and type
                             console.error(`Item data received for ID ${currentItemIdInPreview}, but content_html was missing for an unhandled type '${itemType}'.`);
                             itemPreviewArea.innerHTML = `<p style="color: red;">Error: Content missing or type unhandled for loaded item ${currentItemIdInPreview}.</p>`;
                             itemPreviewArea.style.display = 'block';
                         }
 
                         // Scroll to the relevant preview area after processing
                         let elementToScrollTo = itemPreviewArea; // Default
                         if (itemType === 'imageLabel') {
                             elementToScrollTo = imageLabelInputsDiv;
                         } else if (itemType && itemType.startsWith('keywords-')) {
                             elementToScrollTo = keywordsDefinitionsInputsDiv;
                         }
                         // Add other specific scroll targets if needed

                         if (elementToScrollTo && typeof elementToScrollTo.scrollIntoView === 'function') {
                             elementToScrollTo.scrollIntoView({ behavior: 'smooth', block: 'start' });
                         }
                         console.log(`Successfully finished processing loaded item ${currentItemIdInPreview}.`);
 
                     } else { // data.item was missing or null
                         throw new Error("Item data (data.item) was not found or was null in the server response.");
                     }

                    // --- END: NEW LOGIC PASTED INSIDE TRY ---

                 } catch (error) { // <------------------------------ START OF CATCH BLOCK
                     console.error(`Error loading item ${itemId}:`, error);
                     itemPreviewArea.innerHTML = `<p style="color: red;">Error loading item: ${error.message}</p>`;
                     toggleEditButton.disabled = true;
                     saveButton.disabled = true;
                     addToSheetButton.disabled = true;
                 } finally { // <----------------------------------- FINALLY BLOCK (Now correctly placed)
                     libraryOutput.querySelectorAll('.load-item-button').forEach(btn => btn.disabled = false);
                 }
             } // End if target is load-item-button
         }); // End libraryOutput listener
        clearSheetButton.addEventListener('click', () => {
    // Ask for confirmation
    if (confirm("Are you sure you want to clear all items from the worksheet assembly area?")) {
        // Reset the innerHTML to the placeholder text
        worksheetAssemblyArea.innerHTML = '<p style="color: grey; font-style: italic;">Items added to the worksheet will appear here.</p>';
        console.log("Worksheet assembly area cleared.");
    }
});


        // --- Initialization ---
        handleModeChange(); // Call once on load to set initial state
let resizeTimeout;
    window.addEventListener('resize', () => {
        // Clear the previous timeout if resize happens quickly
        clearTimeout(resizeTimeout);
        // Set a new timeout to run the update function after a short delay
        resizeTimeout = setTimeout(updateWorksheetLabels, 150); // 150ms delay, adjust if needed
    });
    </script>
</body>
</html>


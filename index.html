<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Worksheet Generator</title>
    <style>
        /* Styles for structured output */
        .worksheet-section { border: 1px solid #e0e0e0; padding: 10px 15px; margin-bottom: 15px; background-color: #fff; border-radius: 4px; }
        .worksheet-section h3 { margin-top: 0; margin-bottom: 10px; border-bottom: 1px solid #ccc; padding-bottom: 5px; }
        .editable-content { outline: 1px dashed blue; background-color: #f0f8ff; cursor: text; padding: 2px 4px; min-height: 1em; border-radius: 2px;}
        #itemPreviewArea p, #itemPreviewArea li { margin-bottom: 0.5em; }
        #libraryOutput li { border-bottom: 1px dashed #eee; margin-bottom: 10px; padding-bottom: 10px; } /* Style library list */
        /* Basic styling */
        body { font-family: sans-serif; padding: 20px; background-color: #f0f0f0; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="text"], input[type="url"], input[type="number"], select, textarea { width: 100%; max-width: 450px; padding: 8px; margin-bottom: 15px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px;} /* Added textarea */
        button { padding: 10px 15px; cursor: pointer; margin-bottom: 15px; margin-left: 5px; border: none; border-radius: 4px; background-color: #007bff; color: white; font-size: 1em;}
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        button#toggleEditButton { background-color: #ffc107; color: black; }
        button#saveButton { background-color: #28a745; }
        button#loadLibraryButton { background-color: #6c757d; }
        #itemPreviewArea { margin-top: 10px; border: 1px solid #ccc; padding: 15px; white-space: pre-wrap; background-color: #fdfdfd; min-height: 150px; border-radius: 4px;}
        #libraryOutput { border: 1px solid #ccc; padding: 15px; background-color: #fff; min-height: 100px; border-radius: 4px; margin-top: 10px; }
        .loading { font-style: italic; color: grey; }
        .hidden { display: none; }
        fieldset { border: 1px solid #ccc; padding: 15px; margin-bottom: 15px; border-radius: 4px; background-color: #fff;}
        legend { font-weight: bold; padding: 0 5px; }
        h1, h2 { color: #333; margin-top: 25px; margin-bottom: 10px;}
        h1:first-of-type { margin-top: 0; }
        hr { margin: 30px 0; border: 0; border-top: 1px solid #ccc; }
        /* Style radio labels */
        fieldset div label { display: inline; font-weight: normal; margin-left: 5px; }
        fieldset div input[type="checkbox"] + label { display: inline; font-weight: normal;} /* Style checkbox label */
    </style>
</head>
<body>
    <h1>AI Worksheet Generator</h1>

    <!-- ======================= -->
    <!-- Section 1: LOAD LIBRARY -->
    <!-- ======================= -->
    <h2>Saved Item Library</h2>
    <button id="loadLibraryButton">Load Saved Items</button>
    <div id="libraryOutput">
        Click "Load Saved Items" to view your library.
    </div>
    <!-- ** ADDED SAVED WORKSHEETS SECTION ** -->
    <h2 style="margin-top: 30px;">Saved Worksheets</h2>
    <button id="loadWorksheetsButton" style="background-color: #6c757d;">Load Worksheet List</button>
    <div id="savedWorksheetsList" style="border: 1px solid #ccc; padding: 15px; background-color: #fff; min-height: 80px; border-radius: 4px; margin-top: 10px;">
        Click "Load Worksheet List" to view saved worksheets.
    </div>

    <hr>

    <!-- ========================== -->
    <!-- Section 2: GENERATE NEW    -->
    <!-- ========================== -->
    <h2>Generate New Item</h2>
    <!-- Mode Selection -->
    <fieldset>
        <legend>Select Generator Type</legend>
        <div><input type="radio" id="modeGapFill" name="generatorMode" value="gapFill" checked><label for="modeGapFill">Gap-Fill</label></div>
        <div><input type="radio" id="modeTextBlock" name="generatorMode" value="textBlock"><label for="modeTextBlock">Text Block</label></div>
        <div><input type="radio" id="modePastedText" name="generatorMode" value="pastedText"><label for="modePastedText">Pasted Text Comp</label></div>
        <div><input type="radio" id="modeMcq" name="generatorMode" value="mcq"><label for="modeMcq">Multiple Choice</label></div>
        <div><input type="radio" id="modeTrueFalse" name="generatorMode" value="trueFalse"><label for="modeTrueFalse">True/False</label></div>
        <div><input type="radio" id="modeShortAnswer" name="generatorMode" value="shortAnswer"><label for="modeShortAnswer">Short Answer</label></div>
        <!-- ** ADD THIS DIV ** -->
        <div>
            <input type="radio" id="modeSimilarQ" name="generatorMode" value="similarQ">
            <label for="modeSimilarQ">Similar Calculation Problems</label>
        </div>
        <div><input type="radio" id="modeWordSearch" name="generatorMode" value="wordSearch"><label for="modeWordSearch">Word Search (from Topic)</label></div>
        <div><input type="radio" id="modeKeywordsDefinitionsRadio" name="generatorMode" value="keywordsDefinitions"><label for="modeKeywordsDefinitionsRadio">Keywords & Definitions</label></div>
        <div><input type="radio" id="modeSimilarWrittenQ" name="generatorMode" value="similarWrittenQ"><label for="modeSimilarWrittenQ">Similar Written Questions</label></div>
    </fieldset>

    <!-- Inputs for Gap Fill (Should be visible by default) -->
    <div id="gapFillInputs">
        <fieldset>
            <legend>Gap-Fill Options</legend>
            <div> <label for="topicInput">Enter Topic:</label> <input type="text" id="topicInput" placeholder="e.g., Photosynthesis"> </div>
            <div> <label for="gradeLevelSelect">Grade Level:</label> <select id="gradeLevelSelect" name="grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div><div>
                <label for="gfNumSentencesInput">Number of Sentences (Gaps):</label>
                <input type="number" id="gfNumSentencesInput" value="7" min="3" max="15"> <!-- Default 7, min 3, max 15 -->
            </div>
        </fieldset>
    </div>

    <!-- ** MODIFIED SECTION for Pasted Text ** -->
    <div id="pastedTextInputs" class="hidden"> <!-- Renamed ID -->
        <fieldset>
            <legend>Pasted Text Comprehension Options</legend> <!-- Changed Legend -->
            <!-- YouTube URL Input REMOVED -->
            <div> <!-- Added Textarea -->
                <label for="pastedTextInputArea">Paste Text Here:</label>
                <textarea id="pastedTextInputArea" rows="10" style="width: 100%; max-width: 450px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; padding: 8px;" placeholder="Paste the text you want questions generated for...eg youtube transcript"></textarea>
            </div>
            <div>
                <label for="ptNumQuestionsInput">Number of Questions:</label> <!-- Renamed for attribute -->
                <input type="number" id="ptNumQuestionsInput" value="5" min="2" max="15"> <!-- Renamed ID -->
            </div>
        </fieldset>
    </div>

    <!-- Inputs for Multiple Choice -->
    <div id="mcqInputs" class="hidden">
        <fieldset>
            <legend>Multiple Choice Options</legend>
            <div> <label for="mcqTopicInput">Enter Topic:</label> <input type="text" id="mcqTopicInput" placeholder="e.g., Mitochondria"> </div>
            <div> <label for="mcqGradeLevelSelect">Grade Level:</label> <select id="mcqGradeLevelSelect" name="mcq_grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div>
            <div> <label for="mcqNumQuestionsInput">Number of Questions:</label> <input type="number" id="mcqNumQuestionsInput" value="5" min="2" max="15"> </div>
        </fieldset>
    </div>

    <!-- Inputs for True/False -->
    <div id="trueFalseInputs" class="hidden">
        <fieldset>
            <legend>True/False Options</legend>
            <div> <label for="tfTopicInput">Enter Topic:</label> <input type="text" id="tfTopicInput" placeholder="e.g., The Roman Empire"> </div>
            <div> <label for="tfGradeLevelSelect">Grade Level:</label> <select id="tfGradeLevelSelect" name="tf_grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div>
            <div> <label for="tfNumStatementsInput">Number of Statements:</label> <input type="number" id="tfNumStatementsInput" value="8" min="3" max="20"> </div>
        </fieldset>
    </div>

    <!-- Inputs for Short Answer -->
    <div id="shortAnswerInputs" class="hidden">
        <fieldset>
            <legend>Short Answer Options</legend>
            <div> <label for="saTopicInput">Enter Topic:</label> <input type="text" id="saTopicInput" placeholder="e.g., Climate Change"> </div>
            <div> <label for="saGradeLevelSelect">Grade Level:</label> <select id="saGradeLevelSelect" name="sa_grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div>
            <div> <label for="saNumQuestionsInput">Number of Questions:</label> <input type="number" id="saNumQuestionsInput" value="5" min="2" max="10"> </div>
        </fieldset>
    </div>

    <!-- Inputs for Text Block -->
    <div id="textBlockInputs" class="hidden">
        <fieldset>
            <legend>Text Block Options</legend>
             <div> <input type="checkbox" id="tbGenerateTextCheckbox" name="tb_generate_text" checked style="display: inline; width: auto; margin-bottom: 10px;"> <label for="tbGenerateTextCheckbox">Generate text using AI?</label> </div>
             <div id="tbTopicInputDiv"> <label for="tbTopicInput">Topic (for AI generation):</label> <input type="text" id="tbTopicInput" placeholder="e.g., The Importance of Bees"> </div>
             <div> <label for="tbGradeLevelSelect">Grade Level (for AI generation):</label> <select id="tbGradeLevelSelect" name="tb_grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div>
             <div> <label for="tbDirectInput">Or Enter/Edit Your Text Directly:</label> <textarea id="tbDirectInput" rows="8" placeholder="Type your instructions or text here..."></textarea> </div>
        </fieldset>
    </div>
 
 <!-- ** ADD THIS NEW INPUT SECTION ** -->
 <div id="similarQInputs" class="hidden">
     <fieldset>
         <legend>Similar Questions Options</legend>
         <div>
             <label for="sqExampleInput">Paste Example Question Here:</label>
             <textarea id="sqExampleInput" rows="6" style="width: 100%; max-width: 450px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; padding: 8px;" placeholder="Paste the question you want similar versions of..."></textarea>
         </div>
         <div>
             <label for="sqNumQuestionsInput">Number of Similar Questions:</label>
             <input type="number" id="sqNumQuestionsInput" value="3" min="1" max="10"> <!-- Default 3 -->
         </div>
         <div>
             <label for="sqGradeLevelSelect">Target Grade Level (Optional):</label>
             <select id="sqGradeLevelSelect" name="sq_grade_level">
                 <option value="Not Specified" selected>Not Specified</option> <!-- Add default option -->
                 <option value="elementary school">Elementary</option>
                 <option value="middle school">Middle</option>
                 <option value="high school">High</option>
                 <option value="university">University</option>
                 <option value="general adult">Adult</option>
             </select>
         </div>
         <!-- Add checkboxes for variations here later if desired -->
         <!-- Example:
         <div>
             <input type="checkbox" id="sqAllowUnits" name="sq_allow_units" style="display: inline; width: auto;">
             <label for="sqAllowUnits">Allow Unit Conversions?</label>
         </div>
          -->
     </fieldset>
 </div>
 <!-- ** END OF NEW INPUT SECTION ** -->
  <!-- Inputs for Word Search (Initially Hidden) -->
  <div id="wordSearchInputs" class="hidden">
    <fieldset>
        <legend>Word Search Options</legend>
        <!-- Start with Topic/Grade to generate word list -->
        <div> <label for="wsTopicInput">Enter Topic:</label> <input type="text" id="wsTopicInput" placeholder="e.g., Ancient Egypt"> </div>
        <div> <label for="wsGradeLevelSelect">Grade Level:</label>
            <select id="wsGradeLevelSelect" name="ws_grade_level">
                <option value="elementary school">Elementary</option>
                <option value="middle school" selected>Middle</option>
                <option value="high school">High</option>
                <option value="university">University</option>
                <option value="general adult">Adult</option>
            </select>
         </div>
         <!-- Word list editor and size select will be added here dynamically by JS -->
         <div id="wordSearchDynamicControls"></div>
    </fieldset>
</div>
<div class="generator-mode hidden" id="keywordsDefinitionsInputs">
    <h2>Keywords & Definitions</h2>
    <div class="input-group">
        <label for="keywordsTopic">Topic:</label>
        <input type="text" id="keywordsTopic" placeholder="e.g., Photosynthesis, Solar System">
    </div>
    <div class="input-group">
        <div class="input-group">
            <label for="keywordsGradeLevelSelect">Grade Level:</label> <!-- Changed ID -->
            <select id="keywordsGradeLevelSelect" name="keywords_grade_level"> <!-- Changed ID and added name -->
                <option value="elementary school">Elementary</option>
                <option value="middle school" selected>Middle</option> <!-- Default selected -->
                <option value="high school">High</option>
                <option value="university">University</option>
                <option value="general adult">Adult</option>
            </select>
        </div>
    </div>
    <div class="input-group">
        <label for="keywordsNum">Number of Keywords (Optional):</label>
        <input type="number" id="keywordsNum" placeholder="Default: 10" min="1" max="25"> <!-- Added min/max -->
    </div>
    <button id="generateKeywordsBtn">Generate Keywords</button>
    <hr>

    <!-- Area to display results and controls -->
    <div id="keywordsPreviewArea" style="display: none;"> <!-- Initially hidden -->
        <h3>Generated Keywords/Definitions</h3>

        <!-- Activity Selection Controls -->
        <div id="keywordsActivitySelector" style="margin-bottom: 15px;">
            <label>Select Activity Type:</label><br>
            <input type="radio" id="activityRefTable" name="keywordActivity" value="reference" checked>
            <label for="activityRefTable">Reference Table</label><br>
            <input type="radio" id="activityMatch" name="keywordActivity" value="matching">
            <label for="activityMatch">Matching Activity</label><br>
            <input type="radio" id="activityDefsOnly" name="keywordActivity" value="definitions">
            <label for="activityDefsOnly">Definitions Only</label><br>
            <input type="radio" id="activityKeywordsOnly" name="keywordActivity" value="keywords">
            <label for="activityKeywordsOnly">Keywords Only</label><br>
        </div>

        <!-- The actual generated activity output will go here -->
        <div id="activityOutput" class="worksheet-preview-content" style="border: 1px dashed #ccc; padding: 10px; margin-bottom:10px;">
            <!-- Content generated by JS -->
        </div>

        <!-- Add controls similar to other generators -->
        <button id="addKeywordsToWorksheetBtn">Add to Worksheet</button>
        <button id="saveKeywordsItemBtn">Save Item to Library</button>
        <span id="keywordsItemIdDisplay" class="item-id-display"></span> <!-- To show saved item ID -->
        <p id="keywordsStatus" class="status-message"></p> <!-- For loading/error messages -->

    </div> <!-- End keywordsPreviewArea -->

</div>
<div id="similarWrittenQInputs" class="generator-mode hidden"> <!-- Added generator-mode class too -->
    <fieldset>
        <legend>Similar Written Questions Options</legend>
        <div>
            <label for="swqExampleInput">Paste Example Written Question:</label>
            <textarea id="swqExampleInput" rows="6" placeholder="Paste the question you want variations of..."></textarea> <!-- Inherit styling -->
        </div>
        <div>
            <label for="swqNumQuestionsInput">Number of Similar Questions:</label>
            <input type="number" id="swqNumQuestionsInput" value="3" min="1" max="10">
        </div>
        <div>
            <label for="swqGradeLevelSelect">Target Grade Level:</label>
            <select id="swqGradeLevelSelect" name="swq_grade_level">
                <option value="elementary school">Elementary</option>
                <option value="middle school" selected>Middle</option>
                <option value="high school">High</option>
                <option value="university">University</option>
                <option value="general adult">Adult</option>
                <option value="Not Specified">Not Specified</option> <!-- Optional -->
            </select>
        </div>
    </fieldset>
</div>
    <!-- Generate Button -->
    <button id="generateButton">Generate New</button>

    <hr>

    <!-- ================================== -->
    <!-- Section 3: GENERATED OUTPUT/EDITOR -->
    <!-- ================================== -->
    <button id="saveButton" style="float: right;" disabled>Save to Library</button>
    <button id="toggleEditButton" style="float: right;" disabled>Enable Editing</button>
    <button id="addToSheetButton" style="float: right; background-color: #17a2b8;" disabled>Add Item to Worksheet</button>
    <h2 style="clear: both;">Item preview / Editor</h2>
    <div id="itemPreviewArea"> Generated/loaded item will appear here for preview/editing. </div>
    <hr>
    <h2>Worksheet Assembly Area</h2>
    <div style="margin-bottom: 15px; background-color: #fff; padding: 10px; border-radius: 4px; border: 1px solid #ccc;">
        <label for="worksheetTitleInput" style="display: inline-block; margin-right: 10px;">Worksheet Title:</label>
        <input type="text" id="worksheetTitleInput" placeholder="Enter a title for this worksheet" style="display: inline-block; width: auto; max-width: 300px; margin-bottom: 0;">
        <button id="saveWorksheetButton" style="background-color: #28a745; margin-left: 15px; float: right;">Save This Worksheet</button>
        <div style="clear: both;"></div> <!-- Clear float -->
    </div>
<button id="clearSheetButton" style="background-color: #dc3545;">Clear Worksheet</button> <!-- Added Clear Button -->
<div id="worksheetAssemblyArea" style="border: 2px dashed #6c757d; padding: 20px; background-color: #e9ecef; min-height: 300px; margin-top: 15px;">
    <!-- Items added to the worksheet will appear here -->
    <p style="color: grey; font-style: italic;">Items added to the worksheet will appear here.</p>
</div>

    <script>
        // --- Get Element References (Consolidated) ---
        const modeGapFillRadio = document.getElementById('modeGapFill');
        const modePastedTextRadio = document.getElementById('modePastedText');
        const modeMcqRadio = document.getElementById('modeMcq');
        const modeTrueFalseRadio = document.getElementById('modeTrueFalse');
        const modeShortAnswerRadio = document.getElementById('modeShortAnswer');
        const modeTextBlockRadio = document.getElementById('modeTextBlock');
        const modeSimilarQRadio = document.getElementById('modeSimilarQ');
        const gapFillInputsDiv = document.getElementById('gapFillInputs');
        const pastedTextInputsDiv = document.getElementById('pastedTextInputs');
        const mcqInputsDiv = document.getElementById('mcqInputs');
        const trueFalseInputsDiv = document.getElementById('trueFalseInputs');
        const shortAnswerInputsDiv = document.getElementById('shortAnswerInputs');
        const textBlockInputsDiv = document.getElementById('textBlockInputs');
        const similarQInputsDiv = document.getElementById('similarQInputs');
        const modeWordSearchRadio = document.getElementById('modeWordSearch');
        const wordSearchInputsDiv = document.getElementById('wordSearchInputs');
        const wordSearchDynamicControls = document.getElementById('wordSearchDynamicControls');
        const keywordsDefinitionsInputsDiv = document.getElementById('keywordsDefinitionsInputs');
        const topicInput = document.getElementById('topicInput');
        const gradeLevelSelect = document.getElementById('gradeLevelSelect');
        const gfNumSentencesInput = document.getElementById('gfNumSentencesInput');
        const ptNumQuestionsInput = document.getElementById('ptNumQuestionsInput');
        const pastedTextInputArea = document.getElementById('pastedTextInputArea');
        const mcqTopicInput = document.getElementById('mcqTopicInput');
        const mcqGradeLevelSelect = document.getElementById('mcqGradeLevelSelect');
        const mcqNumQuestionsInput = document.getElementById('mcqNumQuestionsInput');

        const tfTopicInput = document.getElementById('tfTopicInput');
        const tfGradeLevelSelect = document.getElementById('tfGradeLevelSelect');
        const tfNumStatementsInput = document.getElementById('tfNumStatementsInput');

        const saTopicInput = document.getElementById('saTopicInput');
        const saGradeLevelSelect = document.getElementById('saGradeLevelSelect');
        const saNumQuestionsInput = document.getElementById('saNumQuestionsInput');

        const tbGenerateTextCheckbox = document.getElementById('tbGenerateTextCheckbox');
        const tbTopicInputDiv = document.getElementById('tbTopicInputDiv');
        const tbTopicInput = document.getElementById('tbTopicInput');
        const tbGradeLevelSelect = document.getElementById('tbGradeLevelSelect');
        const tbDirectInput = document.getElementById('tbDirectInput');
        const sqExampleInput = document.getElementById('sqExampleInput');
        const sqNumQuestionsInput = document.getElementById('sqNumQuestionsInput');
        const sqGradeLevelSelect = document.getElementById('sqGradeLevelSelect');
        const generateButton = document.getElementById('generateButton');
        const loadLibraryButton = document.getElementById('loadLibraryButton');
        const itemPreviewArea = document.getElementById('itemPreviewArea');
        const addToSheetButton = document.getElementById('addToSheetButton');
        const worksheetAssemblyArea = document.getElementById('worksheetAssemblyArea');
        const clearSheetButton = document.getElementById('clearSheetButton');
        const worksheetTitleInput = document.getElementById('worksheetTitleInput');
        const libraryOutput = document.getElementById('libraryOutput');
        const toggleEditButton = document.getElementById('toggleEditButton');
        const saveButton = document.getElementById('saveButton');

        // --- State Variables ---
        let isEditingEnabled = false;
        let currentPreviewItemId = null; // Store ID of item in preview
        // --- START: Keywords & Definitions Globals/Constants ---
// Store the raw data fetched from the backend
let currentKeywordData = [];
let currentKeywordsItemId = null; // To track if the previewed item came from the library

// Get refs for elements INSIDE the keywordsDefinitionsInputs div
const generateKeywordsBtn = document.getElementById('generateKeywordsBtn');
const keywordsPreviewArea = document.getElementById('keywordsPreviewArea');
const keywordsTopicInput = document.getElementById('keywordsTopic');
const keywordsGradeLevelSelect = document.getElementById('keywordsGradeLevelSelect');
const keywordsNumInput = document.getElementById('keywordsNum');
const keywordsStatus = document.getElementById('keywordsStatus');
const activityOutput = document.getElementById('activityOutput');
const activitySelector = document.getElementById('keywordsActivitySelector'); // Container for radio buttons
const addKeywordsToWorksheetBtn = document.getElementById('addKeywordsToWorksheetBtn');
const saveKeywordsItemBtn = document.getElementById('saveKeywordsItemBtn');
const keywordsItemIdDisplay = document.getElementById('keywordsItemIdDisplay');
const modeKeywordsDefinitionsRadio = document.getElementById('modeKeywordsDefinitionsRadio'); // Ref for the radio button
const modeSimilarWrittenQRadio = document.getElementById('modeSimilarWrittenQ');
const similarWrittenQInputsDiv = document.getElementById('similarWrittenQInputs');
const swqExampleInput = document.getElementById('swqExampleInput');
const swqNumQuestionsInput = document.getElementById('swqNumQuestionsInput');
const swqGradeLevelSelect = document.getElementById('swqGradeLevelSelect');
// --- END: Keywords & Definitions Globals/Constants ---
        // --- Helper Functions ---
        
        // Handles showing/hiding topic input for Text Block mode
        function handleTbCheckboxChange() {
            if (tbGenerateTextCheckbox.checked) {
                tbTopicInputDiv.classList.remove('hidden');
            } else {
                tbTopicInputDiv.classList.add('hidden');
            }
        }

        // ** FIXED handleModeChange Function **
        function handleModeChange(isLoadingItem = false) {
            console.log("--- handleModeChange START ---");
            if (!isLoadingItem) { // Only reset ID if NOT loading
    currentItemIdInPreview = null; // Use your consolidated variable name here
    console.log("handleModeChange: ID reset to null");
} else {
    console.log("handleModeChange: Skipping ID reset during load.");
}
            console.log("handleModeChange: currentPreviewItemId reset to null");

            // --- Hide all input sections first ---
            gapFillInputsDiv.classList.add('hidden');
            pastedTextInputsDiv.classList.add('hidden');
            mcqInputsDiv.classList.add('hidden');
            trueFalseInputsDiv.classList.add('hidden');
            shortAnswerInputsDiv.classList.add('hidden');
            textBlockInputsDiv.classList.add('hidden');
            similarQInputsDiv.classList.add('hidden');
            wordSearchInputsDiv.classList.add('hidden');
            keywordsDefinitionsInputsDiv.classList.add('hidden');
            similarWrittenQInputsDiv.classList.add('hidden');
            // Clear dynamic area if it exists from previous mode
            if (wordSearchDynamicControls) {
                 wordSearchDynamicControls.innerHTML = '';
            }

            // --- Reset main generate button state ---
            generateButton.textContent = 'Generate New';
            generateButton.disabled = false; // Re-enable if it was disabled

            // --- Show the selected input section ---
            if (modeTextBlockRadio.checked) {
                console.log("Mode detected: Text Block");
                textBlockInputsDiv.classList.remove('hidden');
                handleTbCheckboxChange(); // Call helper for checkbox state
            } else if (modePastedTextRadio.checked) {
                 console.log("Mode detected: Pasted Text");
                 pastedTextInputsDiv.classList.remove('hidden');
            } else if (modeMcqRadio.checked) {
                console.log("Mode detected: MCQ");
                mcqInputsDiv.classList.remove('hidden');
            } else if (modeTrueFalseRadio.checked) {
                console.log("Mode detected: True/False");
                trueFalseInputsDiv.classList.remove('hidden');
            } else if (modeShortAnswerRadio.checked) {
                console.log("Mode detected: Short Answer");
                shortAnswerInputsDiv.classList.remove('hidden');
            } else if (modeSimilarQRadio.checked) {
                console.log("Mode detected: Similar Questions");
                similarQInputsDiv.classList.remove('hidden');
            } else if (modeWordSearchRadio.checked) { // Line ~360
                console.log("Mode detected: Word Search");
                wordSearchInputsDiv.classList.remove('hidden');
                generateButton.textContent = 'Get Word List';
            } else if (modeKeywordsDefinitionsRadio.checked) { // Use the new radio button ID
                console.log("Mode detected: Keywords/Definitions");
                keywordsDefinitionsInputsDiv.classList.remove('hidden');
                generateButton.textContent = 'Generate New'; // Main button not used for this mode
                generateButton.disabled = true; // Disable main button for this mode
            }
            else if (modeSimilarWrittenQRadio.checked) {
                console.log("Mode detected: Similar Written Questions");
                similarWrittenQInputsDiv.classList.remove('hidden');
                generateButton.textContent = 'Generate New'; // Use main button
                generateButton.disabled = false; // Enable main button
            }
            else { // Default case (Gap Fill)
                console.log("Mode detected: Default (Gap Fill)");
                gapFillInputsDiv.classList.remove('hidden');
                generateButton.textContent = 'Generate New'; // Reset text
                generateButton.disabled = false; // Ensure enabled
            }
            
            // --- End of showing selected section ---

            // --- Reset output area and editor/action buttons ---
            // This happens regardless of which mode was selected
            itemPreviewArea.innerHTML = 'Enter details for the selected mode and click Generate.';
            toggleEditButton.disabled = true;
            saveButton.disabled = true;
            addToSheetButton.disabled = true;
            toggleEditButton.textContent = 'Enable Editing';
            if (isEditingEnabled) { // If editing was left on from previous item
                itemPreviewArea.style.border = '1px solid #ccc'; // Reset border
                isEditingEnabled = false; // Reset editing state flag
            }

            console.log("--- handleModeChange END ---");
        }


    // Reset output and buttons
    itemPreviewArea.innerHTML = 'Enter details for the selected mode and click Generate.';
    toggleEditButton.disabled = true;
    saveButton.disabled = true;
    addToSheetButton.disabled = true;
    toggleEditButton.textContent = 'Enable Editing';
    if (isEditingEnabled) {
        itemPreviewArea.style.border = '1px solid #ccc';
        isEditingEnabled = false;
    }


        // --- Parsing Functions (Keep all 6 definitions) ---
        function parseAndStructureGapFill(rawText) { /* ... Full function ... */
             const keyIdentifier = "Answer Key:"; const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im')); let contentPart = rawText; let keyPart = ""; let structuredHtml = "";
            if (keyIndex !== -1) { contentPart = rawText.substring(0, keyIndex).trim(); keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim(); } else { console.warn("Could not find 'Answer Key:' separator."); return `<div class="worksheet-section"><h3>Worksheet (Format Issue?)</h3><div>${contentPart.replace(/\n/g, '<br>')}</div></div>`; }
            const sentences = contentPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="gap-fill-sentences"><h3>Worksheet Sentences</h3>'; sentences.forEach((sentence, index) => { structuredHtml += `<p data-index="${index}">${sentence.trim()}</p>`; }); structuredHtml += '</div>';
            const answers = keyPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="gap-fill-answers"><h3>Answer Key</h3><ol>'; answers.forEach((answerLine) => { const cleanedAnswer = answerLine.replace(/^\d+\.\s*/, '').trim(); if (cleanedAnswer) { structuredHtml += `<li>${cleanedAnswer}</li>`; } }); structuredHtml += '</ol></div>'; return structuredHtml;
         }
        function parseAndStructureQuestions(rawText) { /* ... Full function ... */
             const questions = rawText.split('\n').filter(line => line.trim() !== ''); let structuredHtml = '<div class="worksheet-section" id="comprehension-questions"><h3>Comprehension Questions</h3><ol>'; questions.forEach((questionLine) => { const cleanedQuestion = questionLine.replace(/^\d+\.\s*/, '').trim(); if (cleanedQuestion) { structuredHtml += `<li>${cleanedQuestion}</li>`; } }); structuredHtml += '</ol></div>'; return structuredHtml;
        }
        function parseAndStructureMCQ(rawText) { /* ... Full function ... */
            const keyIdentifier = "Answer Key:"; const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im')); let questionsPart = rawText; let keyPart = ""; let structuredHtml = "";
            if (keyIndex !== -1) { questionsPart = rawText.substring(0, keyIndex).trim(); keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim(); } else { console.warn("Could not find 'Answer Key:' separator for MCQs."); return `<div class="worksheet-section"><h3>Questions (Format Issue?)</h3><div>${questionsPart.replace(/\n/g, '<br>')}</div></div>`; }
            structuredHtml += '<div class="worksheet-section" id="mcq-questions"><h3>Multiple Choice Questions</h3>'; const lines = questionsPart.split('\n').filter(line => line.trim() !== ''); let currentQuestionNumber = 0;
            lines.forEach(line => { line = line.trim(); const questionMatch = line.match(/^(\d+)\.\s*(.*)/); const optionMatch = line.match(/^[A-D]\.\s*(.*)/i); if (questionMatch) { currentQuestionNumber = parseInt(questionMatch[1], 10); if (currentQuestionNumber > 1) { structuredHtml += '</ul>'; } structuredHtml += `<p><strong>${questionMatch[1]}. ${questionMatch[2]}</strong></p><ul style="list-style: upper-alpha; margin-left: 20px;">`; } else if (optionMatch) { structuredHtml += `<li>${optionMatch[1]}</li>`; } else if (line) { structuredHtml += `<div>${line}</div>`; } }); if (currentQuestionNumber > 0) { structuredHtml += '</ul>'; } structuredHtml += '</div>';
            const answers = keyPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="mcq-answers"><h3>Answer Key</h3><ol>'; answers.forEach((answerLine) => { const cleanedAnswer = answerLine.trim().replace(/^\d+\.\s*/, ''); if(cleanedAnswer) { structuredHtml += `<li>${cleanedAnswer}</li>`; } }); structuredHtml += '</ol></div>'; return structuredHtml;
         }
        function parseAndStructureTrueFalse(rawText) { /* ... Full function ... */
            const keyIdentifier = "Answer Key:"; const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im')); let statementsPart = rawText; let keyPart = ""; let structuredHtml = "";
            if (keyIndex !== -1) { statementsPart = rawText.substring(0, keyIndex).trim(); keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim(); } else { console.warn("Could not find 'Answer Key:' separator for True/False."); return `<div class="worksheet-section"><h3>Statements (Format Issue?)</h3><div>${statementsPart.replace(/\n/g, '<br>')}</div></div>`; }
            const statements = statementsPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="tf-statements"><h3>True/False Statements</h3><ol>'; statements.forEach((statementLine) => { const cleanedStatement = statementLine.replace(/^\d+\.\s*/, '').trim(); if (cleanedStatement) { structuredHtml += `<li>${cleanedStatement}</li>`; } }); structuredHtml += '</ol></div>';
            const answers = keyPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="tf-answers"><h3>Answer Key</h3><ol>'; answers.forEach((answerLine) => { const cleanedAnswer = answerLine.trim().replace(/^\d+\.\s*/, ''); if(cleanedAnswer) { structuredHtml += `<li>${cleanedAnswer}</li>`; } }); structuredHtml += '</ol></div>'; return structuredHtml;
        }
        function parseAndStructureSimilarQuestions(rawText) {
        console.log("Parsing Similar Questions Text:", rawText.substring(0, 250) + "..."); // Log more context

        // Define markers more flexibly (case-insensitive, optional number/formatting)
        const analysisMarker = "Analysis of Example:"; // Keep this simple
        const questionsMarker = "New Similar Questions:"; // Look for this text after a number/bullet
        const keyMarker = "Answer Key:";

        let analysisPart = ""; // We'll extract but might not display
        let questionsPart = "";
        let keyPart = "";
        let parseSuccess = false;

        // Find indices using case-insensitive search and allowing flexibility
        const analysisIndex = rawText.search(new RegExp(analysisMarker, 'i'));
        // Look for the key marker first, as it should reliably be at the end
        const keyIndex = rawText.search(new RegExp(`^${keyMarker.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im'));

        if (keyIndex !== -1) {
            // If key is found, assume everything before it belongs to questions/analysis
            const beforeKey = rawText.substring(0, keyIndex).trim();
            keyPart = rawText.substring(keyIndex + keyMarker.length).trim();

            // Now try to find the start of the actual questions within the 'beforeKey' part
            // Look for the first line starting with "1." after the analysis section (if analysis exists)
            let questionStartIndex = -1;
            if (analysisIndex !== -1 && analysisIndex < keyIndex) {
                 // Find the end of the analysis block (next newline after analysis marker)
                 const analysisEndIndex = beforeKey.indexOf('\n', analysisIndex);
                 const potentialQuestionArea = analysisEndIndex !== -1 ? beforeKey.substring(analysisEndIndex) : beforeKey;
                 // Find the first "1." in that area
                 questionStartIndex = potentialQuestionArea.search(/^\s*1\.\s+/m);
                 if (questionStartIndex !== -1) {
                     questionStartIndex += (analysisEndIndex !== -1 ? analysisEndIndex : 0); // Adjust index relative to start of beforeKey
                     analysisPart = beforeKey.substring(analysisIndex + analysisMarker.length, questionStartIndex).trim();
                     questionsPart = beforeKey.substring(questionStartIndex).trim();
                     parseSuccess = true;
                 }
            } else {
                 // If no clear analysis marker, assume questions start near the beginning
                 questionStartIndex = beforeKey.search(/^\s*1\.\s+/m);
                 if (questionStartIndex !== -1) {
                     analysisPart = ""; // No analysis extracted
                     questionsPart = beforeKey.substring(questionStartIndex).trim();
                     parseSuccess = true;
                 }
            }

            if(parseSuccess) {
                 console.log("Successfully split SimilarQ into Questions/Key parts (Analysis optional).");
            }

        }

        // If parsing failed, use fallback
        if (!parseSuccess) {
            console.warn("Could not reliably split Similar Questions output. Displaying raw.");
            let fallbackHtml = rawText.replace(/\n/g, '<br>');
            // Try to hide analysis/key roughly if possible in fallback
             const keyIdxFallback = fallbackHtml.search(new RegExp(keyMarker,'i'));
             if(keyIdxFallback !== -1) fallbackHtml = fallbackHtml.substring(0, keyIdxFallback);
             const analysisIdxFallback = fallbackHtml.search(new RegExp(analysisMarker,'i'));
             if(analysisIdxFallback !== -1) fallbackHtml = fallbackHtml.substring(analysisIdxFallback + analysisMarker.length);

            return `<div class="worksheet-section"><h3>Similar Questions (Format Issue?)</h3><div>${fallbackHtml}</div></div>`;
        }
        
        let structuredHtml = "";

        // --- Display Questions Part ONLY ---
        // We are *not* adding the 'analysisPart' to the structuredHtml meant for the worksheet item
        const questions = questionsPart.split('\n').filter(line => line.trim() !== '' && !line.match(/^\d+\s+New Similar Questions:/i)); // Also filter out the title line
        structuredHtml += '<div class="worksheet-section" id="sq-questions"><h3>Generated Questions</h3>';
        structuredHtml += '<ol>';
        questions.forEach((questionLine) => {
            const cleanedQuestion = questionLine.replace(/^\d+\.\s*/, '').trim(); // Remove number
            if (cleanedQuestion) {
                structuredHtml += `<li>${cleanedQuestion}</li>`;
            }
        });
        structuredHtml += '</ol></div>'; // Close sq-questions div

        // --- Process and ADD Answer Key Part (Hidden by default later?) ---
        const answerLines = keyPart.split('\n').filter(line => line.trim() !== '');
        // Maybe hide this section by default later
        structuredHtml += '<div class="worksheet-section answer-key-container" id="sq-answers"><h3>Answer Key</h3>'; // Added answer-key-container class
        structuredHtml += '<ol>';
        let currentAnswerContent = ''; let currentQuestionNumber = null;
        answerLines.forEach((line, index) => {
            line = line.trim(); const numberMatch = line.match(/^(\d+)\.\s*(.*)/);
            if (numberMatch) {
                const questionNum = parseInt(numberMatch[1], 10); const content = numberMatch[2].trim();
                if (currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim().replace(/\n/g,'<br>')}</li>`; }
                currentQuestionNumber = questionNum; currentAnswerContent = content;
            } else if (currentQuestionNumber !== null && line) { currentAnswerContent += `\n<span style="margin-left: 15px;">${line}</span>`; }
            if (index === answerLines.length - 1 && currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim().replace(/\n/g,'<br>')}</li>`; }
        });
        structuredHtml += '</ol></div>'; // Close sq-answers div

        console.log("Finished parsing Similar Questions.");
        return structuredHtml;
    }
    function displayWordListEditor(wordListText) {
            // Find the container for dynamic controls within the word search input div
            const dynamicControlsContainer = document.getElementById('wordSearchDynamicControls');
            if (!dynamicControlsContainer) {
                console.error("Could not find wordSearchDynamicControls container!");
                return;
            }

            // Clear previous dynamic controls if any
            dynamicControlsContainer.innerHTML = '';

            // 1. Parse the word list text
            const words = wordListText.split('\n')
                .map(line => line.replace(/^\d+\.\s*/, '').trim()) // Remove numbering, trim whitespace
                .filter(word => word.length > 0); // Remove empty lines

            // 2. Create Textarea for editing
            const wordListLabel = document.createElement('label');
            wordListLabel.htmlFor = 'wordListEditArea';
            wordListLabel.textContent = 'Edit Word List (one word/phrase per line):';
            wordListLabel.style.marginTop = '15px'; // Add some top margin
            const wordListTextArea = document.createElement('textarea');
            wordListTextArea.id = 'wordListEditArea';
            wordListTextArea.rows = 10; // Adjust size as needed
            wordListTextArea.value = words.join('\n'); // Populate with one word per line
            // Inherit some basic styles if needed, otherwise rely on global styles
            wordListTextArea.style.maxWidth = '450px';
            wordListTextArea.style.width = '100%';

            // 3. Create Size Selector
            const sizeLabel = document.createElement('label');
            sizeLabel.htmlFor = 'wordSearchSizeSelect';
            sizeLabel.textContent = 'Select Grid Size:';
            sizeLabel.style.marginTop = '15px';
            const sizeSelect = document.createElement('select');
            sizeSelect.id = 'wordSearchSizeSelect';
            sizeSelect.style.marginBottom = '15px'; // Add bottom margin
            const sizes = { "small": "Small (~10x10)", "medium": "Medium (~13x13)", "large": "Large (~15x15)" };
            for (const [value, text] of Object.entries(sizes)) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = text;
                if (value === 'medium') option.selected = true; // Default selection
                sizeSelect.appendChild(option);
            }

            // 4. Create "Generate Grid" Button
            const generateGridButton = document.createElement('button');
            generateGridButton.id = 'generateGridButton';
            generateGridButton.textContent = 'Generate Word Search Grid';
            generateGridButton.style.marginLeft = '0'; // Override default button margin if needed

            // 5. Add Event Listener to the new button
            generateGridButton.addEventListener('click', handleGenerateGridClick);

            // 6. Append new elements to the container
            // Hide the original Topic/Grade inputs within the word search fieldset
            document.getElementById('wsTopicInput').parentElement.style.display = 'none';
            document.getElementById('wsGradeLevelSelect').parentElement.style.display = 'none';

            // Append the new controls
            dynamicControlsContainer.appendChild(wordListLabel);
            dynamicControlsContainer.appendChild(wordListTextArea);
            dynamicControlsContainer.appendChild(document.createElement('br')); // Spacing
            dynamicControlsContainer.appendChild(sizeLabel);
            dynamicControlsContainer.appendChild(sizeSelect);
            dynamicControlsContainer.appendChild(document.createElement('br')); // Spacing
            dynamicControlsContainer.appendChild(generateGridButton);

            console.log("Word list editor UI displayed.");
        }
        async function handleGenerateGridClick() {
            console.log(">>> Generate Grid button clicked <<<");

            // Disable button immediately
            const generateGridButton = document.getElementById('generateGridButton');
            if (generateGridButton) generateGridButton.disabled = true;

            // 1. Get words from textarea
            const wordListTextArea = document.getElementById('wordListEditArea');
            const wordsRaw = wordListTextArea.value.trim();
            const words = wordsRaw.split('\n')
                                .map(word => word.trim())
                                .filter(word => word.length > 0);

            if (words.length === 0) {
                alert("Word list is empty. Please enter words.");
                if (generateGridButton) generateGridButton.disabled = false;
                return;
            }

            // 2. Get selected size
            const sizeSelect = document.getElementById('wordSearchSizeSelect');
            const selectedSize = sizeSelect.value;

            // 3. Prepare payload for backend
            const payload = {
                word_list: words,
                size: selectedSize
                // Add allow_backwards or mask options here if you implement UI for them later
            };

            console.log("Sending payload to /generate_word_search_grid:", payload);
            itemPreviewArea.innerHTML = '<div class="loading">Generating grid...</div>'; // Show loading in preview
            toggleEditButton.disabled = true; saveButton.disabled = true; addToSheetButton.disabled = true; // Disable actions

            // 4. Fetch request to backend
            try {
                const response = await fetch('/generate_word_search_grid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                console.log("Received response from grid generation:", data);

                if (!response.ok) {
                    throw new Error(data.message || `HTTP error! status: ${response.status}`);
                }

                if (data.status === 'success' && data.content_html) {
                    itemPreviewArea.innerHTML = data.content_html; // Display grid HTML
                    // Grid generation successful - enable final actions
                    toggleEditButton.disabled = false; // Allow editing (though maybe less useful for grid?)
                    saveButton.disabled = false;    // Allow saving the generated item
                    addToSheetButton.disabled = false; // Allow adding to worksheet
                    // Optionally hide or keep the grid generation controls? Hiding for now.
                    // wordSearchDynamicControls.style.display = 'none';
                } else {
                    throw new Error(data.message || 'Grid generation failed on the server.');
                }

            } catch (error) {
                console.error("Error generating word search grid:", error);
                itemPreviewArea.innerHTML = `<p style="color: red;">Error generating grid: ${error.message}. Please check word lengths or grid size.</p>`;
                // Re-enable button on error
                if (generateGridButton) generateGridButton.disabled = false;
                // Keep main action buttons disabled
                toggleEditButton.disabled = true; saveButton.disabled = true; addToSheetButton.disabled = true;
            }
        }
        function parseAndStructurePastedComprehension(rawText) {
    console.log("Parsing Pasted Text Comprehension:", rawText.substring(0, 150) + "...");
    // This will be similar to Short Answer or MCQ parsing, expecting Questions + Key
    const keyIdentifier = "Answer Key:";
    const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im'));
    let questionsPart = rawText;
    let keyPart = "";
    let structuredHtml = "";

    if (keyIndex !== -1) {
        questionsPart = rawText.substring(0, keyIndex).trim();
        keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim();
        console.log("Split into Questions / Key parts for Pasted Text Comp");
    } else {
        console.warn("Could not find 'Answer Key:' separator for Pasted Text Comp. Treating all as questions.");
        keyPart = ""; // Assume no key if separator not found
    }

    // Process Questions Part
    const questions = questionsPart.split('\n').filter(line => line.trim() !== '');
    // We add a heading for the questions section
    structuredHtml += '<div class="worksheet-section" id="ptc-questions"><h3>Comprehension Questions</h3>';
    structuredHtml += '<ol>'; // Use ordered list for questions
    questions.forEach((questionLine) => {
        const cleanedQuestion = questionLine.replace(/^\d+\.\s*/, '').trim(); // Remove numbering
        if (cleanedQuestion) {
            structuredHtml += `<li>${cleanedQuestion}</li>`; // Add question as list item
        }
    });
    structuredHtml += '</ol></div>'; // Close ptc-questions div

    // Process Key Part (if found) - Reuse logic from Short Answer parser
    if (keyPart) {
        const answerLines = keyPart.split('\n').filter(line => line.trim() !== '');
        structuredHtml += '<div class="worksheet-section" id="ptc-answers"><h3>Answer Key</h3>';
        structuredHtml += '<ol>'; // Main ordered list for question numbers
        let currentAnswerContent = ''; let currentQuestionNumber = null;
        answerLines.forEach((line, index) => {
            line = line.trim(); const numberMatch = line.match(/^(\d+)\.\s*(.*)/);
            if (numberMatch) {
                const questionNum = parseInt(numberMatch[1], 10); const content = numberMatch[2].trim();
                if (currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim()}</li>`; }
                currentQuestionNumber = questionNum; currentAnswerContent = content;
            } else if (currentQuestionNumber !== null && line) { currentAnswerContent += `<br>   ${line}`; }
            if (index === answerLines.length - 1 && currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim()}</li>`; }
        });
        structuredHtml += '</ol></div>'; // Close ptc-answers div
    }

    console.log("Finished parsing Pasted Text Comprehension.");
    return structuredHtml;
    // NOTE: We are NOT displaying the original pasted text here, only the Qs & Key.
    // If you wanted to include the original text, you'd need to pass it to this function
    // or restructure how the output is built. For now, it just parses the AI response.
}
        function parseAndStructureShortAnswer(rawText) { /* ... Full function ... */
            const keyIdentifier = "Answer Key:"; const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im')); let questionsPart = rawText; let keyPart = ""; let structuredHtml = "";
            if (keyIndex !== -1) { questionsPart = rawText.substring(0, keyIndex).trim(); keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim(); } else { console.warn("Could not find 'Answer Key:' separator for Short Answer."); keyPart = ""; }
            const questions = questionsPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="sa-questions"><h3>Short Answer Questions</h3><ol>'; questions.forEach((questionLine) => { const cleanedQuestion = questionLine.replace(/^\d+\.\s*/, '').trim(); if (cleanedQuestion) { structuredHtml += `<li style="margin-bottom: 1.5em;">${cleanedQuestion}<br><span style="color: #999;">Answer: _______________</span></li>`; } }); structuredHtml += '</ol></div>';
            if (keyPart) { const answerLines = keyPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="sa-answers"><h3>Answer Key / Grading Points</h3><ol>'; let currentAnswerContent = ''; let currentQuestionNumber = null; answerLines.forEach((line, index) => { line = line.trim(); const numberMatch = line.match(/^(\d+)\.\s*(.*)/); if (numberMatch) { const questionNum = parseInt(numberMatch[1], 10); const content = numberMatch[2].trim(); if (currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim()}</li>`; } currentQuestionNumber = questionNum; currentAnswerContent = content; } else if (currentQuestionNumber !== null && line) { currentAnswerContent += `<br>${line}`; } if (index === answerLines.length - 1 && currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim()}</li>`; } }); structuredHtml += '</ol></div>'; }
            return structuredHtml;
        }
        function parseAndStructureTextBlock(rawText) { /* ... Full function ... */
             const formattedText = rawText.replace(/\n/g, '<br>'); let structuredHtml = `<div class="worksheet-section" id="text-block-generated"><h3>Text Block</h3><div>${formattedText}</div></div>`; return structuredHtml;
         }
        // --- END OF PARSING FUNCTIONS ---
// --- START: Keywords & Definitions Functions ---

// --- Fisher-Yates Shuffle Function (Helper) ---
function shuffleArray(array) {
    let currentIndex = array.length, randomIndex;
    // While there remain elements to shuffle.
    while (currentIndex !== 0) {
        // Pick a remaining element.
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        // And swap it with the current element.
        [array[currentIndex], array[randomIndex]] = [
            array[randomIndex], array[currentIndex]];
    }
    return array;
}

// --- Function to Display the Selected Keyword Activity ---
function displayKeywordActivity() {
    const selectedActivity = document.querySelector('input[name="keywordActivity"]:checked').value;
    if (!currentKeywordData || currentKeywordData.length === 0) {
        activityOutput.innerHTML = '<p>No keyword data available.</p>';
        return; // Nothing to display
    }

    let tableHTML = '<table class="keywords-table" style="width: 100%; border-collapse: collapse;">';
    let headerHTML = '';
    let tableBodyHTML = '';

    // Determine columns and potentially shuffle data based on activity type
    let displayData = [...currentKeywordData]; // Shallow copy to avoid modifying original
    let definitions = displayData.map(item => item.definition);
    let keywords = displayData.map(item => item.keyword);

    switch (selectedActivity) {
        case 'reference':
            headerHTML = '<thead><tr><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Keyword</th><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Definition</th></tr></thead>';
            displayData.forEach(item => {
                tableBodyHTML += `<tr><td style="border: 1px solid #ddd; padding: 8px;">${item.keyword}</td><td style="border: 1px solid #ddd; padding: 8px;">${item.definition}</td></tr>`;
            });
            break;

        case 'matching':
            headerHTML = '<thead><tr><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Keyword</th><th style="border: 1px solid #ddd; padding: 8px; width: 50px;"></th><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Definition</th></tr></thead>';
            let shuffledDefinitions = shuffleArray([...definitions]); // Shuffle a copy
            keywords.forEach((keyword, index) => {
                tableBodyHTML += `<tr><td style="border: 1px solid #ddd; padding: 8px;">${keyword}</td><td style="border: 1px solid #ddd; padding: 8px;"></td><td style="border: 1px solid #ddd; padding: 8px;">${shuffledDefinitions[index]}</td></tr>`;
            });
            break;

        case 'definitions':
            headerHTML = '<thead><tr><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Keyword</th><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Definition</th></tr></thead>';
             displayData.forEach(item => {
                tableBodyHTML += `<tr><td style="border: 1px solid #ddd; padding: 8px; height: 2.5em;"></td><td style="border: 1px solid #ddd; padding: 8px;">${item.definition}</td></tr>`; // Add height for writing space
            });
            break;

        case 'keywords':
            headerHTML = '<thead><tr><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Keyword</th><th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Definition</th></tr></thead>';
            displayData.forEach(item => {
                tableBodyHTML += `<tr><td style="border: 1px solid #ddd; padding: 8px;">${item.keyword}</td><td style="border: 1px solid #ddd; padding: 8px; height: 2.5em;"></td></tr>`; // Add height for writing space
            });
            break;

        default:
             activityOutput.innerHTML = '<p>Invalid activity type selected.</p>';
            return;
    }

    tableHTML += headerHTML + '<tbody>' + tableBodyHTML + '</tbody></table>';
    activityOutput.innerHTML = tableHTML;

    // --- Add Data Attributes for Saving/Export ---
    // Store raw data for potential use in saving/exporting
    activityOutput.dataset.keywords = JSON.stringify(currentKeywordData);
    activityOutput.dataset.activityType = selectedActivity; // Store which view is current

    // Make the preview editable (optional, maybe not needed for tables?)
    activityOutput.contentEditable = "false";
}
// --- END: Keywords & Definitions Functions ---// --- END OF PARSING FUNCTIONS ---
function addWorksheetItemControls(worksheetItemDiv) {    
    const controlsDiv = document.createElement('div');
    controlsDiv.style.marginBottom = '10px';
    controlsDiv.style.textAlign = 'right'; // Align buttons to the right

    // --- 2. Create Move Up Button ---
    const moveUpButton = document.createElement('button');
    moveUpButton.textContent = ' Up';
    moveUpButton.style.backgroundColor = '#6c757d'; // Grey
    moveUpButton.style.color = 'white';
    moveUpButton.style.padding = '3px 8px';
    moveUpButton.style.fontSize = '0.8em';
    moveUpButton.style.marginLeft = '5px';
    moveUpButton.title = 'Move item up';
    moveUpButton.onclick = () => {
        const currentItem = worksheetItemDiv;
        const previousItem = currentItem.previousElementSibling;
        if (previousItem && previousItem.classList.contains('worksheet-item')) {
            worksheetAssemblyArea.insertBefore(currentItem, previousItem);
            console.log("Moved item up.");
            // updateWorksheetItemNumbers(); // Uncomment if needed
        } else {
            console.log("Cannot move first item up.");
        }
    };
    // --- 3. Append Move Up Button to controlsDiv ---
    controlsDiv.appendChild(moveUpButton); // <<< APPEND HERE

    // --- 4. Create Move Down Button ---
    const moveDownButton = document.createElement('button');
    moveDownButton.textContent = ' Down';
    moveDownButton.style.backgroundColor = '#6c757d'; // Grey
    moveDownButton.style.color = 'white';
    moveDownButton.style.padding = '3px 8px';
    moveDownButton.style.fontSize = '0.8em';
    moveDownButton.style.marginLeft = '5px';
    moveDownButton.title = 'Move item down';
    moveDownButton.onclick = () => {
        const currentItem = worksheetItemDiv;
        const nextItem = currentItem.nextElementSibling;
        if (nextItem && nextItem.classList.contains('worksheet-item')) {
            worksheetAssemblyArea.insertBefore(nextItem, currentItem);
            console.log("Moved item down.");
            // updateWorksheetItemNumbers(); // Uncomment if needed
        } else {
            console.log("Cannot move last item down.");
        }
    };
    // --- 5. Append Move Down Button to controlsDiv ---
    controlsDiv.appendChild(moveDownButton); // <<< APPEND HERE

    // --- 6. Create Remove Button ---
    const removeButton = document.createElement('button');
    removeButton.textContent = ' Remove';
    removeButton.style.backgroundColor = '#dc3545'; // Red color
    removeButton.style.color = 'white';
    removeButton.style.padding = '3px 8px';
    removeButton.style.fontSize = '0.8em';
    removeButton.style.marginLeft = '5px';
    removeButton.title = 'Remove item from worksheet';
    removeButton.onclick = () => {
        if (confirm("Are you sure you want to remove this item from the worksheet?")) {
             worksheetItemDiv.remove();
             console.log("Worksheet item removed.");
             if (worksheetAssemblyArea.querySelectorAll('.worksheet-item').length === 0) {
                  worksheetAssemblyArea.innerHTML = '<p style="color: grey; font-style: italic;">Items added to the worksheet will appear here.</p>';
             }
            // updateWorksheetItemNumbers(); // Uncomment if needed
        }
    };
    // --- 7. Append Remove Button to controlsDiv ---
    controlsDiv.appendChild(removeButton); // <<< APPEND HERE

    // --- 8. Add the completed controlsDiv to the worksheetItemDiv ---
    // Prepend ensures controls are always at the top, before the content
    if (worksheetItemDiv.firstChild) {
        worksheetItemDiv.insertBefore(controlsDiv, worksheetItemDiv.firstChild);
    } else {
        worksheetItemDiv.appendChild(controlsDiv);
    }
}
        // --- Event Listeners (Consolidated) ---
        modeGapFillRadio.addEventListener('change', handleModeChange);
        modePastedTextRadio.addEventListener('change', handleModeChange)
        modeMcqRadio.addEventListener('change', handleModeChange);
        modeTrueFalseRadio.addEventListener('change', handleModeChange);
        modeShortAnswerRadio.addEventListener('change', handleModeChange);
        modeTextBlockRadio.addEventListener('change', handleModeChange);
        tbGenerateTextCheckbox.addEventListener('change', handleTbCheckboxChange); // Listener for TextBlock checkbox
        modeSimilarQRadio.addEventListener('change', handleModeChange);
        modeWordSearchRadio.addEventListener('change', handleModeChange); // <<< ADD LISTENER
        modeKeywordsDefinitionsRadio.addEventListener('change', handleModeChange);
        modeSimilarWrittenQRadio.addEventListener('change', handleModeChange);
        tbGenerateTextCheckbox.addEventListener('change', handleTbCheckboxChange);
        generateButton.addEventListener('click', async () => {
            console.log(">>> generateButton clicked! <<<");
            currentPreviewItemId = null; // Reset item ID tracking
            console.log("Generate Button: currentPreviewItemId reset to null");

            const selectedMode = document.querySelector('input[name="generatorMode"]:checked').value;
            console.log(">>> Mode Selected:", selectedMode);

            // --- Reset UI ---
            itemPreviewArea.innerHTML = '<div class="loading">Generating... Please wait.</div>';
            generateButton.disabled = true; // Disable button during processing
            toggleEditButton.disabled = true;
            saveButton.disabled = true;
            addToSheetButton.disabled = true;
            toggleEditButton.textContent = 'Enable Editing';
            if (isEditingEnabled) { itemPreviewArea.style.border = '1px solid #ccc'; isEditingEnabled = false; }

            // --- Prepare Payload & Validation ---
            let fetchUrl = '';
            let payload = { item_type: selectedMode }; // Include type early
            let isValid = true;
            let isWordListRequest = false; // Flag for the first step of word search
            let useDirectText = false;

            if (selectedMode === 'gapFill') {
                payload.topic = topicInput.value.trim();
                payload.grade_level = gradeLevelSelect.value;
                payload.num_sentences = parseInt(gfNumSentencesInput.value, 10) || 7;
                if (!payload.topic) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please enter a topic.</p>'; }
                else if (payload.num_sentences < 3 || payload.num_sentences > 15) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Sentences must be 3-15.</p>'; }
                else { fetchUrl = '/generate_worksheet'; }
            } else if (selectedMode === 'textBlock') {
                const generate = tbGenerateTextCheckbox.checked;
                const directTextValue = tbDirectInput.value.trim();
                if (generate) {
                    payload.topic = tbTopicInput.value.trim();
                    payload.grade_level = tbGradeLevelSelect.value;
                    if (!payload.topic) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please enter topic for AI generation.</p>'; }
                    else { fetchUrl = '/generate_text_block'; }
                } else { // Direct text input
                    if (!directTextValue) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Enter text directly or check box.</p>'; }
                    else { useDirectText = true; } // Handled below, no fetch
                }
            } else if (selectedMode === 'pastedText') {
                payload.pasted_text = pastedTextInputArea.value; // Keep raw
                payload.num_questions = parseInt(ptNumQuestionsInput.value, 10) || 5;
                if (!payload.pasted_text || !payload.pasted_text.trim()) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please paste text.</p>'; }
                else if (payload.num_questions < 2 || payload.num_questions > 15) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Questions must be 2-15.</p>'; }
                else { fetchUrl = '/generate_pasted_comprehension'; payload.grade_level = "mixed"; } // Set default grade
            } else if (selectedMode === 'mcq') {
                payload.topic = mcqTopicInput.value.trim();
                payload.grade_level = mcqGradeLevelSelect.value;
                payload.num_questions = parseInt(mcqNumQuestionsInput.value, 10) || 5;
                if (!payload.topic) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please enter topic.</p>'; }
                else if (payload.num_questions < 2 || payload.num_questions > 15) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Questions must be 2-15.</p>'; }
                else { fetchUrl = '/generate_mcq'; }
            } else if (selectedMode === 'trueFalse') {
                payload.topic = tfTopicInput.value.trim();
                payload.grade_level = tfGradeLevelSelect.value;
                payload.num_statements = parseInt(tfNumStatementsInput.value, 10) || 8;
                if (!payload.topic) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please enter topic.</p>'; }
                else if (payload.num_statements < 3 || payload.num_statements > 20) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Statements must be 3-20.</p>'; }
                else { fetchUrl = '/generate_true_false'; }
            } else if (selectedMode === 'shortAnswer') {
                payload.topic = saTopicInput.value.trim();
                payload.grade_level = saGradeLevelSelect.value;
                payload.num_questions = parseInt(saNumQuestionsInput.value, 10) || 5;
                if (!payload.topic) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please enter topic.</p>'; }
                else if (payload.num_questions < 2 || payload.num_questions > 10) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Questions must be 2-10.</p>'; }
                else { fetchUrl = '/generate_short_answer'; }
            } else if (selectedMode === 'similarQ') {
                payload.example_question = sqExampleInput.value; // Keep raw
                payload.num_questions = parseInt(sqNumQuestionsInput.value, 10) || 3;
                payload.grade_level = sqGradeLevelSelect.value;
                if (!payload.example_question || !payload.example_question.trim()) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please paste example question.</p>'; }
                else if (payload.num_questions < 1 || payload.num_questions > 10) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Questions must be 1-10.</p>'; }
                else { fetchUrl = '/generate_similar_questions'; }
            }
            // --- ADDED: Word Search Mode Handling ---
            else if (selectedMode === 'similarWrittenQ') {
                payload.example_question = swqExampleInput.value.trim();
                payload.num_questions = parseInt(swqNumQuestionsInput.value, 10) || 3;
                payload.grade_level = swqGradeLevelSelect.value; // Will be "Not Specified" if user selects that
                if (!payload.example_question) {
                    isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please paste an example question.</p>';
                } else if (payload.num_questions < 1 || payload.num_questions > 10) {
                    isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Number of questions must be 1-10.</p>';
                } else {
                    fetchUrl = '/generate_similar_written_questions';
                }
            } else if (selectedMode === 'wordSearch') {
                // This click is for the FIRST step: getting the word list
                isWordListRequest = true; // Set flag
                payload.topic = document.getElementById('wsTopicInput').value.trim(); // Use specific ID
                payload.grade_level = document.getElementById('wsGradeLevelSelect').value; // Use specific ID
                // Optional: Add num_words input if desired
                // payload.num_words = parseInt(document.getElementById('wsNumWords').value, 10) || 15;
                if (!payload.topic) { isValid = false; itemPreviewArea.innerHTML = '<p style="color: red;">Please enter topic.</p>'; }
                else { fetchUrl = '/generate_word_list'; } // Target the word list route
            }
            // --- End Word Search Mode ---
            else {
                itemPreviewArea.innerHTML = '<p style="color: red;">Invalid mode selected (JS Error).</p>';
                isValid = false;
            }

            // --- Exit if validation failed ---
            if (!isValid) {
                 if (!itemPreviewArea.innerHTML.includes('color: red')) { itemPreviewArea.innerHTML = '<p style="color: red;">Input error.</p>'; }
                 generateButton.disabled = false; // Re-enable button
                 // Ensure other buttons remain disabled
                 toggleEditButton.disabled = true; saveButton.disabled = true; addToSheetButton.disabled = true;
                 return;
            }

            // --- Handle Direct Text (no fetch needed) ---
            if (useDirectText) {
                 console.log("Using direct text input.");
                 const directTextContent = tbDirectInput.value;
                 itemPreviewArea.innerHTML = parseAndStructureTextBlock(directTextContent);
                 toggleEditButton.disabled = false; saveButton.disabled = false; addToSheetButton.disabled = false; // Enable actions
                 generateButton.disabled = false; // Re-enable generate button
                 return; // Exit listener
            }

            // --- Make API Call (if fetchUrl is set) ---
            if (fetchUrl) {
                 try {
                    console.log(`Fetching ${fetchUrl} with final payload:`, payload);
                    const response = await fetch(fetchUrl, {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) });
                    const data = await response.json();
                    console.log('Raw data received from backend:', data);
                    if (!response.ok) { throw new Error(data.message || `HTTP error! status: ${response.status}`); }

                    if (data.status === 'success') {
                        // --- Check if this was the Word List request ---
                        if (isWordListRequest && data.word_list_text) {
                             console.log("Received word list text.");
                             itemPreviewArea.innerHTML = '<p><i>Edit word list below and generate grid...</i></p>'; // Clear preview
                             displayWordListEditor(data.word_list_text); // Call new function to update UI
                             generateButton.disabled = true; // Keep main button disabled until grid generated or mode changed
                             // Do NOT enable save/edit/add buttons here
                             toggleEditButton.disabled = true; saveButton.disabled = true; addToSheetButton.disabled = true;
                        }
                        // --- Handle standard item generation ---
                        else {
                            let rawContent = ''; let outputHtml = '';
                            // Select parser based on mode/key (keep existing logic)
                            if (selectedMode === 'gapFill' && data.worksheet_content) { rawContent = data.worksheet_content; outputHtml = parseAndStructureGapFill(rawContent);
                                itemPreviewArea.innerHTML = outputHtml;
                                toggleEditButton.disabled = false;
                                saveButton.disabled = false;
                                addToSheetButton.disabled = false; 
                            }
                            else if (selectedMode === 'pastedText' && data.pasted_comprehension_content) { rawContent = data.pasted_comprehension_content; outputHtml = parseAndStructurePastedComprehension(rawContent);
                                itemPreviewArea.innerHTML = outputHtml;
                                toggleEditButton.disabled = false;
                                saveButton.disabled = false;
                                addToSheetButton.disabled = false; }
                            
                            else if (selectedMode === 'mcq' && data.mcq_content) { rawContent = data.mcq_content; outputHtml = parseAndStructureMCQ(rawContent);
                            console.log("MCQ Block: Setting innerHTML and enabling buttons."); // Optional log
                            itemPreviewArea.innerHTML = outputHtml;
                            toggleEditButton.disabled = false;
                            saveButton.disabled = false;
                            addToSheetButton.disabled = false; }
                            else if (selectedMode === 'trueFalse' && data.true_false_content) { rawContent = data.true_false_content; outputHtml = parseAndStructureTrueFalse(rawContent);
                                itemPreviewArea.innerHTML = outputHtml;
                                toggleEditButton.disabled = false;
                                saveButton.disabled = false;
                                addToSheetButton.disabled = false; }
                            
                            else if (selectedMode === 'shortAnswer' && data.short_answer_content) { rawContent = data.short_answer_content; outputHtml = parseAndStructureShortAnswer(rawContent);
                                itemPreviewArea.innerHTML = outputHtml;
                                toggleEditButton.disabled = false;
                                saveButton.disabled = false;
                                addToSheetButton.disabled = false; }
                            
                            else if (selectedMode === 'similarQ' && data.similar_questions_content) { rawContent = data.similar_questions_content; outputHtml = parseAndStructureSimilarQuestions(rawContent);
                                itemPreviewArea.innerHTML = outputHtml;
                                toggleEditButton.disabled = false;
                                saveButton.disabled = false;
                                addToSheetButton.disabled = false;
                             }
                            else if (selectedMode === 'similarWrittenQ' && data.data) { // Check for the nested 'data' key
                                console.log("SWQ Block: Entered.");
                                const resultData = data.data;
                                console.log("SWQ Block: Got resultData:", resultData);
                                console.log("Received Similar Written Q data:", resultData);
                                let outputHtml = '<div class="worksheet-section" data-item-type="similar-written-q">'; // Add item type for saving later?
                                console.log("SWQ Block: Initialized outputHtml.");
                                // Store raw data on the preview area itself for saving
                                try {
                                    itemPreviewArea.dataset.rawSwqData = JSON.stringify(resultData);
                                    console.log("SWQ Block: Set rawSwqData dataset.");
                                } catch (e) { console.error("SWQ Block: Error setting dataset:", e); }
                                outputHtml += `<h3>Skills Tested</h3><p>${resultData.skills_identified || 'Not specified'}</p>`;
                                outputHtml += '<h3>Generated Questions</h3>';
                                if (resultData.similar_questions && resultData.similar_questions.length > 0) {
                                    console.log("SWQ Block: Has similar_questions array.");
                                    outputHtml += '<ol>';
                                        resultData.similar_questions.forEach((q, index) => {
                                        console.log(`SWQ Block: Processing question index ${index}`);
                                        // Basic sanitization - replace potential HTML tags just in case
                                        const sanitizedQ = q.replace(/</g, "<").replace(/>/g, ">");
                                        outputHtml += `<li style="margin-bottom: 0.8em;">${sanitizedQ}</li>`; // Add list item style
                                    });
                                    outputHtml += '</ol>';
                                    console.log("SWQ Block: Finished questions loop.")
                                } else {
                                    outputHtml += '<p>No similar questions generated.</p>';
                                }
                                outputHtml += '</div>';
                                outputHtml = outputHtml; // Assign to the variable used below (or directly set innerHTML)
                                rawContent = "N/A"; // No single raw text blob for this type
                                console.log("SWQ Block: FINAL outputHtml to be set:\n", outputHtml);
                                console.log("SWQ Block: Attempting to set innerHTML...");
                                itemPreviewArea.innerHTML = outputHtml; // <<< SET THE PREVIEW CONTENT HERE
                                console.log("SWQ Block: Successfully SET innerHTML.");

                                // Enable save/add buttons specifically for this type
                                console.log("SWQ Block: Attempting to enable buttons...");
                                toggleEditButton.disabled = false; // Allow editing if needed
                                saveButton.disabled = false;    // Use the main save button
                                addToSheetButton.disabled = false;// Use the main add button
                                console.log("SWQ Block: Successfully enabled buttons.");
                            }


                            else if (selectedMode === 'textBlock' && data.text_block_content) { rawContent = data.text_block_content; outputHtml = parseAndStructureTextBlock(rawContent); tbDirectInput.value = rawContent; }
                            else { console.error("Success status but missing expected content key.", data); throw new Error('Generation succeeded but expected content key was not found.'); }
                    
                        }
                    } else { // data.status !== 'success'
                        console.error("Backend returned status !== 'success'", data);
                        throw new Error(data.message || 'Generation failed on the server.');
                    }
                 } catch (error) { // Catch fetch or processing errors
                    console.error('Error during generation fetch/processing:', error);
                    itemPreviewArea.innerHTML = `<p style="color: red;">Error: ${error.message}. Check console.</p>`;
                    generateButton.disabled = false; // Re-enable button on error
                    generateButton.textContent = (selectedMode === 'wordSearch') ? 'Get Word List' : 'Generate New'; // Reset text appropriately
                    // Keep other buttons disabled
                    toggleEditButton.disabled = true; saveButton.disabled = true; addToSheetButton.disabled = true;
                 }
            } else { // Should not happen if validation is correct
                console.error("LOGIC ERROR: No fetch URL set for mode:", selectedMode);
                itemPreviewArea.innerHTML = `<p style="color: red;">Internal JS error for mode '${selectedMode}'.</p>`;
                generateButton.disabled = false;
            }
        });
// --- START: Keywords & Definitions Event Listeners ---

// --- Event Listener for Generate Button ---
generateKeywordsBtn.addEventListener('click', async () => {
    const topic = keywordsTopicInput.value.trim();
    const gradeLevel = keywordsGradeLevelSelect.value;
    const numKeywords = keywordsNumInput.value; // Let backend handle default/validation

    if (!topic || !gradeLevel) {
        keywordsStatus.textContent = 'Please enter both Topic and Grade Level.';
        keywordsStatus.className = 'status-message error';
        return;
    }

    keywordsStatus.textContent = 'Generating keywords...';
    keywordsStatus.className = 'status-message loading';
    keywordsPreviewArea.style.display = 'none'; // Hide previous results
    currentKeywordData = []; // Clear old data
    currentKeywordsItemId = null; // Reset item ID tracking
    keywordsItemIdDisplay.textContent = '';

    try {
        const response = await fetch('/generate_keywords_definitions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ topic, grade_level: gradeLevel, num_keywords: numKeywords }),
        });

        const result = await response.json();

        if (response.ok && result.status === 'success') {
            keywordsStatus.textContent = 'Keywords generated successfully.';
            keywordsStatus.className = 'status-message success';
            currentKeywordData = result.keywords;
            keywordsPreviewArea.style.display = 'block'; // Show preview area
            // Display the default activity (Reference Table)
            document.getElementById('activityRefTable').checked = true; // Ensure default is selected
            displayKeywordActivity();
        } else {
            throw new Error(result.message || 'Failed to generate keywords.');
        }
    } catch (error) {
        console.error("Error generating keywords:", error);
        keywordsStatus.textContent = `Error: ${error.message}`;
        keywordsStatus.className = 'status-message error';
        keywordsPreviewArea.style.display = 'none'; // Keep hidden on error
    }
});

// --- Event Listener for Activity Selector Radio Buttons ---
activitySelector.addEventListener('change', (event) => {
    if (event.target.type === 'radio' && event.target.name === 'keywordActivity') {
        displayKeywordActivity(); // Re-render the table with the new selection
    }
});

// --- Event Listener for "Add to Worksheet" Button ---
addKeywordsToWorksheetBtn.addEventListener('click', () => {
    if (currentItemIdInPreview === null) {
        console.log("addKeywordsToWorksheetBtn: Check FAILED - item not saved yet."); // Add log
        alert("Please save the current Keywords/Definitions item to the library before adding it to the worksheet.");
        return; // Stop the function here
    }
    console.log(`addKeywordsToWorksheetBtn: Check PASSED - Item ID is ${currentItemIdInPreview}.`);
    // Clone the current activity output to add to the worksheet
    const activityContent = activityOutput.innerHTML.trim(); // Get the generated table HTML
    const activityType = activityOutput.dataset.activityType || 'keywords-reference'; // Get stored type
    const keywordsJson = activityOutput.dataset.keywords || '[]'; // Get stored raw data

    if (!activityContent) {
        alert("No activity content to add.");
        return;
    }

    const worksheetItem = document.createElement('div');
    worksheetItem.className = 'worksheet-item';
    // Set a specific data-item-type based on the activity shown
    worksheetItem.dataset.itemType = `keywords-${activityType}`; // e.g., keywords-matching
    // Store the raw data if needed for export later
    worksheetItem.dataset.keywordsData = keywordsJson;

    // Add item ID if it was loaded from library
    if (currentItemIdInPreview) {
        worksheetItem.dataset.generatedItemId = currentItemIdInPreview;
        console.log(`Adding item from library with ID: ${currentItemIdInPreview}`);
    }

    // Embed the actual HTML content inside a container
    const contentWrapper = document.createElement('div');
    contentWrapper.className = 'item-content-wrapper'; // For potential styling
    contentWrapper.innerHTML = activityContent; // Add the table HTML
    worksheetItem.appendChild(contentWrapper);

    // Add controls (Move Up/Down, Remove) - Reuse your existing functions/logic
    addWorksheetItemControls(worksheetItem); // Assuming you have this function

    // Append to the worksheet assembly area
    const placeholder = worksheetAssemblyArea.querySelector('p');
    if (placeholder && placeholder.textContent.includes('Items added to the worksheet')) {
     worksheetAssemblyArea.innerHTML = ''; // Clear the placeholder
    }
    document.getElementById('worksheetAssemblyArea').appendChild(worksheetItem);

     // Add visual separation
    document.getElementById('worksheetAssemblyArea').appendChild(document.createElement('hr'));

    // updateWorksheetItemNumbers(); // Assuming you have this function
});

// --- Event Listener for "Save Item" Button ---
saveKeywordsItemBtn.addEventListener('click', async () => {
    const activityContentHtml = activityOutput.innerHTML.trim();
    const activityType = activityOutput.dataset.activityType || 'reference';
    const itemType = `keywords-${activityType}`; // e.g., keywords-matching
    const keywordsJson = activityOutput.dataset.keywords || '[]'; // Get raw data

    if (!activityContentHtml || !currentKeywordData || currentKeywordData.length === 0) {
        alert("No content generated to save.");
        return;
    }

    // Try to get source/grade from inputs
    const sourceTopic = keywordsTopicInput.value.trim() || "Unknown Topic";
    const gradeLevel = keywordsGradeLevelSelect.value; // Read value from the select element
// You might still want a check here if a default/unknown option is possible
if (!gradeLevel || gradeLevel === "Not Specified") { // Example check
     alert("Please select a valid grade level before saving.");
     isValidMeta = false; // Assuming isValidMeta is used for validation check
     // return; // Or return early
}

    keywordsStatus.textContent = 'Saving item...';
    keywordsStatus.className = 'status-message loading';

    try {
        const response = await fetch('/save_item', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                item_type: itemType,
                content_html: activityContentHtml,
                source_topic: sourceTopic,
                grade_level: gradeLevel,
                item_data_json: keywordsJson,
                // Optionally send the raw data if your backend saves it
                // item_data_json: keywordsJson
            }),
        });
        const result = await response.json();

        if (response.ok && result.item_id) {
            keywordsStatus.textContent = `Item saved successfully (ID: ${result.item_id})`;
            keywordsStatus.className = 'status-message success';
            ccurrentItemIdInPreview = result.item_id; // Track the saved ID
            console.log(`Keywords Save: Updated currentItemIdInPreview to ${currentItemIdInPreview}`);
            keywordsItemIdDisplay.textContent = `Saved as ID: ${result.item_id}`;
             // Refresh library list if you have one displayed
             if (typeof loadLibraryItems === 'function') {
                loadLibraryItems();
            }
        } else {
            throw new Error(result.message || 'Failed to save item.');
        }
    } catch (error) {
        console.error("Error saving item:", error);
        keywordsStatus.textContent = `Error: ${error.message}`;
        keywordsStatus.className = 'status-message error';
        currentItemIdInPreview = null; // Reset on failure
         keywordsItemIdDisplay.textContent = '';
    }
});

        

        toggleEditButton.addEventListener('click', () => { /* ... Keep unchanged ... */
             isEditingEnabled = !isEditingEnabled; const contentElements = itemPreviewArea.querySelectorAll('.worksheet-section p, .worksheet-section li'); if (isEditingEnabled) { toggleEditButton.textContent = 'Disable Editing'; saveButton.disabled = true; contentElements.forEach(el => { el.contentEditable = true; el.classList.add('editable-content'); }); itemPreviewArea.style.border = '2px solid blue'; console.log("Editing enabled."); } else { toggleEditButton.textContent = 'Enable Editing'; saveButton.disabled = false; contentElements.forEach(el => { el.contentEditable = false; el.classList.remove('editable-content'); }); itemPreviewArea.style.border = '1px solid #ccc'; console.log("Editing disabled."); }
        });

        saveButton.addEventListener('click', async () => {
             // Check if editing is enabled
             if (isEditingEnabled) {
                 alert("Please disable editing before saving.");
                 return;
             }

            const selectedMode = document.querySelector('input[name="generatorMode"]:checked').value;
            // Declare metadata variables
            let source_topic = null;
            let source_url = null; // Keep null for now unless a mode uses it
            let gradeLevel = null;
            let isValidMeta = true; // ** Declare isValidMeta **

            // Gather metadata based on the mode ACTIVE WHEN SAVING
            // Uses the values currently shown in the inputs for context
            if (selectedMode === 'gapFill') {
                source_topic = topicInput.value.trim();
                gradeLevel = gradeLevelSelect.value;
                if (!source_topic) { alert("Cannot save without topic context."); isValidMeta = false; }
            } else if (selectedMode === 'textBlock') {
                 source_topic = tbTopicInput.value.trim() || "User Provided Text"; // Use topic if available
                 gradeLevel = tbGradeLevelSelect.value;
            } else if (selectedMode === 'pastedText') {
                 source_topic = "Pasted Text Comprehension"; // Placeholder topic
                 gradeLevel = "middle school"; // Placeholder grade
                 source_url = null;
            } else if (selectedMode === 'mcq') {
                source_topic = mcqTopicInput.value.trim();
                gradeLevel = mcqGradeLevelSelect.value;
                item_type = selectedMode;
                if (!source_topic) { alert("Cannot save without topic context."); isValidMeta = false; }
            } else if (selectedMode === 'trueFalse') {
                 source_topic = tfTopicInput.value.trim();
                 gradeLevel = tfGradeLevelSelect.value;
                 if (!source_topic) { alert("Cannot save without topic context."); isValidMeta = false; }
            } else if (selectedMode === 'shortAnswer') {
                 source_topic = saTopicInput.value.trim();
                 gradeLevel = saGradeLevelSelect.value;
                 if (!source_topic) { alert("Cannot save without topic context."); isValidMeta = false; }
            } else if (selectedMode === 'similarQ') {
                 // Save the example question as the topic for now? Or first few words?
                 source_topic = sqExampleInput.value.substring(0, 50).trim() + "... (Similar Q)";
                 gradeLevel = sqGradeLevelSelect.value;
                 if (!sqExampleInput.value.trim()) { alert("Cannot save similar question without original example text."); isValidMeta = false; }
                 else if (selectedMode === 'similarWrittenQ') {
                    source_topic = swqExampleInput.value.substring(0, 75).trim() + "... (Similar Written Q)"; // Use example Q as topic base
                    gradeLevel = swqGradeLevelSelect.value;
                    item_type = selectedMode; // Use 'similarWrittenQ'
                    // Retrieve the raw data stored on the preview area
                    payload.item_data_json = itemPreviewArea.dataset.rawSwqData || null; // Add raw data to payload
                    if (!swqExampleInput.value.trim()) { alert("Cannot save without the original example question text."); isValidMeta = false; }
                    if (!payload.item_data_json) { console.warn("Could not retrieve raw SWQ data from preview area dataset for saving."); }
                }
            } else if (selectedMode === 'wordSearch') {
                // Get topic/grade from the specific word search inputs
                source_topic = document.getElementById('wsTopicInput').value.trim() || "Word Search";
                gradeLevel = document.getElementById('wsGradeLevelSelect').value;
                item_type = selectedMode; // Set item_type
                // Optional validation:
                // if (!document.getElementById('wsTopicInput').value.trim()) {
                //     alert("Word Search Topic is recommended for saving context.");
                //     // isValidMeta = false; // Optionally make it mandatory
                // }
            } else if (selectedMode === 'similarWrittenQ') {
                source_topic = swqExampleInput.value.substring(0, 75).trim() + "... (Similar Written Q)";
                gradeLevel = swqGradeLevelSelect.value;
                item_type = selectedMode; // Set item_type
                item_data_json_to_save = itemPreviewArea.dataset.rawSwqData || null;
                if (!swqExampleInput.value.trim()) {
                    alert("Cannot save without the original example question text.");
                    isValidMeta = false;
                }
                // Check for raw data (removed the console.warn from here, handled in payload creation)
                // if (!item_data_json_to_save) {
                //     console.warn("Could not retrieve raw SWQ data from preview area dataset for saving.");
                // }
                 // Ensure item_data_json is set correctly for payload later
                 // This variable 'item_data_json_to_save' will be used when creating the payload
            } else { // Handles any unknown mode (Should include keywords here eventually if needed)
                alert(`Unknown item type selected for saving: ${selectedMode}`);
                isValidMeta = false;
                item_type = 'unknown'; // Set a default unknown type
            }
            // --- END: Corrected Metadata Gathering Chain ---

            // --- Grade Level Check (This should now work correctly) ---
            if (!gradeLevel) { // Check if gradeLevel was successfully assigned above
                 alert("Could not determine Grade Level for saving. Please select a grade.");
                 isValidMeta = false;
            }

            // --- Payload Creation (Ensure item_data_json is handled) ---
            if (!isValidMeta) { return; } // Exit if metadata gathering failed

            const content_html = itemPreviewArea.innerHTML;
            // ... (content_html validation) ...

            const payload = {
                item_type: item_type, // Use the variable set above
                source_topic: source_topic,
                source_url: source_url, // Still likely null
                grade_level: gradeLevel,
                content_html: content_html,
                // Assign item_data_json based on mode AFTER checking isValidMeta
                item_data_json: (selectedMode === 'similarWrittenQ') ? item_data_json_to_save : (selectedMode === 'keywordsDefinitions') ? itemPreviewArea.dataset.keywords : null
                 // ^^^^ Added logic for keywords mode here too ^^^^
            };
            if (!gradeLevel) {
                 alert("Could not determine Grade Level for saving. Please select a grade.");
                 // Maybe try reading from a default select if others fail?
                 // gradeLevel = gradeLevelSelect.value; // Fallback? Risky.
                 isValidMeta = false;
            }

            if (!isValidMeta) { return; }

            if (!content_html || content_html.includes('click Generate') || content_html.includes('<div class="loading">')) {
                alert("Cannot save empty or placeholder content.");
                return;
            }
            // Exit if basic metadata validation failed
            if (!isValidMeta) { return; }


            // Ensure the item_data_json from the SWQ logic above overwrites the null if necessary
            if (selectedMode === 'similarWrittenQ' && itemPreviewArea.dataset.rawSwqData) {
                payload.item_data_json = itemPreviewArea.dataset.rawSwqData;
            };

            console.log("Saving payload:", payload);
            saveButton.disabled = true;
            saveButton.textContent = 'Saving...';

            // Make fetch call
            try {
                const response = await fetch('/save_item', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const result = await response.json();
                if (!response.ok || result.status !== 'success') { throw new Error(result.message || `HTTP error! status: ${response.status}`); }
                alert("Item saved successfully!");
                if (result.item_id) {
                    currentPreviewItemId = result.item_id;
                    console.log('Item saved successfully! Stored ID:', currentPreviewItemId);
                    alert(`Item saved successfully! ID: ${currentPreviewItemId}`);
                } else {
                    // This case should ideally not happen if backend is correct
                    currentPreviewItemId = null; // Ensure ID is null if not returned
                    console.warn('Item saved, but item_id was missing in the response:', result);
                    alert("Item saved, but failed to retrieve its ID.");
                }
                saveButton.textContent = 'Saved!'; // Indicate success
            } catch (error) {
                console.error("Error saving item:", error);
                alert(`Error saving item: ${error.message}`);
                saveButton.textContent = 'Save to Library'; // Reset text
                saveButton.disabled = false; // Re-enable on error
                currentPreviewItemId = null;
            }
        }); // <-- End of saveButton listener
        // --- SAVE WORKSHEET LISTENER ---
        saveWorksheetButton.addEventListener('click', async () => {
        const worksheetTitle = worksheetTitleInput.value.trim() || "Untitled Worksheet"; // Get title or use default
        const itemsInWorksheet = worksheetAssemblyArea.querySelectorAll('.worksheet-item'); // Get all item divs

        if (itemsInWorksheet.length === 0) {
            alert("Cannot save an empty worksheet. Please add items first.");
            return;
        }

        // --- Extract Ordered Item IDs ---
        // We need to have stored the original GeneratedItem ID on each worksheet item div when it was added
        const orderedItemIds = [];
        itemsInWorksheet.forEach(itemDiv => {
            const itemId = itemDiv.dataset.generatedItemId; // ** We need to ADD this data attribute later **
            if (itemId) {
                orderedItemIds.push(itemId);
            } else {
                console.warn("Found a worksheet item without a generatedItemId dataset.", itemDiv);
                // Optionally alert the user or skip? For now, we skip.
            }
        });

        if (orderedItemIds.length === 0) {
             alert("Could not find item IDs to save. Ensure items were added correctly.");
             return;
        }

        // --- Prepare Payload ---
        const payload = {
            title: worksheetTitle,
            item_ids: orderedItemIds // Send the array of IDs in order
        };
        console.log("Saving Worksheet Payload:", payload);

        // --- Send to Backend ---
        saveWorksheetButton.disabled = true;
        saveWorksheetButton.textContent = 'Saving...';
        try {
            const response = await fetch('/save_worksheet', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();
            if (!response.ok || result.status !== 'success') {
                throw new Error(result.message || `HTTP error! status: ${response.status}`);
            }
            alert(`Worksheet '${worksheetTitle}' saved successfully! (ID: ${result.worksheet_id})`);
            worksheetTitleInput.value = ''; // Clear title input maybe?
            saveWorksheetButton.textContent = 'Worksheet Saved';
            // Optionally reload the worksheet list?
            // loadWorksheetsButton.click(); // Trigger loading the list again

        } catch (error) {
            console.error("Error saving worksheet:", error);
            alert(`Error saving worksheet: ${error.message}`);
            saveWorksheetButton.textContent = 'Save This Worksheet';
            saveWorksheetButton.disabled = false; // Re-enable on error
        } finally {
             // Decide if button should stay disabled after successful save or re-enable
             // saveWorksheetButton.disabled = false;
        }
    });
    // --- END OF SAVE WORKSHEET LISTENER ---
    // --- LOAD WORKSHEETS LIST LISTENER ---
    loadWorksheetsButton.addEventListener('click', async () => {
        savedWorksheetsList.innerHTML = '<div class="loading">Loading worksheet list...</div>';
        loadWorksheetsButton.disabled = true;
        try {
            const response = await fetch('/list_worksheets');
            const data = await response.json();
            if (!response.ok || data.status !== 'success') {
                throw new Error(data.message || `HTTP error! status: ${response.status}`);
            }

            if (data.worksheets && data.worksheets.length > 0) {
                savedWorksheetsList.innerHTML = ''; // Clear
                const list = document.createElement('ul');
                list.style.listStyle = 'none'; list.style.padding = '0';
                data.worksheets.forEach(ws => {
                    const listItem = document.createElement('li');
                    listItem.style.borderBottom = '1px dashed #eee';
                    listItem.style.marginBottom = '10px';
                    listItem.style.paddingBottom = '10px';
                    listItem.innerHTML = `
                        <strong>${ws.title}</strong> (ID: ${ws.id})<br>
                        <small>Last Modified: ${new Date(ws.last_modified_date).toLocaleString()}</small>
                        <button data-worksheet-id="${ws.id}" class="load-worksheet-button" style="margin-left: 15px; padding: 2px 8px; font-size: 0.8em; background-color:#ffc107; color:black;">Load This Worksheet</button>
                        <button data-worksheet-id="${ws.id}" class="export-docx-button" style="margin-left: 5px; padding: 2px 8px; font-size: 0.8em; background-color:#007bff; color:white;">Export DOCX</button>
                        <!-- Add Delete Worksheet button later -->
                    `;
                    list.appendChild(listItem);
                });
                savedWorksheetsList.appendChild(list);
            } else {
                savedWorksheetsList.innerHTML = '<p>No saved worksheets found.</p>';
            }
        } catch (error) {
            console.error("Error loading worksheet list:", error);
            savedWorksheetsList.innerHTML = `<p style="color: red;">Error loading worksheet list: ${error.message}</p>`;
        } finally {
            loadWorksheetsButton.disabled = false;
        }
    });
    // --- END OF LOAD WORKSHEETS LIST LISTENER ---
    // --- LOAD SPECIFIC WORKSHEET LISTENER (Event Delegation) ---
    savedWorksheetsList.addEventListener('click', async (event) => {

// --- Handler for LOAD WORKSHEET Button ---
if (event.target.classList.contains('load-worksheet-button')) {
    const button = event.target;
    const worksheetId = button.dataset.worksheetId;
    if (!worksheetId) return;

    console.log(`Load worksheet button clicked for ID: ${worksheetId}`); // Correct log for loading
    worksheetAssemblyArea.innerHTML = '<div class="loading">Loading worksheet items...</div>';
    // Disable buttons while loading
    button.disabled = true;
    loadWorksheetsButton.disabled = true;
    clearSheetButton.disabled = true;

    try {
        const response = await fetch(`/load_worksheet/${worksheetId}`);
        const data = await response.json();

        if (!response.ok || data.status !== 'success') {
            throw new Error(data.message || `HTTP error! status: ${response.status}`);
        }

        // --- Rebuild Worksheet Assembly Area ---
        worksheetAssemblyArea.innerHTML = '';
        worksheetTitleInput.value = data.worksheet_title || '';

        if (data.items && data.items.length > 0) {
            data.items.forEach(itemData => {
                const worksheetItem = document.createElement('div');
                worksheetItem.classList.add('worksheet-item');
                worksheetItem.dataset.generatedItemId = itemData.id;
                // Apply styles (keep your existing style code)
                worksheetItem.style.border = '1px solid #a0a0a0';
                worksheetItem.style.padding = '15px';
                worksheetItem.style.marginBottom = '15px';
                worksheetItem.style.backgroundColor = 'white';
                worksheetItem.style.overflow = 'hidden';

                // Add controls (Remove, Move Up, Down) (keep your existing control creation code)
                const controlsDiv = document.createElement('div');
                controlsDiv.style.marginBottom = '10px'; controlsDiv.style.textAlign = 'right';
                // Move Up Button code...
                const moveUpButton = document.createElement('button'); moveUpButton.textContent = ' Up'; /* Add styles + onclick */ moveUpButton.style.backgroundColor = '#6c757d'; moveUpButton.style.color = 'white'; moveUpButton.style.padding = '3px 8px'; moveUpButton.style.fontSize = '0.8em'; moveUpButton.style.marginLeft = '5px'; moveUpButton.title = 'Move item up'; moveUpButton.onclick = () => { const currentItem = worksheetItem; const previousItem = currentItem.previousElementSibling; if (previousItem && previousItem.classList.contains('worksheet-item')) { worksheetAssemblyArea.insertBefore(currentItem, previousItem); }}; controlsDiv.appendChild(moveUpButton);
                // Move Down Button code...
                const moveDownButton = document.createElement('button'); moveDownButton.textContent = ' Down'; /* Add styles + onclick */ moveDownButton.style.backgroundColor = '#6c757d'; moveDownButton.style.color = 'white'; moveDownButton.style.padding = '3px 8px'; moveDownButton.style.fontSize = '0.8em'; moveDownButton.style.marginLeft = '5px'; moveDownButton.title = 'Move item down'; moveDownButton.onclick = () => { const currentItem = worksheetItem; const nextItem = currentItem.nextElementSibling; if (nextItem && nextItem.classList.contains('worksheet-item')) { worksheetAssemblyArea.insertBefore(nextItem, currentItem); }}; controlsDiv.appendChild(moveDownButton);
                // Remove Button code...
                const removeButton = document.createElement('button'); removeButton.textContent = ' Remove'; /* Add styles + onclick */ removeButton.style.backgroundColor = '#dc3545'; removeButton.style.color = 'white'; removeButton.style.padding = '3px 8px'; removeButton.style.fontSize = '0.8em'; removeButton.style.marginLeft = '5px'; removeButton.title = 'Remove item from worksheet'; removeButton.onclick = () => { worksheetItem.remove(); if (worksheetAssemblyArea.querySelectorAll('.worksheet-item').length === 0) {worksheetAssemblyArea.innerHTML = '<p style="color: grey; font-style: italic;">Items added to the worksheet will appear here.</p>';}}; controlsDiv.appendChild(removeButton);
                worksheetItem.appendChild(controlsDiv);

                // Add content (keep your existing content creation code)
                const contentDiv = document.createElement('div');
                contentDiv.style.clear = 'both';
                contentDiv.innerHTML = itemData.content_html;
                worksheetItem.appendChild(contentDiv);

                // Append to assembly area
                worksheetAssemblyArea.appendChild(worksheetItem);
            });
        } else {
             worksheetAssemblyArea.innerHTML = '<p style="color: grey; font-style: italic;">Worksheet loaded but contains no items.</p>';
        }
        console.log(`Worksheet ${worksheetId} loaded successfully.`);

    } catch (error) {
        console.error(`Error loading worksheet ${worksheetId}:`, error);
        worksheetAssemblyArea.innerHTML = `<p style="color: red;">Error loading worksheet: ${error.message}</p>`;
    } finally {
         // Re-enable buttons
         loadWorksheetsButton.disabled = false;
         clearSheetButton.disabled = false;
         // Re-enable specific button?
         // button.disabled = false; // Maybe not, let user reload list if needed
    }
} // --- END of 'load-worksheet-button' Handler ---


// --- Handler for EXPORT DOCX Button ---
else if (event.target.classList.contains('export-docx-button')) {
    const button = event.target;
    const worksheetId = button.dataset.worksheetId;
    if (!worksheetId) {
        console.error("Export DOCX button clicked but worksheet ID is missing.");
        return;
    }
    // Use the CORRECT log message here
    console.log(`Export DOCX button clicked for ID: ${worksheetId}`);
    console.log(`Attempting to navigate to: /export/docx/${worksheetId}`); // Add this log

    // Directly navigate to the export URL - the backend will handle the download
    window.location.href = `/export/docx/${worksheetId}`;

    // Optional: Add visual feedback? e.g., briefly disable button
    button.disabled = true;
    button.textContent = 'Exporting...'
    setTimeout(() => { // Re-enable after a short delay
         button.disabled = false;
         button.textContent = 'Export DOCX';
    }, 2000); // Re-enable after 2 seconds

} // --- END of 'export-docx-button' Handler ---

// --- Add other handlers (e.g., delete) using else if blocks here ---

}); // --- END of savedWorksheetsList listener ---

    // --- END OF LOAD SPECIFIC WORKSHEET LISTENER ---
        loadLibraryButton.addEventListener('click', async () => { /* ... Keep unchanged ... */
             libraryOutput.innerHTML = '<div class="loading">Loading library...</div>'; loadLibraryButton.disabled = true; try { const response = await fetch('/list_items'); const data = await response.json(); if (!response.ok || data.status !== 'success') { throw new Error(data.message || `HTTP error! Status: ${response.status}`); } if (data.items && data.items.length > 0) { libraryOutput.innerHTML = ''; const list = document.createElement('ul'); list.style.listStyle = 'none'; list.style.padding = '0'; data.items.forEach(item => { const listItem = document.createElement('li'); let description = `Type: ${item.item_type}`; if(item.source_topic) description += `, Topic: ${item.source_topic}`; if(item.source_url) description += `, URL: <small>${item.source_url}</small>`; description += `, Grade: ${item.grade_level}`; listItem.innerHTML = `<strong>ID: ${item.id}</strong> - ${description} <br><small>Last Modified: ${new Date(item.last_modified).toLocaleString()}</small><button data-item-id="${item.id}" class="load-item-button" style="margin-left: 15px; padding: 2px 8px; font-size: 0.8em;">Load Item</button>`; list.appendChild(listItem); }); libraryOutput.appendChild(list); } else { libraryOutput.innerHTML = '<p>No saved items found in the library.</p>'; } } catch (error) { console.error("Error loading library:", error); libraryOutput.innerHTML = `<p style="color: red;">Error loading library: ${error.message}</p>`; } finally { loadLibraryButton.disabled = false; }
        });
        addToSheetButton.addEventListener('click', () => {
    console.log("Add to Sheet button clicked.");
    // Ensure editing is off before adding
    if (isEditingEnabled) {
        alert("Please disable editing before adding the item to the worksheet.");
        return;
    }
    if (currentPreviewItemId === null) {
        alert("Cannot add item to worksheet. Please save the current item first, or load an existing item from the library.");
        return;
    }

    // Get the HTML content from the preview area
    const previewContent = itemPreviewArea.innerHTML;
    console.log("--- AddToSheet: Content being added ---");
    console.log(previewContent); // Log the actual HTML string
    console.log("--- End AddToSheet Content ---");

    // Check if the preview content is valid (not empty, loading, or placeholder)
    if (!previewContent || previewContent.trim() === '' || previewContent.includes('will appear here') || previewContent.includes('<div class="loading">')) {
        alert("No valid item in the preview area to add.");
        return;
    }

    // --- Create a wrapper div for the item on the worksheet ---
    const worksheetItem = document.createElement('div');
    worksheetItem.classList.add('worksheet-item'); // For potential future styling/identification
    worksheetItem.dataset.generatedItemId = currentPreviewItemId;
    // Add some basic inline styles for visibility for now
    worksheetItem.style.border = '1px solid #a0a0a0';
    worksheetItem.style.padding = '15px';
    worksheetItem.style.marginBottom = '15px';
    worksheetItem.style.backgroundColor = 'white';
    worksheetItem.style.overflow = 'hidden'; // Contains floats

    // --- Add controls to the item (e.g., Remove button) ---
    addWorksheetItemControls(worksheetItem);
    const contentDiv = document.createElement('div');
    contentDiv.style.clear = 'both'; // Ensure content clears floated controls if any were used
    contentDiv.innerHTML = previewContent; // Put the preview HTML inside this div
    worksheetItem.appendChild(contentDiv);
    

    // --- Append the complete item to the Assembly Area ---
    // Clear placeholder text if it's the first item being added
    const placeholder = worksheetAssemblyArea.querySelector('p');
    if (placeholder && placeholder.textContent.includes('Items added to the worksheet')) {
         worksheetAssemblyArea.innerHTML = ''; // Clear the placeholder
    }
    console.log("--- AddToSheet: Final worksheetItem structure BEFORE appending to assembly area ---");
    console.log(worksheetItem.outerHTML);
    console.log(`WorksheetItem children count: ${worksheetItem.children.length}`);
    if (worksheetItem.children.length > 1) {
         console.log("First child (should be controls):", worksheetItem.children[0].tagName, worksheetItem.children[0].className);
         console.log("Second child (should be content):", worksheetItem.children[1].tagName, worksheetItem.children[1].className);
    }
    worksheetAssemblyArea.appendChild(worksheetItem); // Add the new item

    console.log("Item appended to worksheet assembly area.");

    // Optional: Clear preview area and disable buttons after adding?
    // itemPreviewArea.innerHTML = 'Item added to worksheet below. Generate or load another.';
    // toggleEditButton.disabled = true;
    // saveButton.disabled = true;
    // addToSheetButton.disabled = true;
});

libraryOutput.addEventListener('click', async (event) => {
             if (event.target.classList.contains('load-item-button')) {
                 const button = event.target;
                 const itemId = button.dataset.itemId;
                 if (!itemId) { console.error("Load button clicked but item ID is missing."); return; }
                 console.log(`Load button clicked for item ID: ${itemId}`);
                 libraryOutput.querySelectorAll('.load-item-button').forEach(btn => btn.disabled = true);
                 itemPreviewArea.innerHTML = '<div class="loading">Loading item...</div>';
                 toggleEditButton.disabled = true;
                 saveButton.disabled = true;
                 addToSheetButton.disabled = true;
                 try { // <--------------------------------------------- START OF TRY BLOCK
                     const response = await fetch(`/get_item/${itemId}`);
                     const data = await response.json();
                     if (!response.ok) { // Check response status early
                          throw new Error(data.message || `HTTP error! Status: ${response.status}`);
                     }

                     // --- START: NEW LOGIC PASTED INSIDE TRY ---
                     if (data.item) {
                         const itemType = data.item.item_type;
                         const contentHtml = data.item.content_html;
                         const loadedItemId = data.item.id;

                         console.log(`Processing loaded item ${loadedItemId}, Type: ${itemType}`);
                         currentItemIdInPreview = loadedItemId;

                        if (itemType && itemType.startsWith('keywords-')) {
    console.log(`Loading keywords item specific logic...`);

    let keywordsJsonData = '[]'; // Default
    // --- PRIORITIZE backend data ---
    if (data.item.item_data_json) { // <<< CHECK THIS FIRST
         keywordsJsonData = data.item.item_data_json;
         console.log("Loaded raw keyword JSON from backend `item_data_json` field.");
    } else {
         // --- Fallback (Should ideally not be needed now) ---
         console.warn("Backend did not provide item_data_json, attempting to parse from content_html (less reliable).");
         const tempDiv = document.createElement('div');
         tempDiv.innerHTML = contentHtml;
         const outputDiv = tempDiv.querySelector('#activityOutput'); // Or other wrapper if structure changed
         if (outputDiv && outputDiv.dataset.keywords) {
             keywordsJsonData = outputDiv.dataset.keywords;
             console.log("Parsed raw keyword JSON from data-keywords attribute (fallback).");
         } else {
              console.error("Could not find keywords data in item_data_json or content_html for item", loadedItemId);
         }
    }
    console.log("Attempting to parse this JSON string:", keywordsJsonData);
    // --- END of data retrieval ---

    try {
        currentKeywordData = JSON.parse(keywordsJsonData || '[]');
        if (!Array.isArray(currentKeywordData)) { // Basic validation after parse
             console.error("Parsed keyword data is not an array:", currentKeywordData);
             currentKeywordData = []; // Reset if invalid structure
        }
        console.log("SUCCESS: Parsed currentKeywordData:", currentKeywordData);
    } catch (parseError) {
        console.error("Error parsing stored keywords JSON:", parseError, "JSON was:", keywordsJsonData);
        currentKeywordData = [];
        // Display error in preview area might be better here
         itemPreviewArea.innerHTML = `<p style="color: red;">Error loading keyword data. Saved data format invalid.</p>`;
         // Maybe return or throw error to stop further processing
    }

    const specificActivityType = itemType.substring('keywords-'.length);

    // Select the mode radio button
    modeKeywordsDefinitionsRadio.checked = true;
    handleModeChange(true); // Update visibility of sections

    // Select the activity type radio button
    const radioToCheckAlt = document.querySelector(`input[name="keywordActivity"][value="${specificActivityType}"]`);
     if (radioToCheckAlt) {
         radioToCheckAlt.checked = true;
    } else {
         console.warn(`Could not find radio button for activity type: ${specificActivityType}, defaulting to reference.`);
         document.getElementById('activityRefTable').checked = true; // Default
    }

    // Display the activity (displayKeywordActivity will use currentKeywordData)
    if (currentKeywordData.length > 0) {
         displayKeywordActivity(); // Render the table
    } else {
         // If data is empty after trying to load, show a message
         activityOutput.innerHTML = '<p>Keyword data loaded but appears empty or invalid.</p>';
    }


    // Update status/ID display for keywords section
    keywordsPreviewArea.style.display = 'block'; // Ensure preview area is visible
    keywordsItemIdDisplay.textContent = `Loaded ID: ${loadedItemId}`;
    keywordsStatus.textContent = `Item ${loadedItemId} loaded.`;
    keywordsStatus.className = 'status-message info';
    // Enable keyword-specific buttons
    addKeywordsToWorksheetBtn.disabled = false;
    saveKeywordsItemBtn.disabled = false;

}else if (itemType === 'similarWrittenQ') {
    console.log(`Loading similarWrittenQ item specific logic...`);
    let resultData = null;
    let skills = "Skills not found in saved data.";
    let questions = [];

    // Prioritize loading raw data from item_data_json
    if (data.item.item_data_json) {
        try {
            resultData = JSON.parse(data.item.item_data_json);
            if (resultData && typeof resultData === 'object') {
                skills = resultData.skills_identified || skills;
                questions = resultData.similar_questions || [];
                if (!Array.isArray(questions)) questions = []; // Ensure it's an array
                console.log("Loaded and parsed raw SWQ data from item_data_json.");
            } else {
                 console.error("Parsed SWQ item_data_json is not a valid object.");
            }
        } catch(e) {
            console.error("Error parsing SWQ item_data_json:", e);
        }
    } else {
         console.warn("Raw data (item_data_json) not found for similarWrittenQ item. Content may be incomplete.");
         // Cannot reliably reconstruct from content_html alone for this type
    }

    // Reconstruct the HTML for the preview area
    let outputHtml = '<div class="worksheet-section" data-item-type="similar-written-q">';
    // Store raw data again for potential re-saving
    itemPreviewArea.dataset.rawSwqData = data.item.item_data_json || '{}';

    outputHtml += `<h3>Skills Tested</h3><p>${skills.replace(/</g, "<")}</p>`; // Sanitize skills
    outputHtml += '<h3>Generated Questions</h3>';
    if (questions.length > 0) {
        outputHtml += '<ol>';
        questions.forEach(q => {
            const sanitizedQ = String(q).replace(/</g, "<").replace(/>/g, ">"); // Ensure string & sanitize
            outputHtml += `<li style="margin-bottom: 0.8em;">${sanitizedQ}</li>`;
        });
        outputHtml += '</ol>';
    } else {
        outputHtml += '<p>No similar questions found in saved data.</p>';
    }
    outputHtml += '</div>';

    // Select the mode radio button
    modeSimilarWrittenQRadio.checked = true;
    handleModeChange(true); // Pass true to prevent ID reset

    // Display content
    itemPreviewArea.innerHTML = outputHtml;

    // Enable main action buttons
    toggleEditButton.disabled = false;
    saveButton.disabled = false;
    addToSheetButton.disabled = false;
    isEditingEnabled = false;
    toggleEditButton.textContent = 'Enable Editing';
    saveButton.textContent = 'Save to Library';

} else if (contentHtml) { 
    // --- Handle all OTHER item types ---
                              // ... (logic for other types: set radio, call handleModeChange, set innerHTML) ...
                                console.log(`Loading standard item type: ${itemType}`);
                                // Select the corresponding mode radio button (add checks for all your modes)
                                if (itemType === 'gapFill') modeGapFillRadio.checked = true;
                                else if (itemType === 'pastedText') modePastedTextRadio.checked = true;
                                else if (itemType === 'mcq') modeMcqRadio.checked = true;
                                else if (itemType === 'trueFalse') modeTrueFalseRadio.checked = true;
                                else if (itemType === 'shortAnswer') modeShortAnswerRadio.checked = true;
                                else if (itemType === 'textBlock') modeTextBlockRadio.checked = true;
                                else if (itemType === 'similarQ') modeSimilarQRadio.checked = true;
                                else if (itemType === 'wordSearch') modeWordSearchRadio.checked = true;
                                else modeGapFillRadio.checked = true; // Fallback

                                handleModeChange(true); // Hide/show correct input sections

                                // Display content in the main preview area
                                itemPreviewArea.innerHTML = contentHtml;

                                // Update main status/ID display (if you have one)
                                // Example: document.getElementById('mainStatus').textContent = `Item ${loadedItemId} loaded.`;

                                // Enable main action buttons
                                toggleEditButton.disabled = false;
                                saveButton.disabled = false;
                                addToSheetButton.disabled = false;
                                isEditingEnabled = false;
                                toggleEditButton.textContent = 'Enable Editing';
                                saveButton.textContent = 'Save to Library'; // Use the main save button

                         } else { // Item exists but has no content?
                             throw new Error("Item data received, but content_html was missing.");
                         }

                         itemPreviewArea.scrollIntoView({ behavior: 'smooth', block: 'start' });
                         console.log(`Successfully processed loaded item ${loadedItemId}.`);

                     } else { // data.item was missing
                         throw new Error("Item data was not found in the response.");
                     }
                    // --- END: NEW LOGIC PASTED INSIDE TRY ---

                 } catch (error) { // <------------------------------ START OF CATCH BLOCK
                     console.error(`Error loading item ${itemId}:`, error);
                     itemPreviewArea.innerHTML = `<p style="color: red;">Error loading item: ${error.message}</p>`;
                     toggleEditButton.disabled = true;
                     saveButton.disabled = true;
                     addToSheetButton.disabled = true;
                 } finally { // <----------------------------------- FINALLY BLOCK (Now correctly placed)
                     libraryOutput.querySelectorAll('.load-item-button').forEach(btn => btn.disabled = false);
                 }
             } // End if target is load-item-button
         }); // End libraryOutput listener
        clearSheetButton.addEventListener('click', () => {
    // Ask for confirmation
    if (confirm("Are you sure you want to clear all items from the worksheet assembly area?")) {
        // Reset the innerHTML to the placeholder text
        worksheetAssemblyArea.innerHTML = '<p style="color: grey; font-style: italic;">Items added to the worksheet will appear here.</p>';
        console.log("Worksheet assembly area cleared.");
    }
});


        // --- Initialization ---
        handleModeChange(); // Call once on load to set initial state

    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Worksheet Generator</title>
    <style>
        /* Styles for structured output */
        .worksheet-section { border: 1px solid #e0e0e0; padding: 10px 15px; margin-bottom: 15px; background-color: #fff; border-radius: 4px; }
        .worksheet-section h3 { margin-top: 0; margin-bottom: 10px; border-bottom: 1px solid #ccc; padding-bottom: 5px; }
        .editable-content { outline: 1px dashed blue; background-color: #f0f8ff; cursor: text; padding: 2px 4px; min-height: 1em; border-radius: 2px;}
        #itemPreviewArea p, #itemPreviewArea li { margin-bottom: 0.5em; }
        #libraryOutput li { border-bottom: 1px dashed #eee; margin-bottom: 10px; padding-bottom: 10px; } /* Style library list */
        /* Basic styling */
        body { font-family: sans-serif; padding: 20px; background-color: #f0f0f0; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="text"], input[type="url"], input[type="number"], select, textarea { width: 100%; max-width: 450px; padding: 8px; margin-bottom: 15px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px;} /* Added textarea */
        button { padding: 10px 15px; cursor: pointer; margin-bottom: 15px; margin-left: 5px; border: none; border-radius: 4px; background-color: #007bff; color: white; font-size: 1em;}
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        button#toggleEditButton { background-color: #ffc107; color: black; }
        button#saveButton { background-color: #28a745; }
        button#loadLibraryButton { background-color: #6c757d; }
        #itemPreviewArea { margin-top: 10px; border: 1px solid #ccc; padding: 15px; white-space: pre-wrap; background-color: #fdfdfd; min-height: 150px; border-radius: 4px;}
        #libraryOutput { border: 1px solid #ccc; padding: 15px; background-color: #fff; min-height: 100px; border-radius: 4px; margin-top: 10px; }
        .loading { font-style: italic; color: grey; }
        .hidden { display: none; }
        fieldset { border: 1px solid #ccc; padding: 15px; margin-bottom: 15px; border-radius: 4px; background-color: #fff;}
        legend { font-weight: bold; padding: 0 5px; }
        h1, h2 { color: #333; margin-top: 25px; margin-bottom: 10px;}
        h1:first-of-type { margin-top: 0; }
        hr { margin: 30px 0; border: 0; border-top: 1px solid #ccc; }
        /* Style radio labels */
        fieldset div label { display: inline; font-weight: normal; margin-left: 5px; }
        fieldset div input[type="checkbox"] + label { display: inline; font-weight: normal;} /* Style checkbox label */
    </style>
</head>
<body>
    <h1>AI Worksheet Generator</h1>

    <!-- ======================= -->
    <!-- Section 1: LOAD LIBRARY -->
    <!-- ======================= -->
    <h2>Saved Item Library</h2>
    <button id="loadLibraryButton">Load Saved Items</button>
    <div id="libraryOutput">
        Click "Load Saved Items" to view your library.
    </div>
    <!-- ** ADDED SAVED WORKSHEETS SECTION ** -->
    <h2 style="margin-top: 30px;">Saved Worksheets</h2>
    <button id="loadWorksheetsButton" style="background-color: #6c757d;">Load Worksheet List</button>
    <div id="savedWorksheetsList" style="border: 1px solid #ccc; padding: 15px; background-color: #fff; min-height: 80px; border-radius: 4px; margin-top: 10px;">
        Click "Load Worksheet List" to view saved worksheets.
    </div>

    <hr>

    <!-- ========================== -->
    <!-- Section 2: GENERATE NEW    -->
    <!-- ========================== -->
    <h2>Generate New Item</h2>
    <!-- Mode Selection -->
    <fieldset>
        <legend>Select Generator Type</legend>
        <div><input type="radio" id="modeGapFill" name="generatorMode" value="gapFill" checked><label for="modeGapFill">Gap-Fill</label></div>
        <div><input type="radio" id="modeTextBlock" name="generatorMode" value="textBlock"><label for="modeTextBlock">Text Block</label></div>
        <div><input type="radio" id="modePastedText" name="generatorMode" value="pastedText"><label for="modePastedText">Pasted Text Comp</label></div>
        <div><input type="radio" id="modeMcq" name="generatorMode" value="mcq"><label for="modeMcq">Multiple Choice</label></div>
        <div><input type="radio" id="modeTrueFalse" name="generatorMode" value="trueFalse"><label for="modeTrueFalse">True/False</label></div>
        <div><input type="radio" id="modeShortAnswer" name="generatorMode" value="shortAnswer"><label for="modeShortAnswer">Short Answer</label></div>
        <!-- ** ADD THIS DIV ** -->
        <div>
            <input type="radio" id="modeSimilarQ" name="generatorMode" value="similarQ">
            <label for="modeSimilarQ">Similar Calculation Problems</label>
        </div>
        <!-- ** END ADDED DIV ** -->
    </fieldset>

    <!-- Inputs for Gap Fill (Should be visible by default) -->
    <div id="gapFillInputs">
        <fieldset>
            <legend>Gap-Fill Options</legend>
            <div> <label for="topicInput">Enter Topic:</label> <input type="text" id="topicInput" placeholder="e.g., Photosynthesis"> </div>
            <div> <label for="gradeLevelSelect">Grade Level:</label> <select id="gradeLevelSelect" name="grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div><div>
                <label for="gfNumSentencesInput">Number of Sentences (Gaps):</label>
                <input type="number" id="gfNumSentencesInput" value="7" min="3" max="15"> <!-- Default 7, min 3, max 15 -->
            </div>
        </fieldset>
    </div>

    <!-- ** MODIFIED SECTION for Pasted Text ** -->
    <div id="pastedTextInputs" class="hidden"> <!-- Renamed ID -->
        <fieldset>
            <legend>Pasted Text Comprehension Options</legend> <!-- Changed Legend -->
            <!-- YouTube URL Input REMOVED -->
            <div> <!-- Added Textarea -->
                <label for="pastedTextInputArea">Paste Text Here:</label>
                <textarea id="pastedTextInputArea" rows="10" style="width: 100%; max-width: 450px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; padding: 8px;" placeholder="Paste the text you want questions generated for...eg youtube transcript"></textarea>
            </div>
            <div>
                <label for="ptNumQuestionsInput">Number of Questions:</label> <!-- Renamed for attribute -->
                <input type="number" id="ptNumQuestionsInput" value="5" min="2" max="15"> <!-- Renamed ID -->
            </div>
        </fieldset>
    </div>

    <!-- Inputs for Multiple Choice -->
    <div id="mcqInputs" class="hidden">
        <fieldset>
            <legend>Multiple Choice Options</legend>
            <div> <label for="mcqTopicInput">Enter Topic:</label> <input type="text" id="mcqTopicInput" placeholder="e.g., Mitochondria"> </div>
            <div> <label for="mcqGradeLevelSelect">Grade Level:</label> <select id="mcqGradeLevelSelect" name="mcq_grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div>
            <div> <label for="mcqNumQuestionsInput">Number of Questions:</label> <input type="number" id="mcqNumQuestionsInput" value="5" min="2" max="15"> </div>
        </fieldset>
    </div>

    <!-- Inputs for True/False -->
    <div id="trueFalseInputs" class="hidden">
        <fieldset>
            <legend>True/False Options</legend>
            <div> <label for="tfTopicInput">Enter Topic:</label> <input type="text" id="tfTopicInput" placeholder="e.g., The Roman Empire"> </div>
            <div> <label for="tfGradeLevelSelect">Grade Level:</label> <select id="tfGradeLevelSelect" name="tf_grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div>
            <div> <label for="tfNumStatementsInput">Number of Statements:</label> <input type="number" id="tfNumStatementsInput" value="8" min="3" max="20"> </div>
        </fieldset>
    </div>

    <!-- Inputs for Short Answer -->
    <div id="shortAnswerInputs" class="hidden">
        <fieldset>
            <legend>Short Answer Options</legend>
            <div> <label for="saTopicInput">Enter Topic:</label> <input type="text" id="saTopicInput" placeholder="e.g., Climate Change"> </div>
            <div> <label for="saGradeLevelSelect">Grade Level:</label> <select id="saGradeLevelSelect" name="sa_grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div>
            <div> <label for="saNumQuestionsInput">Number of Questions:</label> <input type="number" id="saNumQuestionsInput" value="5" min="2" max="10"> </div>
        </fieldset>
    </div>

    <!-- Inputs for Text Block -->
    <div id="textBlockInputs" class="hidden">
        <fieldset>
            <legend>Text Block Options</legend>
             <div> <input type="checkbox" id="tbGenerateTextCheckbox" name="tb_generate_text" checked style="display: inline; width: auto; margin-bottom: 10px;"> <label for="tbGenerateTextCheckbox">Generate text using AI?</label> </div>
             <div id="tbTopicInputDiv"> <label for="tbTopicInput">Topic (for AI generation):</label> <input type="text" id="tbTopicInput" placeholder="e.g., The Importance of Bees"> </div>
             <div> <label for="tbGradeLevelSelect">Grade Level (for AI generation):</label> <select id="tbGradeLevelSelect" name="tb_grade_level"> <option value="elementary school">Elementary</option> <option value="middle school" selected>Middle</option> <option value="high school">High</option> <option value="university">University</option> <option value="general adult">Adult</option> </select> </div>
             <div> <label for="tbDirectInput">Or Enter/Edit Your Text Directly:</label> <textarea id="tbDirectInput" rows="8" placeholder="Type your instructions or text here..."></textarea> </div>
        </fieldset>
    </div>
 
 <!-- ** ADD THIS NEW INPUT SECTION ** -->
 <div id="similarQInputs" class="hidden">
     <fieldset>
         <legend>Similar Questions Options</legend>
         <div>
             <label for="sqExampleInput">Paste Example Question Here:</label>
             <textarea id="sqExampleInput" rows="6" style="width: 100%; max-width: 450px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; padding: 8px;" placeholder="Paste the question you want similar versions of..."></textarea>
         </div>
         <div>
             <label for="sqNumQuestionsInput">Number of Similar Questions:</label>
             <input type="number" id="sqNumQuestionsInput" value="3" min="1" max="10"> <!-- Default 3 -->
         </div>
         <div>
             <label for="sqGradeLevelSelect">Target Grade Level (Optional):</label>
             <select id="sqGradeLevelSelect" name="sq_grade_level">
                 <option value="Not Specified" selected>Not Specified</option> <!-- Add default option -->
                 <option value="elementary school">Elementary</option>
                 <option value="middle school">Middle</option>
                 <option value="high school">High</option>
                 <option value="university">University</option>
                 <option value="general adult">Adult</option>
             </select>
         </div>
         <!-- Add checkboxes for variations here later if desired -->
         <!-- Example:
         <div>
             <input type="checkbox" id="sqAllowUnits" name="sq_allow_units" style="display: inline; width: auto;">
             <label for="sqAllowUnits">Allow Unit Conversions?</label>
         </div>
          -->
     </fieldset>
 </div>
 <!-- ** END OF NEW INPUT SECTION ** -->
    <!-- Generate Button -->
    <button id="generateButton">Generate New</button>

    <hr>

    <!-- ================================== -->
    <!-- Section 3: GENERATED OUTPUT/EDITOR -->
    <!-- ================================== -->
    <button id="saveButton" style="float: right;" disabled>Save to Library</button>
    <button id="toggleEditButton" style="float: right;" disabled>Enable Editing</button>
    <button id="addToSheetButton" style="float: right; background-color: #17a2b8;" disabled>Add Item to Worksheet</button>
    <h2 style="clear: both;">Item preview / Editor</h2>
    <div id="itemPreviewArea"> Generated/loaded item will appear here for preview/editing. </div>
    <hr>
    <h2>Worksheet Assembly Area</h2>
    <div style="margin-bottom: 15px; background-color: #fff; padding: 10px; border-radius: 4px; border: 1px solid #ccc;">
        <label for="worksheetTitleInput" style="display: inline-block; margin-right: 10px;">Worksheet Title:</label>
        <input type="text" id="worksheetTitleInput" placeholder="Enter a title for this worksheet" style="display: inline-block; width: auto; max-width: 300px; margin-bottom: 0;">
        <button id="saveWorksheetButton" style="background-color: #28a745; margin-left: 15px; float: right;">Save This Worksheet</button>
        <div style="clear: both;"></div> <!-- Clear float -->
    </div>
<button id="clearSheetButton" style="background-color: #dc3545;">Clear Worksheet</button> <!-- Added Clear Button -->
<div id="worksheetAssemblyArea" style="border: 2px dashed #6c757d; padding: 20px; background-color: #e9ecef; min-height: 300px; margin-top: 15px;">
    <!-- Items added to the worksheet will appear here -->
    <p style="color: grey; font-style: italic;">Items added to the worksheet will appear here.</p>
</div>

    <script>
        // --- Get Element References (Consolidated) ---
        const modeGapFillRadio = document.getElementById('modeGapFill');
        const modePastedTextRadio = document.getElementById('modePastedText');
        const modeMcqRadio = document.getElementById('modeMcq');
        const modeTrueFalseRadio = document.getElementById('modeTrueFalse');
        const modeShortAnswerRadio = document.getElementById('modeShortAnswer');
        const modeTextBlockRadio = document.getElementById('modeTextBlock');
        const modeSimilarQRadio = document.getElementById('modeSimilarQ');
        const gapFillInputsDiv = document.getElementById('gapFillInputs');
        const pastedTextInputsDiv = document.getElementById('pastedTextInputs');
        const mcqInputsDiv = document.getElementById('mcqInputs');
        const trueFalseInputsDiv = document.getElementById('trueFalseInputs');
        const shortAnswerInputsDiv = document.getElementById('shortAnswerInputs');
        const textBlockInputsDiv = document.getElementById('textBlockInputs');
        const similarQInputsDiv = document.getElementById('similarQInputs');
        const topicInput = document.getElementById('topicInput');
        const gradeLevelSelect = document.getElementById('gradeLevelSelect');
        const gfNumSentencesInput = document.getElementById('gfNumSentencesInput');
        const ptNumQuestionsInput = document.getElementById('ptNumQuestionsInput');
        const pastedTextInputArea = document.getElementById('pastedTextInputArea');
        const mcqTopicInput = document.getElementById('mcqTopicInput');
        const mcqGradeLevelSelect = document.getElementById('mcqGradeLevelSelect');
        const mcqNumQuestionsInput = document.getElementById('mcqNumQuestionsInput');

        const tfTopicInput = document.getElementById('tfTopicInput');
        const tfGradeLevelSelect = document.getElementById('tfGradeLevelSelect');
        const tfNumStatementsInput = document.getElementById('tfNumStatementsInput');

        const saTopicInput = document.getElementById('saTopicInput');
        const saGradeLevelSelect = document.getElementById('saGradeLevelSelect');
        const saNumQuestionsInput = document.getElementById('saNumQuestionsInput');

        const tbGenerateTextCheckbox = document.getElementById('tbGenerateTextCheckbox');
        const tbTopicInputDiv = document.getElementById('tbTopicInputDiv');
        const tbTopicInput = document.getElementById('tbTopicInput');
        const tbGradeLevelSelect = document.getElementById('tbGradeLevelSelect');
        const tbDirectInput = document.getElementById('tbDirectInput');
        const sqExampleInput = document.getElementById('sqExampleInput');
        const sqNumQuestionsInput = document.getElementById('sqNumQuestionsInput');
        const sqGradeLevelSelect = document.getElementById('sqGradeLevelSelect');
        const generateButton = document.getElementById('generateButton');
        const loadLibraryButton = document.getElementById('loadLibraryButton');
        const itemPreviewArea = document.getElementById('itemPreviewArea');
        const addToSheetButton = document.getElementById('addToSheetButton');
        const worksheetAssemblyArea = document.getElementById('worksheetAssemblyArea');
        const clearSheetButton = document.getElementById('clearSheetButton');
        const worksheetTitleInput = document.getElementById('worksheetTitleInput');
        const libraryOutput = document.getElementById('libraryOutput');
        const toggleEditButton = document.getElementById('toggleEditButton');
        const saveButton = document.getElementById('saveButton');

        // --- State Variables ---
        let isEditingEnabled = false;
        let currentPreviewItemId = null; // Store ID of item in preview
        // --- Helper Functions ---

        // Handles showing/hiding topic input for Text Block mode
        function handleTbCheckboxChange() {
            if (tbGenerateTextCheckbox.checked) {
                tbTopicInputDiv.classList.remove('hidden');
            } else {
                tbTopicInputDiv.classList.add('hidden');
            }
        }

        // ** FIXED handleModeChange Function **
        function handleModeChange() {
    console.log("--- handleModeChange START ---"); // Keep logs for now
    currentPreviewItemId = null;
    console.log("handleModeChange: currentPreviewItemId reset to null");
    // Hide all input sections first
    gapFillInputsDiv.classList.add('hidden');
    pastedTextInputsDiv.classList.add('hidden');
    mcqInputsDiv.classList.add('hidden');
    trueFalseInputsDiv.classList.add('hidden');
    shortAnswerInputsDiv.classList.add('hidden');
    textBlockInputsDiv.classList.add('hidden');
    similarQInputsDiv.classList.add('hidden');

    // Show the selected one
    if (modeTextBlockRadio.checked) {
        console.log("Mode detected: Text Block");
        textBlockInputsDiv.classList.remove('hidden'); handleTbCheckboxChange();
    } else if (modePastedTextRadio.checked) {
         console.log("Mode detected: Pasted Text");
         pastedTextInputsDiv.classList.remove('hidden');
    } else if (modeMcqRadio.checked) {
        console.log("Mode detected: MCQ");
        mcqInputsDiv.classList.remove('hidden');
    } else if (modeTrueFalseRadio.checked) {
        console.log("Mode detected: True/False");
        trueFalseInputsDiv.classList.remove('hidden');
    } else if (modeShortAnswerRadio.checked) {
        console.log("Mode detected: Short Answer");
        shortAnswerInputsDiv.classList.remove('hidden');
    } else if (modeSimilarQRadio.checked) { // <-- Add condition for SimilarQ
        console.log("Mode detected: Similar Questions");
        similarQInputsDiv.classList.remove('hidden');
    }
    // *** FIXED: Explicitly handle Gap Fill (or treat as default) ***
    else { // Catches modeGapFillRadio.checked or initial state
        console.log("Mode detected: Default (Gap Fill)");
        gapFillInputsDiv.classList.remove('hidden');
    }
    console.log("--- handleModeChange END ---");

    // Reset output and buttons
    itemPreviewArea.innerHTML = 'Enter details for the selected mode and click Generate.';
    toggleEditButton.disabled = true;
    saveButton.disabled = true;
    addToSheetButton.disabled = true;
    toggleEditButton.textContent = 'Enable Editing';
    if (isEditingEnabled) {
        itemPreviewArea.style.border = '1px solid #ccc';
        isEditingEnabled = false;
    }
}

        // --- Parsing Functions (Keep all 6 definitions) ---
        function parseAndStructureGapFill(rawText) { /* ... Full function ... */
             const keyIdentifier = "Answer Key:"; const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im')); let contentPart = rawText; let keyPart = ""; let structuredHtml = "";
            if (keyIndex !== -1) { contentPart = rawText.substring(0, keyIndex).trim(); keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim(); } else { console.warn("Could not find 'Answer Key:' separator."); return `<div class="worksheet-section"><h3>Worksheet (Format Issue?)</h3><div>${contentPart.replace(/\n/g, '<br>')}</div></div>`; }
            const sentences = contentPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="gap-fill-sentences"><h3>Worksheet Sentences</h3>'; sentences.forEach((sentence, index) => { structuredHtml += `<p data-index="${index}">${sentence.trim()}</p>`; }); structuredHtml += '</div>';
            const answers = keyPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="gap-fill-answers"><h3>Answer Key</h3><ol>'; answers.forEach((answerLine) => { const cleanedAnswer = answerLine.replace(/^\d+\.\s*/, '').trim(); if (cleanedAnswer) { structuredHtml += `<li>${cleanedAnswer}</li>`; } }); structuredHtml += '</ol></div>'; return structuredHtml;
         }
        function parseAndStructureQuestions(rawText) { /* ... Full function ... */
             const questions = rawText.split('\n').filter(line => line.trim() !== ''); let structuredHtml = '<div class="worksheet-section" id="comprehension-questions"><h3>Comprehension Questions</h3><ol>'; questions.forEach((questionLine) => { const cleanedQuestion = questionLine.replace(/^\d+\.\s*/, '').trim(); if (cleanedQuestion) { structuredHtml += `<li>${cleanedQuestion}</li>`; } }); structuredHtml += '</ol></div>'; return structuredHtml;
        }
        function parseAndStructureMCQ(rawText) { /* ... Full function ... */
            const keyIdentifier = "Answer Key:"; const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im')); let questionsPart = rawText; let keyPart = ""; let structuredHtml = "";
            if (keyIndex !== -1) { questionsPart = rawText.substring(0, keyIndex).trim(); keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim(); } else { console.warn("Could not find 'Answer Key:' separator for MCQs."); return `<div class="worksheet-section"><h3>Questions (Format Issue?)</h3><div>${questionsPart.replace(/\n/g, '<br>')}</div></div>`; }
            structuredHtml += '<div class="worksheet-section" id="mcq-questions"><h3>Multiple Choice Questions</h3>'; const lines = questionsPart.split('\n').filter(line => line.trim() !== ''); let currentQuestionNumber = 0;
            lines.forEach(line => { line = line.trim(); const questionMatch = line.match(/^(\d+)\.\s*(.*)/); const optionMatch = line.match(/^[A-D]\.\s*(.*)/i); if (questionMatch) { currentQuestionNumber = parseInt(questionMatch[1], 10); if (currentQuestionNumber > 1) { structuredHtml += '</ul>'; } structuredHtml += `<p><strong>${questionMatch[1]}. ${questionMatch[2]}</strong></p><ul style="list-style: upper-alpha; margin-left: 20px;">`; } else if (optionMatch) { structuredHtml += `<li>${optionMatch[1]}</li>`; } else if (line) { structuredHtml += `<div>${line}</div>`; } }); if (currentQuestionNumber > 0) { structuredHtml += '</ul>'; } structuredHtml += '</div>';
            const answers = keyPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="mcq-answers"><h3>Answer Key</h3><ol>'; answers.forEach((answerLine) => { const cleanedAnswer = answerLine.trim().replace(/^\d+\.\s*/, ''); if(cleanedAnswer) { structuredHtml += `<li>${cleanedAnswer}</li>`; } }); structuredHtml += '</ol></div>'; return structuredHtml;
         }
        function parseAndStructureTrueFalse(rawText) { /* ... Full function ... */
            const keyIdentifier = "Answer Key:"; const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im')); let statementsPart = rawText; let keyPart = ""; let structuredHtml = "";
            if (keyIndex !== -1) { statementsPart = rawText.substring(0, keyIndex).trim(); keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim(); } else { console.warn("Could not find 'Answer Key:' separator for True/False."); return `<div class="worksheet-section"><h3>Statements (Format Issue?)</h3><div>${statementsPart.replace(/\n/g, '<br>')}</div></div>`; }
            const statements = statementsPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="tf-statements"><h3>True/False Statements</h3><ol>'; statements.forEach((statementLine) => { const cleanedStatement = statementLine.replace(/^\d+\.\s*/, '').trim(); if (cleanedStatement) { structuredHtml += `<li>${cleanedStatement}</li>`; } }); structuredHtml += '</ol></div>';
            const answers = keyPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="tf-answers"><h3>Answer Key</h3><ol>'; answers.forEach((answerLine) => { const cleanedAnswer = answerLine.trim().replace(/^\d+\.\s*/, ''); if(cleanedAnswer) { structuredHtml += `<li>${cleanedAnswer}</li>`; } }); structuredHtml += '</ol></div>'; return structuredHtml;
        }
        function parseAndStructureSimilarQuestions(rawText) {
        console.log("Parsing Similar Questions Text:", rawText.substring(0, 250) + "..."); // Log more context

        // Define markers more flexibly (case-insensitive, optional number/formatting)
        const analysisMarker = "Analysis of Example:"; // Keep this simple
        const questionsMarker = "New Similar Questions:"; // Look for this text after a number/bullet
        const keyMarker = "Answer Key:";

        let analysisPart = ""; // We'll extract but might not display
        let questionsPart = "";
        let keyPart = "";
        let parseSuccess = false;

        // Find indices using case-insensitive search and allowing flexibility
        const analysisIndex = rawText.search(new RegExp(analysisMarker, 'i'));
        // Look for the key marker first, as it should reliably be at the end
        const keyIndex = rawText.search(new RegExp(`^${keyMarker.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im'));

        if (keyIndex !== -1) {
            // If key is found, assume everything before it belongs to questions/analysis
            const beforeKey = rawText.substring(0, keyIndex).trim();
            keyPart = rawText.substring(keyIndex + keyMarker.length).trim();

            // Now try to find the start of the actual questions within the 'beforeKey' part
            // Look for the first line starting with "1." after the analysis section (if analysis exists)
            let questionStartIndex = -1;
            if (analysisIndex !== -1 && analysisIndex < keyIndex) {
                 // Find the end of the analysis block (next newline after analysis marker)
                 const analysisEndIndex = beforeKey.indexOf('\n', analysisIndex);
                 const potentialQuestionArea = analysisEndIndex !== -1 ? beforeKey.substring(analysisEndIndex) : beforeKey;
                 // Find the first "1." in that area
                 questionStartIndex = potentialQuestionArea.search(/^\s*1\.\s+/m);
                 if (questionStartIndex !== -1) {
                     questionStartIndex += (analysisEndIndex !== -1 ? analysisEndIndex : 0); // Adjust index relative to start of beforeKey
                     analysisPart = beforeKey.substring(analysisIndex + analysisMarker.length, questionStartIndex).trim();
                     questionsPart = beforeKey.substring(questionStartIndex).trim();
                     parseSuccess = true;
                 }
            } else {
                 // If no clear analysis marker, assume questions start near the beginning
                 questionStartIndex = beforeKey.search(/^\s*1\.\s+/m);
                 if (questionStartIndex !== -1) {
                     analysisPart = ""; // No analysis extracted
                     questionsPart = beforeKey.substring(questionStartIndex).trim();
                     parseSuccess = true;
                 }
            }

            if(parseSuccess) {
                 console.log("Successfully split SimilarQ into Questions/Key parts (Analysis optional).");
            }

        }

        // If parsing failed, use fallback
        if (!parseSuccess) {
            console.warn("Could not reliably split Similar Questions output. Displaying raw.");
            let fallbackHtml = rawText.replace(/\n/g, '<br>');
            // Try to hide analysis/key roughly if possible in fallback
             const keyIdxFallback = fallbackHtml.search(new RegExp(keyMarker,'i'));
             if(keyIdxFallback !== -1) fallbackHtml = fallbackHtml.substring(0, keyIdxFallback);
             const analysisIdxFallback = fallbackHtml.search(new RegExp(analysisMarker,'i'));
             if(analysisIdxFallback !== -1) fallbackHtml = fallbackHtml.substring(analysisIdxFallback + analysisMarker.length);

            return `<div class="worksheet-section"><h3>Similar Questions (Format Issue?)</h3><div>${fallbackHtml}</div></div>`;
        }


        let structuredHtml = "";

        // --- Display Questions Part ONLY ---
        // We are *not* adding the 'analysisPart' to the structuredHtml meant for the worksheet item
        const questions = questionsPart.split('\n').filter(line => line.trim() !== '' && !line.match(/^\d+\s+New Similar Questions:/i)); // Also filter out the title line
        structuredHtml += '<div class="worksheet-section" id="sq-questions"><h3>Generated Questions</h3>';
        structuredHtml += '<ol>';
        questions.forEach((questionLine) => {
            const cleanedQuestion = questionLine.replace(/^\d+\.\s*/, '').trim(); // Remove number
            if (cleanedQuestion) {
                structuredHtml += `<li>${cleanedQuestion}</li>`;
            }
        });
        structuredHtml += '</ol></div>'; // Close sq-questions div

        // --- Process and ADD Answer Key Part (Hidden by default later?) ---
        const answerLines = keyPart.split('\n').filter(line => line.trim() !== '');
        // Maybe hide this section by default later
        structuredHtml += '<div class="worksheet-section answer-key-container" id="sq-answers"><h3>Answer Key</h3>'; // Added answer-key-container class
        structuredHtml += '<ol>';
        let currentAnswerContent = ''; let currentQuestionNumber = null;
        answerLines.forEach((line, index) => {
            line = line.trim(); const numberMatch = line.match(/^(\d+)\.\s*(.*)/);
            if (numberMatch) {
                const questionNum = parseInt(numberMatch[1], 10); const content = numberMatch[2].trim();
                if (currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim().replace(/\n/g,'<br>')}</li>`; }
                currentQuestionNumber = questionNum; currentAnswerContent = content;
            } else if (currentQuestionNumber !== null && line) { currentAnswerContent += `\n<span style="margin-left: 15px;">${line}</span>`; }
            if (index === answerLines.length - 1 && currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim().replace(/\n/g,'<br>')}</li>`; }
        });
        structuredHtml += '</ol></div>'; // Close sq-answers div

        console.log("Finished parsing Similar Questions.");
        return structuredHtml;
    }
        function parseAndStructurePastedComprehension(rawText) {
    console.log("Parsing Pasted Text Comprehension:", rawText.substring(0, 150) + "...");
    // This will be similar to Short Answer or MCQ parsing, expecting Questions + Key
    const keyIdentifier = "Answer Key:";
    const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im'));
    let questionsPart = rawText;
    let keyPart = "";
    let structuredHtml = "";

    if (keyIndex !== -1) {
        questionsPart = rawText.substring(0, keyIndex).trim();
        keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim();
        console.log("Split into Questions / Key parts for Pasted Text Comp");
    } else {
        console.warn("Could not find 'Answer Key:' separator for Pasted Text Comp. Treating all as questions.");
        keyPart = ""; // Assume no key if separator not found
    }

    // Process Questions Part
    const questions = questionsPart.split('\n').filter(line => line.trim() !== '');
    // We add a heading for the questions section
    structuredHtml += '<div class="worksheet-section" id="ptc-questions"><h3>Comprehension Questions</h3>';
    structuredHtml += '<ol>'; // Use ordered list for questions
    questions.forEach((questionLine) => {
        const cleanedQuestion = questionLine.replace(/^\d+\.\s*/, '').trim(); // Remove numbering
        if (cleanedQuestion) {
            structuredHtml += `<li>${cleanedQuestion}</li>`; // Add question as list item
        }
    });
    structuredHtml += '</ol></div>'; // Close ptc-questions div

    // Process Key Part (if found) - Reuse logic from Short Answer parser
    if (keyPart) {
        const answerLines = keyPart.split('\n').filter(line => line.trim() !== '');
        structuredHtml += '<div class="worksheet-section" id="ptc-answers"><h3>Answer Key</h3>';
        structuredHtml += '<ol>'; // Main ordered list for question numbers
        let currentAnswerContent = ''; let currentQuestionNumber = null;
        answerLines.forEach((line, index) => {
            line = line.trim(); const numberMatch = line.match(/^(\d+)\.\s*(.*)/);
            if (numberMatch) {
                const questionNum = parseInt(numberMatch[1], 10); const content = numberMatch[2].trim();
                if (currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim()}</li>`; }
                currentQuestionNumber = questionNum; currentAnswerContent = content;
            } else if (currentQuestionNumber !== null && line) { currentAnswerContent += `<br>   ${line}`; }
            if (index === answerLines.length - 1 && currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim()}</li>`; }
        });
        structuredHtml += '</ol></div>'; // Close ptc-answers div
    }

    console.log("Finished parsing Pasted Text Comprehension.");
    return structuredHtml;
    // NOTE: We are NOT displaying the original pasted text here, only the Qs & Key.
    // If you wanted to include the original text, you'd need to pass it to this function
    // or restructure how the output is built. For now, it just parses the AI response.
}
        function parseAndStructureShortAnswer(rawText) { /* ... Full function ... */
            const keyIdentifier = "Answer Key:"; const keyIndex = rawText.search(new RegExp(`^${keyIdentifier.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*`, 'im')); let questionsPart = rawText; let keyPart = ""; let structuredHtml = "";
            if (keyIndex !== -1) { questionsPart = rawText.substring(0, keyIndex).trim(); keyPart = rawText.substring(keyIndex + keyIdentifier.length).trim(); } else { console.warn("Could not find 'Answer Key:' separator for Short Answer."); keyPart = ""; }
            const questions = questionsPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="sa-questions"><h3>Short Answer Questions</h3><ol>'; questions.forEach((questionLine) => { const cleanedQuestion = questionLine.replace(/^\d+\.\s*/, '').trim(); if (cleanedQuestion) { structuredHtml += `<li style="margin-bottom: 1.5em;">${cleanedQuestion}<br><span style="color: #999;">Answer: _______________</span></li>`; } }); structuredHtml += '</ol></div>';
            if (keyPart) { const answerLines = keyPart.split('\n').filter(line => line.trim() !== ''); structuredHtml += '<div class="worksheet-section" id="sa-answers"><h3>Answer Key / Grading Points</h3><ol>'; let currentAnswerContent = ''; let currentQuestionNumber = null; answerLines.forEach((line, index) => { line = line.trim(); const numberMatch = line.match(/^(\d+)\.\s*(.*)/); if (numberMatch) { const questionNum = parseInt(numberMatch[1], 10); const content = numberMatch[2].trim(); if (currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim()}</li>`; } currentQuestionNumber = questionNum; currentAnswerContent = content; } else if (currentQuestionNumber !== null && line) { currentAnswerContent += `<br>   ${line}`; } if (index === answerLines.length - 1 && currentAnswerContent) { structuredHtml += `<li>${currentAnswerContent.trim()}</li>`; } }); structuredHtml += '</ol></div>'; }
            return structuredHtml;
        }
        function parseAndStructureTextBlock(rawText) { /* ... Full function ... */
             const formattedText = rawText.replace(/\n/g, '<br>'); let structuredHtml = `<div class="worksheet-section" id="text-block-generated"><h3>Text Block</h3><div>${formattedText}</div></div>`; return structuredHtml;
         }
        // --- END OF PARSING FUNCTIONS ---


        // --- Event Listeners (Consolidated) ---
        modeGapFillRadio.addEventListener('change', handleModeChange);
        modePastedTextRadio.addEventListener('change', handleModeChange)
        modeMcqRadio.addEventListener('change', handleModeChange);
        modeTrueFalseRadio.addEventListener('change', handleModeChange);
        modeShortAnswerRadio.addEventListener('change', handleModeChange);
        modeTextBlockRadio.addEventListener('change', handleModeChange);
        tbGenerateTextCheckbox.addEventListener('change', handleTbCheckboxChange); // Listener for TextBlock checkbox
        modeSimilarQRadio.addEventListener('change', handleModeChange);

        generateButton.addEventListener('click', async () => {
            console.log(">>> generateButton clicked! <<<"); // Log entry
            currentPreviewItemId = null;
            console.log("Generate Button: currentPreviewItemId reset to null");

            // --- Declare ALL potential payload variables OUTSIDE the blocks ---
            let fetchUrl = '';
            let isValid = true; // Use this for input validation ONLY
            let useDirectText = false; // Flag for text block mode
            const selectedMode = document.querySelector('input[name="generatorMode"]:checked').value;

            // Variables for payload - initialize to null or default
            let topic = null;
            let gradeLevel = null;
            let numQuestions = null;
            let numSentences = null; // Use specific name for gap-fill number
            let numStatements = null;
            let youtubeUrl = null; // Keep for reference, though unused now
            let pastedText = null;
            let exampleQuestion = null;

            // --- Reset UI ---
            itemPreviewArea.innerHTML = '<div class="loading">Generating... Please wait.</div>';
            // Separate button state lines
            generateButton.disabled = true;
            toggleEditButton.disabled = true;
            saveButton.disabled = true;
            addToSheetButton.disabled = true;
            toggleEditButton.textContent = 'Enable Editing';
            if (isEditingEnabled) { itemPreviewArea.style.border = '1px solid #ccc'; isEditingEnabled = false; }

            console.log(">>> Mode Selected:", selectedMode);

            // --- Prepare fetchUrl and Assign outer variables based on mode & Validate ---
            if (selectedMode === 'gapFill') {
                topic = topicInput.value.trim();
                gradeLevel = gradeLevelSelect.value;
                numSentences = parseInt(gfNumSentencesInput.value, 10) || 7; // Use specific variable
                if (!topic) { itemPreviewArea.innerHTML = '<p style="color: red;">Please enter a topic.</p>'; isValid = false; }
                else if (numSentences < 3 || numSentences > 15) { itemPreviewArea.innerHTML = '<p style="color: red;">Please enter a number of sentences between 3 and 15.</p>'; isValid = false; }
                else { fetchUrl = '/generate_worksheet'; }
            } else if (selectedMode === 'textBlock') {
                const generate = tbGenerateTextCheckbox.checked;
                topic = tbTopicInput.value.trim();
                gradeLevel = tbGradeLevelSelect.value;
                const directTextValue = tbDirectInput.value.trim(); // Use temp var
                if (generate && !topic) { itemPreviewArea.innerHTML = '<p style="color: red;">Please enter a topic for AI generation.</p>'; isValid = false; }
                else if (!generate && !directTextValue) { itemPreviewArea.innerHTML = '<p style="color: red;">Please enter your text directly, or check the box.</p>'; isValid = false; }
                else { if (generate) { fetchUrl = '/generate_text_block'; } else { useDirectText = true; } } // Set flag OR url
            } else if (selectedMode === 'pastedText') {
                pastedText = pastedTextInputArea.value; // Keep raw value with newlines
                numQuestions = parseInt(ptNumQuestionsInput.value, 10) || 5;
                if (!pastedText || !pastedText.trim()) { itemPreviewArea.innerHTML = '<p style="color: red;">Please paste the text for comprehension.</p>'; isValid = false; }
                else if (numQuestions < 2 || numQuestions > 15) { itemPreviewArea.innerHTML = '<p style="color: red;">Please enter # questions between 2 and 15.</p>'; isValid = false; }
                else { fetchUrl = '/generate_pasted_comprehension'; }
                topic = null; gradeLevel = "mixed"; numStatements = null; youtubeUrl = null; exampleQuestion = null; // Reset others
            } else if (selectedMode === 'mcq') {
                topic = mcqTopicInput.value.trim();
                gradeLevel = mcqGradeLevelSelect.value;
                numQuestions = parseInt(mcqNumQuestionsInput.value, 10) || 5;
                if (!topic) { itemPreviewArea.innerHTML = '<p style="color: red;">Please enter a topic for MCQs.</p>'; isValid = false; }
                else if (numQuestions < 2 || numQuestions > 15) { itemPreviewArea.innerHTML = '<p style="color: red;"># questions must be 2-15.</p>'; isValid = false; }
                else { fetchUrl = '/generate_mcq'; }
            } else if (selectedMode === 'trueFalse') {
                topic = tfTopicInput.value.trim();
                gradeLevel = tfGradeLevelSelect.value;
                numStatements = parseInt(tfNumStatementsInput.value, 10) || 8;
                if (!topic) { itemPreviewArea.innerHTML = '<p style="color: red;">Please enter a topic for T/F.</p>'; isValid = false; }
                else if (numStatements < 3 || numStatements > 20) { itemPreviewArea.innerHTML = '<p style="color: red;"># statements must be 3-20.</p>'; isValid = false; }
                else { fetchUrl = '/generate_true_false'; }
            } else if (selectedMode === 'shortAnswer') {
                topic = saTopicInput.value.trim();
                gradeLevel = saGradeLevelSelect.value;
                numQuestions = parseInt(saNumQuestionsInput.value, 10) || 5;
                if (!topic) { itemPreviewArea.innerHTML = '<p style="color: red;">Please enter a topic for SA.</p>'; isValid = false; }
                else if (numQuestions < 2 || numQuestions > 10) { itemPreviewArea.innerHTML = '<p style="color: red;"># questions must be 2-10.</p>'; isValid = false; }
                else { fetchUrl = '/generate_short_answer'; }
            } else if (selectedMode === 'similarQ') {
                exampleQuestion = sqExampleInput.value; // Keep raw value
                numQuestions = parseInt(sqNumQuestionsInput.value, 10) || 3;
                gradeLevel = sqGradeLevelSelect.value;
                if (!exampleQuestion || !exampleQuestion.trim()) { itemPreviewArea.innerHTML = '<p style="color: red;">Please paste the example question.</p>'; isValid = false; }
                else if (numQuestions < 1 || numQuestions > 10) { itemPreviewArea.innerHTML = '<p style="color: red;"># questions must be 1-10.</p>'; isValid = false; }
                else { fetchUrl = '/generate_similar_questions'; }
                topic = null; numStatements = null; youtubeUrl = null; pastedText = null; // Reset others
            } else {
                // Should not happen with radio buttons, but good fallback
                itemPreviewArea.innerHTML = '<p style="color: red;">Invalid mode selected.</p>';
                isValid = false;
            }
            // --- End of Prepare / Validate ---

            // Exit if validation failed
            if (!isValid) {
                 if (!itemPreviewArea.innerHTML.includes('color: red')) { itemPreviewArea.innerHTML = '<p style="color: red;">Please check your inputs.</p>'; }
                 generateButton.disabled = false; // Re-enable only Generate
                 toggleEditButton.disabled = true; saveButton.disabled = true; addToSheetButton.disabled = true; // Keep others disabled
                 return;
            }

            // Handle Direct Text case (no API call)
            if (useDirectText) {
                 console.log("Using direct text input.");
                 const directTextContent = tbDirectInput.value; // Use original value
                 itemPreviewArea.innerHTML = parseAndStructureTextBlock(directTextContent); // Use parser
                 // Enable buttons for direct text
                 toggleEditButton.disabled = false; saveButton.disabled = false; addToSheetButton.disabled = false;
                 isEditingEnabled = false; toggleEditButton.textContent = 'Enable Editing'; saveButton.textContent = 'Save to Library';
                 generateButton.disabled = false; // Re-enable generate button
                 return; // Exit listener early
            }

            // Build the Payload Object only if we have a fetchUrl
            if (fetchUrl) {
                 payload = { item_type: selectedMode }; // Start with common field

                 // Add fields conditionally based on the outer variables that were assigned
                 if (topic !== null) payload.topic = topic;
                 if (gradeLevel !== null && gradeLevel !== "Not Specified") payload.grade_level = gradeLevel;
                 // youtubeUrl is no longer used
                 if (pastedText !== null) payload.pasted_text = pastedText; // Send raw pasted text
                 if (exampleQuestion !== null) payload.example_question = exampleQuestion; // Send raw example q

                 // Handle different number keys based on mode
                 if (numQuestions !== null && ['mcq', 'shortAnswer', 'pastedText', 'similarQ'].includes(selectedMode)) {
                     payload.num_questions = numQuestions;
                 }
                 if (numSentences !== null && selectedMode === 'gapFill') {
                     payload.num_sentences = numSentences;
                 }
                 if (numStatements !== null && selectedMode === 'trueFalse') {
                     payload.num_statements = numStatements;
                 }

                 // --- Make API Call ---
                 try {
                    console.log(`Fetching ${fetchUrl} with final payload:`, payload);
                    const response = await fetch(fetchUrl, {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) });
                    const data = await response.json();
                    console.log('Raw data received from backend:', data);
                    if (!response.ok) { throw new Error(data.message || `HTTP error! status: ${response.status}`); }

                    if (data.status === 'success') {
                        let rawContent = ''; let outputHtml = '';
                        // --- Response Handling (Select correct parser based on mode/key) ---
                        if (selectedMode === 'gapFill' && data.worksheet_content) { rawContent = data.worksheet_content; outputHtml = parseAndStructureGapFill(rawContent); }
                        else if (selectedMode === 'pastedText' && data.pasted_comprehension_content) { rawContent = data.pasted_comprehension_content; outputHtml = parseAndStructurePastedComprehension(rawContent); }
                        else if (selectedMode === 'mcq' && data.mcq_content) { rawContent = data.mcq_content; outputHtml = parseAndStructureMCQ(rawContent); }
                        else if (selectedMode === 'trueFalse' && data.true_false_content) { rawContent = data.true_false_content; outputHtml = parseAndStructureTrueFalse(rawContent); }
                        else if (selectedMode === 'shortAnswer' && data.short_answer_content) { rawContent = data.short_answer_content; outputHtml = parseAndStructureShortAnswer(rawContent); }
                        else if (selectedMode === 'similarQ' && data.similar_questions_content) { rawContent = data.similar_questions_content; outputHtml = parseAndStructureSimilarQuestions(rawContent); } // Added similarQ
                        else if (selectedMode === 'textBlock' && data.text_block_content) { rawContent = data.text_block_content; outputHtml = parseAndStructureTextBlock(rawContent); tbDirectInput.value = rawContent; }
                        else { console.error("Success status but missing expected content key.", data); throw new Error('Generation succeeded but expected content key was not found.'); }

                        itemPreviewArea.innerHTML = outputHtml; // Display result
                        // Enable appropriate buttons on success
                        toggleEditButton.disabled = false;
                        saveButton.disabled = false;
                        addToSheetButton.disabled = false;
                        isEditingEnabled = false;
                        toggleEditButton.textContent = 'Enable Editing';
                        saveButton.textContent = 'Save to Library';

                    } else { console.error("Backend returned status !== 'success'", data); throw new Error(data.message || 'Generation failed on the server.'); }
                 } catch (error) {
                    console.error('Error during generation fetch/processing:', error);
                    itemPreviewArea.innerHTML = `<p style="color: red;">Error: ${error.message}. Check console for details.</p>`;
                    // Keep Edit/Save/Add disabled on error
                    toggleEditButton.disabled = true; saveButton.disabled = true; addToSheetButton.disabled = true;
                 } finally {
                    generateButton.disabled = false; // Always re-enable Generate button
                 }
            } else { // This block handles: isValid=true AND useDirectText=false AND fetchUrl='' (Shouldn't happen ideally)
                console.error("LOGIC ERROR: Validation passed, not using direct text, but no fetch URL was set for mode:", selectedMode);
                itemPreviewArea.innerHTML = `<p style="color: red;">Internal error: Could not determine action for mode '${selectedMode}'.</p>`;
                generateButton.disabled = false; // Re-enable button
            }
        }); // End of generateButton listener 
        

        toggleEditButton.addEventListener('click', () => { /* ... Keep unchanged ... */
             isEditingEnabled = !isEditingEnabled; const contentElements = itemPreviewArea.querySelectorAll('.worksheet-section p, .worksheet-section li'); if (isEditingEnabled) { toggleEditButton.textContent = 'Disable Editing'; saveButton.disabled = true; contentElements.forEach(el => { el.contentEditable = true; el.classList.add('editable-content'); }); itemPreviewArea.style.border = '2px solid blue'; console.log("Editing enabled."); } else { toggleEditButton.textContent = 'Enable Editing'; saveButton.disabled = false; contentElements.forEach(el => { el.contentEditable = false; el.classList.remove('editable-content'); }); itemPreviewArea.style.border = '1px solid #ccc'; console.log("Editing disabled."); }
        });

        saveButton.addEventListener('click', async () => {
             // Check if editing is enabled
             if (isEditingEnabled) {
                 alert("Please disable editing before saving.");
                 return;
             }

            const selectedMode = document.querySelector('input[name="generatorMode"]:checked').value;
            // Declare metadata variables
            let source_topic = null;
            let source_url = null; // Keep null for now unless a mode uses it
            let gradeLevel = null;
            let isValidMeta = true; // ** Declare isValidMeta **

            // Gather metadata based on the mode ACTIVE WHEN SAVING
            // Uses the values currently shown in the inputs for context
            if (selectedMode === 'gapFill') {
                source_topic = topicInput.value.trim();
                gradeLevel = gradeLevelSelect.value;
                if (!source_topic) { alert("Cannot save without topic context."); isValidMeta = false; }
            } else if (selectedMode === 'textBlock') {
                 source_topic = tbTopicInput.value.trim() || "User Provided Text"; // Use topic if available
                 grade_level = tbGradeLevelSelect.value;
            } else if (selectedMode === 'pastedText') {
                 source_topic = "Pasted Text Comprehension"; // Placeholder topic
                 grade_level = "mixed"; // Placeholder grade
                 source_url = null;
            } else if (selectedMode === 'mcq') {
                source_topic = mcqTopicInput.value.trim();
                gradeLevel = mcqGradeLevelSelect.value;
                if (!source_topic) { alert("Cannot save without topic context."); isValidMeta = false; }
            } else if (selectedMode === 'trueFalse') {
                 source_topic = tfTopicInput.value.trim();
                 gradeLevel = tfGradeLevelSelect.value;
                 if (!source_topic) { alert("Cannot save without topic context."); isValidMeta = false; }
            } else if (selectedMode === 'shortAnswer') {
                 source_topic = saTopicInput.value.trim();
                 gradeLevel = saGradeLevelSelect.value;
                 if (!source_topic) { alert("Cannot save without topic context."); isValidMeta = false; }
            } else if (selectedMode === 'similarQ') {
                 // Save the example question as the topic for now? Or first few words?
                 source_topic = sqExampleInput.value.substring(0, 50).trim() + "... (Similar Q)";
                 gradeLevel = sqGradeLevelSelect.value;
                 if (!sqExampleInput.value.trim()) { alert("Cannot save similar question without original example text."); isValidMeta = false; }
            } else {
                alert("Unknown item type selected for saving.");
                isValidMeta = false;
            }

            // Exit if basic metadata validation failed
            if (!isValidMeta) { return; }

            // Get Content HTML and validate it
            const content_html = itemPreviewArea.innerHTML;
            if (!content_html || content_html.includes('click Generate') || content_html.includes('<div class="loading">')) {
                alert("Cannot save empty or placeholder content.");
                return;
            }

            // Prepare payload
            const payload = {
                item_type: selectedMode,
                source_topic: source_topic,
                source_url: source_url, // Will be null for most
                grade_level: gradeLevel,
                content_html: content_html
            };

            console.log("Saving payload:", payload);
            saveButton.disabled = true;
            saveButton.textContent = 'Saving...';

            // Make fetch call
            try {
                const response = await fetch('/save_item', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const result = await response.json();
                if (!response.ok || result.status !== 'success') { throw new Error(result.message || `HTTP error! status: ${response.status}`); }
                alert("Item saved successfully!");
                if (result.item_id) {
                    currentPreviewItemId = result.item_id;
                    console.log('Item saved successfully! Stored ID:', currentPreviewItemId);
                    alert(`Item saved successfully! ID: ${currentPreviewItemId}`);
                } else {
                    // This case should ideally not happen if backend is correct
                    currentPreviewItemId = null; // Ensure ID is null if not returned
                    console.warn('Item saved, but item_id was missing in the response:', result);
                    alert("Item saved, but failed to retrieve its ID.");
                }
                saveButton.textContent = 'Saved!'; // Indicate success
            } catch (error) {
                console.error("Error saving item:", error);
                alert(`Error saving item: ${error.message}`);
                saveButton.textContent = 'Save to Library'; // Reset text
                saveButton.disabled = false; // Re-enable on error
                currentPreviewItemId = null;
            }
        }); // <-- End of saveButton listener
        // --- SAVE WORKSHEET LISTENER ---
        saveWorksheetButton.addEventListener('click', async () => {
        const worksheetTitle = worksheetTitleInput.value.trim() || "Untitled Worksheet"; // Get title or use default
        const itemsInWorksheet = worksheetAssemblyArea.querySelectorAll('.worksheet-item'); // Get all item divs

        if (itemsInWorksheet.length === 0) {
            alert("Cannot save an empty worksheet. Please add items first.");
            return;
        }

        // --- Extract Ordered Item IDs ---
        // We need to have stored the original GeneratedItem ID on each worksheet item div when it was added
        const orderedItemIds = [];
        itemsInWorksheet.forEach(itemDiv => {
            const itemId = itemDiv.dataset.generatedItemId; // ** We need to ADD this data attribute later **
            if (itemId) {
                orderedItemIds.push(itemId);
            } else {
                console.warn("Found a worksheet item without a generatedItemId dataset.", itemDiv);
                // Optionally alert the user or skip? For now, we skip.
            }
        });

        if (orderedItemIds.length === 0) {
             alert("Could not find item IDs to save. Ensure items were added correctly.");
             return;
        }

        // --- Prepare Payload ---
        const payload = {
            title: worksheetTitle,
            item_ids: orderedItemIds // Send the array of IDs in order
        };
        console.log("Saving Worksheet Payload:", payload);

        // --- Send to Backend ---
        saveWorksheetButton.disabled = true;
        saveWorksheetButton.textContent = 'Saving...';
        try {
            const response = await fetch('/save_worksheet', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();
            if (!response.ok || result.status !== 'success') {
                throw new Error(result.message || `HTTP error! status: ${response.status}`);
            }
            alert(`Worksheet '${worksheetTitle}' saved successfully! (ID: ${result.worksheet_id})`);
            worksheetTitleInput.value = ''; // Clear title input maybe?
            saveWorksheetButton.textContent = 'Worksheet Saved';
            // Optionally reload the worksheet list?
            // loadWorksheetsButton.click(); // Trigger loading the list again

        } catch (error) {
            console.error("Error saving worksheet:", error);
            alert(`Error saving worksheet: ${error.message}`);
            saveWorksheetButton.textContent = 'Save This Worksheet';
            saveWorksheetButton.disabled = false; // Re-enable on error
        } finally {
             // Decide if button should stay disabled after successful save or re-enable
             // saveWorksheetButton.disabled = false;
        }
    });
    // --- END OF SAVE WORKSHEET LISTENER ---
    // --- LOAD WORKSHEETS LIST LISTENER ---
    loadWorksheetsButton.addEventListener('click', async () => {
        savedWorksheetsList.innerHTML = '<div class="loading">Loading worksheet list...</div>';
        loadWorksheetsButton.disabled = true;
        try {
            const response = await fetch('/list_worksheets');
            const data = await response.json();
            if (!response.ok || data.status !== 'success') {
                throw new Error(data.message || `HTTP error! status: ${response.status}`);
            }

            if (data.worksheets && data.worksheets.length > 0) {
                savedWorksheetsList.innerHTML = ''; // Clear
                const list = document.createElement('ul');
                list.style.listStyle = 'none'; list.style.padding = '0';
                data.worksheets.forEach(ws => {
                    const listItem = document.createElement('li');
                    listItem.style.borderBottom = '1px dashed #eee';
                    listItem.style.marginBottom = '10px';
                    listItem.style.paddingBottom = '10px';
                    listItem.innerHTML = `
                        <strong>${ws.title}</strong> (ID: ${ws.id})<br>
                        <small>Last Modified: ${new Date(ws.last_modified_date).toLocaleString()}</small>
                        <button data-worksheet-id="${ws.id}" class="load-worksheet-button" style="margin-left: 15px; padding: 2px 8px; font-size: 0.8em; background-color:#ffc107; color:black;">Load This Worksheet</button>
                        <button data-worksheet-id="${ws.id}" class="export-docx-button" style="margin-left: 5px; padding: 2px 8px; font-size: 0.8em; background-color:#007bff; color:white;">Export DOCX</button>
                        <!-- Add Delete Worksheet button later -->
                    `;
                    list.appendChild(listItem);
                });
                savedWorksheetsList.appendChild(list);
            } else {
                savedWorksheetsList.innerHTML = '<p>No saved worksheets found.</p>';
            }
        } catch (error) {
            console.error("Error loading worksheet list:", error);
            savedWorksheetsList.innerHTML = `<p style="color: red;">Error loading worksheet list: ${error.message}</p>`;
        } finally {
            loadWorksheetsButton.disabled = false;
        }
    });
    // --- END OF LOAD WORKSHEETS LIST LISTENER ---
    // --- LOAD SPECIFIC WORKSHEET LISTENER (Event Delegation) ---
    savedWorksheetsList.addEventListener('click', async (event) => {

// --- Handler for LOAD WORKSHEET Button ---
if (event.target.classList.contains('load-worksheet-button')) {
    const button = event.target;
    const worksheetId = button.dataset.worksheetId;
    if (!worksheetId) return;

    console.log(`Load worksheet button clicked for ID: ${worksheetId}`); // Correct log for loading
    worksheetAssemblyArea.innerHTML = '<div class="loading">Loading worksheet items...</div>';
    // Disable buttons while loading
    button.disabled = true;
    loadWorksheetsButton.disabled = true;
    clearSheetButton.disabled = true;

    try {
        const response = await fetch(`/load_worksheet/${worksheetId}`);
        const data = await response.json();

        if (!response.ok || data.status !== 'success') {
            throw new Error(data.message || `HTTP error! status: ${response.status}`);
        }

        // --- Rebuild Worksheet Assembly Area ---
        worksheetAssemblyArea.innerHTML = '';
        worksheetTitleInput.value = data.worksheet_title || '';

        if (data.items && data.items.length > 0) {
            data.items.forEach(itemData => {
                const worksheetItem = document.createElement('div');
                worksheetItem.classList.add('worksheet-item');
                worksheetItem.dataset.generatedItemId = itemData.id;
                // Apply styles (keep your existing style code)
                worksheetItem.style.border = '1px solid #a0a0a0';
                worksheetItem.style.padding = '15px';
                worksheetItem.style.marginBottom = '15px';
                worksheetItem.style.backgroundColor = 'white';
                worksheetItem.style.overflow = 'hidden';

                // Add controls (Remove, Move Up, Down) (keep your existing control creation code)
                const controlsDiv = document.createElement('div');
                controlsDiv.style.marginBottom = '10px'; controlsDiv.style.textAlign = 'right';
                // Move Up Button code...
                const moveUpButton = document.createElement('button'); moveUpButton.textContent = '⬆️ Up'; /* Add styles + onclick */ moveUpButton.style.backgroundColor = '#6c757d'; moveUpButton.style.color = 'white'; moveUpButton.style.padding = '3px 8px'; moveUpButton.style.fontSize = '0.8em'; moveUpButton.style.marginLeft = '5px'; moveUpButton.title = 'Move item up'; moveUpButton.onclick = () => { const currentItem = worksheetItem; const previousItem = currentItem.previousElementSibling; if (previousItem && previousItem.classList.contains('worksheet-item')) { worksheetAssemblyArea.insertBefore(currentItem, previousItem); }}; controlsDiv.appendChild(moveUpButton);
                // Move Down Button code...
                const moveDownButton = document.createElement('button'); moveDownButton.textContent = '⬇️ Down'; /* Add styles + onclick */ moveDownButton.style.backgroundColor = '#6c757d'; moveDownButton.style.color = 'white'; moveDownButton.style.padding = '3px 8px'; moveDownButton.style.fontSize = '0.8em'; moveDownButton.style.marginLeft = '5px'; moveDownButton.title = 'Move item down'; moveDownButton.onclick = () => { const currentItem = worksheetItem; const nextItem = currentItem.nextElementSibling; if (nextItem && nextItem.classList.contains('worksheet-item')) { worksheetAssemblyArea.insertBefore(nextItem, currentItem); }}; controlsDiv.appendChild(moveDownButton);
                // Remove Button code...
                const removeButton = document.createElement('button'); removeButton.textContent = '❌ Remove'; /* Add styles + onclick */ removeButton.style.backgroundColor = '#dc3545'; removeButton.style.color = 'white'; removeButton.style.padding = '3px 8px'; removeButton.style.fontSize = '0.8em'; removeButton.style.marginLeft = '5px'; removeButton.title = 'Remove item from worksheet'; removeButton.onclick = () => { worksheetItem.remove(); if (worksheetAssemblyArea.querySelectorAll('.worksheet-item').length === 0) {worksheetAssemblyArea.innerHTML = '<p style="color: grey; font-style: italic;">Items added to the worksheet will appear here.</p>';}}; controlsDiv.appendChild(removeButton);
                worksheetItem.appendChild(controlsDiv);

                // Add content (keep your existing content creation code)
                const contentDiv = document.createElement('div');
                contentDiv.style.clear = 'both';
                contentDiv.innerHTML = itemData.content_html;
                worksheetItem.appendChild(contentDiv);

                // Append to assembly area
                worksheetAssemblyArea.appendChild(worksheetItem);
            });
        } else {
             worksheetAssemblyArea.innerHTML = '<p style="color: grey; font-style: italic;">Worksheet loaded but contains no items.</p>';
        }
        console.log(`Worksheet ${worksheetId} loaded successfully.`);

    } catch (error) {
        console.error(`Error loading worksheet ${worksheetId}:`, error);
        worksheetAssemblyArea.innerHTML = `<p style="color: red;">Error loading worksheet: ${error.message}</p>`;
    } finally {
         // Re-enable buttons
         loadWorksheetsButton.disabled = false;
         clearSheetButton.disabled = false;
         // Re-enable specific button?
         // button.disabled = false; // Maybe not, let user reload list if needed
    }
} // --- END of 'load-worksheet-button' Handler ---


// --- Handler for EXPORT DOCX Button ---
else if (event.target.classList.contains('export-docx-button')) {
    const button = event.target;
    const worksheetId = button.dataset.worksheetId;
    if (!worksheetId) {
        console.error("Export DOCX button clicked but worksheet ID is missing.");
        return;
    }
    // Use the CORRECT log message here
    console.log(`Export DOCX button clicked for ID: ${worksheetId}`);
    console.log(`Attempting to navigate to: /export/docx/${worksheetId}`); // Add this log

    // Directly navigate to the export URL - the backend will handle the download
    window.location.href = `/export/docx/${worksheetId}`;

    // Optional: Add visual feedback? e.g., briefly disable button
    button.disabled = true;
    button.textContent = 'Exporting...'
    setTimeout(() => { // Re-enable after a short delay
         button.disabled = false;
         button.textContent = 'Export DOCX';
    }, 2000); // Re-enable after 2 seconds

} // --- END of 'export-docx-button' Handler ---

// --- Add other handlers (e.g., delete) using else if blocks here ---

}); // --- END of savedWorksheetsList listener ---

    // --- END OF LOAD SPECIFIC WORKSHEET LISTENER ---
        loadLibraryButton.addEventListener('click', async () => { /* ... Keep unchanged ... */
             libraryOutput.innerHTML = '<div class="loading">Loading library...</div>'; loadLibraryButton.disabled = true; try { const response = await fetch('/list_items'); const data = await response.json(); if (!response.ok || data.status !== 'success') { throw new Error(data.message || `HTTP error! Status: ${response.status}`); } if (data.items && data.items.length > 0) { libraryOutput.innerHTML = ''; const list = document.createElement('ul'); list.style.listStyle = 'none'; list.style.padding = '0'; data.items.forEach(item => { const listItem = document.createElement('li'); let description = `Type: ${item.item_type}`; if(item.source_topic) description += `, Topic: ${item.source_topic}`; if(item.source_url) description += `, URL: <small>${item.source_url}</small>`; description += `, Grade: ${item.grade_level}`; listItem.innerHTML = `<strong>ID: ${item.id}</strong> - ${description} <br><small>Last Modified: ${new Date(item.last_modified).toLocaleString()}</small><button data-item-id="${item.id}" class="load-item-button" style="margin-left: 15px; padding: 2px 8px; font-size: 0.8em;">Load Item</button>`; list.appendChild(listItem); }); libraryOutput.appendChild(list); } else { libraryOutput.innerHTML = '<p>No saved items found in the library.</p>'; } } catch (error) { console.error("Error loading library:", error); libraryOutput.innerHTML = `<p style="color: red;">Error loading library: ${error.message}</p>`; } finally { loadLibraryButton.disabled = false; }
        });
        addToSheetButton.addEventListener('click', () => {
    console.log("Add to Sheet button clicked.");
    // Ensure editing is off before adding
    if (isEditingEnabled) {
        alert("Please disable editing before adding the item to the worksheet.");
        return;
    }
    if (currentPreviewItemId === null) {
        alert("Cannot add item to worksheet. Please save the current item first, or load an existing item from the library.");
        return;
    }

    // Get the HTML content from the preview area
    const previewContent = itemPreviewArea.innerHTML;

    // Check if the preview content is valid (not empty, loading, or placeholder)
    if (!previewContent || previewContent.trim() === '' || previewContent.includes('will appear here') || previewContent.includes('<div class="loading">')) {
        alert("No valid item in the preview area to add.");
        return;
    }

    // --- Create a wrapper div for the item on the worksheet ---
    const worksheetItem = document.createElement('div');
    worksheetItem.classList.add('worksheet-item'); // For potential future styling/identification
    worksheetItem.dataset.generatedItemId = currentPreviewItemId;
    // Add some basic inline styles for visibility for now
    worksheetItem.style.border = '1px solid #a0a0a0';
    worksheetItem.style.padding = '15px';
    worksheetItem.style.marginBottom = '15px';
    worksheetItem.style.backgroundColor = 'white';
    worksheetItem.style.overflow = 'hidden'; // Contains floats

    // --- Add controls to the item (e.g., Remove button) ---
    const controlsDiv = document.createElement('div');
    controlsDiv.style.marginBottom = '10px'; // Space below controls


// --- Add controls to the item (Remove, Move Up, Move Down) ---
    controlsDiv.style.marginBottom = '10px';
    controlsDiv.style.textAlign = 'right'; // Align buttons to the right

    // MOVE UP BUTTON
    const moveUpButton = document.createElement('button');
    moveUpButton.textContent = '⬆️ Up'; // Or use text 'Up'
    moveUpButton.style.backgroundColor = '#6c757d'; // Grey
    moveUpButton.style.color = 'white';
    moveUpButton.style.padding = '3px 8px';
    moveUpButton.style.fontSize = '0.8em';
    moveUpButton.style.marginLeft = '5px';
    moveUpButton.title = 'Move item up'; // Tooltip
    moveUpButton.onclick = () => {
        const currentItem = worksheetItem; // The item this button belongs to
        const previousItem = currentItem.previousElementSibling;
        // Check if it's not the first item (previousElementSibling exists and is a worksheet item)
        if (previousItem && previousItem.classList.contains('worksheet-item')) {
            worksheetAssemblyArea.insertBefore(currentItem, previousItem);
            console.log("Moved item up.");
        } else {
            console.log("Cannot move first item up.");
        }
    };
    controlsDiv.appendChild(moveUpButton);

    // MOVE DOWN BUTTON
    const moveDownButton = document.createElement('button');
    moveDownButton.textContent = '⬇️ Down'; // Or use text 'Down'
    moveDownButton.style.backgroundColor = '#6c757d'; // Grey
    moveDownButton.style.color = 'white';
    moveDownButton.style.padding = '3px 8px';
    moveDownButton.style.fontSize = '0.8em';
    moveDownButton.style.marginLeft = '5px';
    moveDownButton.title = 'Move item down'; // Tooltip
    moveDownButton.onclick = () => {
        const currentItem = worksheetItem;
        const nextItem = currentItem.nextElementSibling;
         // Check if it's not the last item (nextElementSibling exists)
         // We assume anything after it would also be a worksheet-item if present
        if (nextItem && nextItem.classList.contains('worksheet-item')) {
            // Insert the *next* item before the *current* item, effectively moving current down
            worksheetAssemblyArea.insertBefore(nextItem, currentItem);
            console.log("Moved item down.");
        } else {
            console.log("Cannot move last item down.");
        }
    };
    controlsDiv.appendChild(moveDownButton);

    // REMOVE BUTTON (Keep existing logic)
    const removeButton = document.createElement('button');
    removeButton.textContent = '❌ Remove'; // Or use text 'Remove'
    // removeButton.style.float = 'right'; // No longer needed with textAlign: right on container
    removeButton.style.backgroundColor = '#dc3545'; // Red color
    removeButton.style.color = 'white';
    removeButton.style.padding = '3px 8px';
    removeButton.style.fontSize = '0.8em';
    removeButton.style.marginLeft = '5px';
    removeButton.title = 'Remove item from worksheet'; // Tooltip
    removeButton.onclick = () => {
         worksheetItem.remove();
         console.log("Worksheet item removed.");
         if (worksheetAssemblyArea.querySelectorAll('.worksheet-item').length === 0) {
              worksheetAssemblyArea.innerHTML = '<p style="color: grey; font-style: italic;">Items added to the worksheet will appear here.</p>';
         }
    };
    controlsDiv.appendChild(removeButton); // Add remove button last

    // Add controls div to the top of the item wrapper
    worksheetItem.appendChild(controlsDiv);

    // --- Add the actual content from the preview ---
    const contentDiv = document.createElement('div');
    contentDiv.style.clear = 'both'; // Ensure content clears floated button
    contentDiv.innerHTML = previewContent;
    worksheetItem.appendChild(contentDiv);
    // Define what happens when the remove button is clicked
    removeButton.onclick = () => {
         worksheetItem.remove(); // Remove the entire item div
         console.log("Worksheet item removed.");
         // Check if assembly area is empty after removal to restore placeholder
         if (worksheetAssemblyArea.querySelectorAll('.worksheet-item').length === 0) {
              worksheetAssemblyArea.innerHTML = '<p style="color: grey; font-style: italic;">Items added to the worksheet will appear here.</p>';
         }
    };
    controlsDiv.appendChild(removeButton); // Add button to controls div
    // Add other controls (like move up/down) here later if needed

    // Add controls div to the top of the item wrapper
    worksheetItem.appendChild(controlsDiv);

    // --- Add the actual content from the preview ---
    contentDiv.style.clear = 'both'; // Ensure content clears floated button
    contentDiv.innerHTML = previewContent; // Put the preview HTML inside this div
    worksheetItem.appendChild(contentDiv); // Add content div to the item wrapper


    // --- Append the complete item to the Assembly Area ---
    // Clear placeholder text if it's the first item being added
    const placeholder = worksheetAssemblyArea.querySelector('p');
    if (placeholder && placeholder.textContent.includes('Items added to the worksheet')) {
         worksheetAssemblyArea.innerHTML = ''; // Clear the placeholder
    }
    worksheetAssemblyArea.appendChild(worksheetItem); // Add the new item

    console.log("Item appended to worksheet assembly area.");

    // Optional: Clear preview area and disable buttons after adding?
    // itemPreviewArea.innerHTML = 'Item added to worksheet below. Generate or load another.';
    // toggleEditButton.disabled = true;
    // saveButton.disabled = true;
    // addToSheetButton.disabled = true;
});

        libraryOutput.addEventListener('click', async (event) => { /* ... Keep unchanged ... */
             if (event.target.classList.contains('load-item-button')) { const button = event.target; const itemId = button.dataset.itemId; if (!itemId) { console.error("Load button clicked but item ID is missing."); return; } console.log(`Load button clicked for item ID: ${itemId}`); libraryOutput.querySelectorAll('.load-item-button').forEach(btn => btn.disabled = true); itemPreviewArea.innerHTML = '<div class="loading">Loading item...</div>'; toggleEditButton.disabled = true; saveButton.disabled = true;addToSheetButton.disabled = true; try { const response = await fetch(`/get_item/${itemId}`); const data = await response.json(); if (!response.ok || data.status !== 'success') { throw new Error(data.message || `HTTP error! Status: ${response.status}`); } if (data.item && data.item.content_html) { itemPreviewArea.innerHTML = data.item.content_html; currentPreviewItemId = data.item.id;
                console.log(`Successfully loaded item ${itemId}. Stored ID: ${currentPreviewItemId}`); toggleEditButton.disabled = false; saveButton.disabled = false; addToSheetButton.disabled = false; isEditingEnabled = false; toggleEditButton.textContent = 'Enable Editing'; saveButton.textContent = 'Save to Library'; itemPreviewArea.scrollIntoView({ behavior: 'smooth', block: 'start' }); console.log(`Successfully loaded item ${itemId} into editor.`); } else { throw new Error("Item data received successfully, but content_html was missing."); } } catch (error) { console.error(`Error loading item ${itemId}:`, error); itemPreviewArea.innerHTML = `<p style="color: red;">Error loading item: ${error.message}</p>`; toggleEditButton.disabled = true; saveButton.disabled = true;addToSheetButton.disabled = true; } finally { libraryOutput.querySelectorAll('.load-item-button').forEach(btn => btn.disabled = false); } }
        });
        clearSheetButton.addEventListener('click', () => {
    // Ask for confirmation
    if (confirm("Are you sure you want to clear all items from the worksheet assembly area?")) {
        // Reset the innerHTML to the placeholder text
        worksheetAssemblyArea.innerHTML = '<p style="color: grey; font-style: italic;">Items added to the worksheet will appear here.</p>';
        console.log("Worksheet assembly area cleared.");
    }
});


        // --- Initialization ---
        handleModeChange(); // Call once on load to set initial state

    </script>
</body>
</html>